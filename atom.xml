<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LexLady</title>
  
  
  <link href="http://lexlady.top/atom.xml" rel="self"/>
  
  <link href="http://lexlady.top/"/>
  <updated>2023-04-01T13:32:20.978Z</updated>
  <id>http://lexlady.top/</id>
  
  <author>
    <name>Lexlady</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Ethernaut</title>
    <link href="http://lexlady.top/2023/02/25/Ether/"/>
    <id>http://lexlady.top/2023/02/25/Ether/</id>
    <published>2023-02-25T12:44:02.000Z</published>
    <updated>2023-04-01T13:32:20.978Z</updated>
    
    <content type="html"><![CDATA[<p>此文章会记录在Ethernaut上经历的题。</p><span id="more"></span><h1 id="1-Hello-Ethernaut"><a href="#1-Hello-Ethernaut" class="headerlink" title="1.Hello Ethernaut"></a>1.Hello Ethernaut</h1><p>在第一题中，我们会跟着引导通过web终端进行操作，基本上没什么难度，一步步地按照提示来做就行。<del>你甚至可以通过直接查看合约ABI来推断出答案，实在是太友好了！！</del><br>收获：  </p><ul><li>关键字的使用</li><li>各种变量的存储位置</li></ul><hr><h1 id="2-Fallback"><a href="#2-Fallback" class="headerlink" title="2.Fallback"></a>2.Fallback</h1><p>任务要求：获取合约的所有权；将余额减为零</p><p>解题点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">receive() external payable &#123;<br>  require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);<br>  owner = msg.sender;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>receive方法</p><ul><li>一个合约至多含有一个receive()函数,</li><li>没有function关键字、没有参数，没有返回值</li><li>可见性必须声明为external，必须含有payable关键字</li><li>允许使用modifier修改器</li></ul><p>当本合约收到ether但并未被调用任何函数，未接受任何数据，receive函数被触发，执行ether的传输（类似于基本的send(),transfer()函数）；如果合约中不存在此类方法，但拥有一个可支付的回退函数将触发回退函数执行ether的操作；如果都不存在，那么合约将不能接受ether并抛出异常</p><p>选自<a href="https://docs.soliditylang.org/en/v0.8.13/contracts.html#receive-ether-function">solidity官方文档v0.8.13</a></p></blockquote><p>参考：1）执行实例中的contribute方法，向合约发送最多0.001ether。2）向合约发送以太，触发receive方法。3）执行实例中的withdraw方法</p><hr><h1 id="3-Fallout"><a href="#3-Fallout" class="headerlink" title="3.Fallout"></a>3.Fallout</h1><p>任务要求：获取合约的所有权<del>卖眼镜的做的题</del></p><p>解题点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Fallout is Ownable &#123;...<br><br>function Fal1out() public payable &#123;...<br></code></pre></td></tr></table></figure><p>作为构造函数其名称居然与合约名称不一致，使其成为了任何人都可以执行的公共函数</p><blockquote><p>在solidity 0.4.22版本及其之后中使用function声明构造函数的方法被舍弃，而采用了使用关键字constructor来声明构造函数。</p><blockquote><p>这是在使用编译器0.4.22之前的版本时所需注意的</p></blockquote></blockquote><p>参考：直接调用函数Fal1out</p><hr><h1 id="4-Coin-Flip"><a href="#4-Coin-Flip" class="headerlink" title="4.Coin Flip"></a>4.Coin Flip</h1><p>任务要求：连续猜对硬币的正反面十次。<del>区区千分之一的运气我也不是没有</del></p><p>解题点：<br>硬币的正反面取决于上一个块，结果看起来是随机的但却是可预测的，我们也可以通过获取上一个区块的信息来运行一次题目的算法然后选择对应的结果。因为在一个区块中的交易不止一个，所以只要保证在生成下一个区块前将完成操作即可。</p><p>参考：<br>获取实例地址<br>在remix上部署一份攻击合约（只需要在获取结果后调用实例）<br>之后连续使用攻击合约的方法进行攻击10次就行</p><blockquote><p>知识点<br>SafeMath库：防溢出的增强型运算方法<br>block.num：当前区块数<br>block.blockhash：区块哈希值</p></blockquote><hr><h1 id="5-Telephone"><a href="#5-Telephone" class="headerlink" title="5.Telephone"></a>5.Telephone</h1><p>任务要求：获取合约的所有权</p><p>解题点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function changeOwner(address _owner) public &#123;<br>    if (tx.origin != msg.sender) &#123;<br>      owner = _owner;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>本题涉及到tx.origin与msg.sender的区别：前者表示交易的发送者，后者则表示消息的发送者。</p><p>如果情景是在一个合约下的调用，那么这两者是木有区别的；但是如果是在多个合约的情况下，比如用户通过A合约来调用B合约，那么对于B合约来说，msg.sender就代表合约A，而tx.origin就代表用户。</p><p>参考：在remix上部署另一个合约，通过该合约调用实例中的方法改变owner</p><hr><h1 id="6-Token"><a href="#6-Token" class="headerlink" title="6.Token"></a>6.Token</h1><p>任务要求：获取更多的Token</p><p>解题点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function transfer(address _to, uint _value) public returns (bool) &#123;<br>    require(balances[msg.sender] - _value &gt;= 0);<br>    balances[msg.sender] -= _value;<br>    balances[_to] += _value;<br>    return true;<br>  &#125;<br></code></pre></td></tr></table></figure><p>这里可以通过<em>下溢</em>绕过require检测，因为_value和balance[]都为无符号整数，所以结果会变为2^256-1</p><p>参考：略</p><hr><h1 id="7-Delegation"><a href="#7-Delegation" class="headerlink" title="7.Delegation"></a>7.Delegation</h1><p>任务要求：获取合约的所有权</p><p>分析：这题包含了两个合约Delegation和Delegate，Delegation合约实例化了Delegate合约，又在其Fallback函数中使用了delegatecall来调用了delegate合约。</p><blockquote><p>call函数是一个能对合约发送数据与合约进行交互的底层接口（它们都接受一个 bytes memory 参数，并返回成功条件（作为一个 bool） 和返回的数据（ bytes memory）。而delegatecall又与call有所不同；通过delegatecall调用的目标地址的代码要在当前合约的环境中执行。这个函数主要是方便我们使用存在其他地方的函数（用户必须确保两个合约中的存储结构都适合使用delegatecall。）</p></blockquote><p>解题点：使用delegatecall调用delegate合约的pwn函数。</p><hr><h1 id="8-Force"><a href="#8-Force" class="headerlink" title="8.Force"></a>8.Force</h1><p>任务要求：让合约的balance大于0</p><p>解题点：<del>MEOW~（不是）</del></p><p>在以太坊中可以强制给一个合约发送以太，无论合约是否拒绝。通过函数selfdestruct来实现。</p><blockquote><p>这是一个自毁函数，当你调用它的时候，它会使该合约无效化并删除该地址的字节码，然后它会把合约里剩余的资金发送给参数所指定的地址，比较特殊的是这笔资金的发送将无视合约的fallback函数，因为我们之前也提到了当合约直接收到一笔不知如何处理的eth时会触发fallback函数，然而selfdestruct的发送的资金会无视这一点。</p></blockquote><p>因此我们只需要创建一个合约往合约中存点eth然后调用selfdestruct发送给实例合约就行。</p><hr><h1 id="9-Vault"><a href="#9-Vault" class="headerlink" title="9.Vault"></a>9.Vault</h1><p>任务要求：将合约中的bool值改变</p><p>解题点：输入密码<del>废话</del></p><p>任何数据在区块链上都是透明的！（战术后仰）通过web3中的getStorageAt函数直接获取合约里的状态变量的值</p><blockquote><p><code>web3.eth.getStorageAt(address, position [, defaultBlock] [, callback])</code><br>参数1：String 获取存储的地址；参数2：存储的索引位置；参数3：（可选）不使用web3.eth.defaultBlock设置的默认块，而是自定义或预定义的块号；参数4：（可选）可选回调，返回一个错误对象作为第一个参数，结果作为第二个参数<br>Returns ：返回给定位置的值</p><p>选自web3.<a href="https://web3js.readthedocs.io/en/v1.2.11/web3-eth.html#getstorageat">eth官方文档</a></p></blockquote><hr><h1 id="10-King"><a href="#10-King" class="headerlink" title="10.King"></a>10.King</h1><p>任务要求：确保王位</p><p>解题点：<code>payable(king).transfer(msg.value);</code></p><p>当新的国王诞生时将会给老国王原来的奖金，那么只要原来的国王不接受直接进行revert，那么就可以永远的占据合约的king</p><p>参考：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma ...<br><br>contract attack&#123;<br>  constructor (address _addr) public payable&#123;<br>    _addr.call&#123;gas:100000000,value:msg.value&#125;;<br>  &#125;<br>  receive() external payable &#123;<br>    revert();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="11-Re-entrancy"><a href="#11-Re-entrancy" class="headerlink" title="11.Re-entrancy"></a>11.Re-entrancy</h1><p>任务要求：盗取合约中的所有代币</p><p>解题点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function withdraw(uint _amount) public &#123;<br>    if(balances[msg.sender] &gt;= _amount) &#123;<br>      (bool result,) = msg.sender.call&#123;value:_amount&#125;(&quot;&quot;);<br>      if(result) &#123;<br>        _amount;<br>      &#125;<br>      balances[msg.sender] -= _amount;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>重入的关键：发送完成后才进行了sender的balances更新，所以只需要使其不断进行call.value发送eth，同样使用Fallback函数来实现</p><h1 id="Elevator"><a href="#Elevator" class="headerlink" title="Elevator"></a>Elevator</h1><p>这个电梯不让你到达顶楼，想办法到达顶楼</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>interface Building &#123;<br>  function isLastFloor(uint) external returns (bool);<br>&#125;<br><br><br>contract Elevator &#123;<br>  bool public top;<br>  uint public floor;<br><br>  function goTo(uint _floor) public &#123;<br>    Building building = Building(msg.sender);<br><br>    if (! building.isLastFloor(_floor)) &#123;<br>      floor = _floor;<br>      top = building.isLastFloor(floor);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该题提供了一个接口，在合约中我们看到接口的isLastFloor函数是用来衡量当前楼层是否是顶楼。所以题解在于如何实现isLastFloor函数。<br>方法中执行了两次isLastFloor函数，在通过条件语句时是取反判定，因此我们可以让函数内部进行取反操作这样就可以在执行两次后得到true值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract attack &#123;<br>    Elevator ele;<br>    bool b = true;<br>    function isLastFloor(uint) view public retuens(bool) &#123;<br>        t = !t;<br>        return t;<br>    &#125;<br>    function hk(address _addr) public &#123;<br>        ele = Elevator(_addr);<br>        ele.goTo(1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="NaughtCoin"><a href="#NaughtCoin" class="headerlink" title="NaughtCoin"></a>NaughtCoin</h1><p>通过转移走合约中的所有余额来完成此关。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>import &#x27;openzeppelin-contracts-08/token/ERC20/ERC20.sol&#x27;;<br><br> contract NaughtCoin is ERC20 &#123;<br><br>  // string public constant name = &#x27;NaughtCoin&#x27;;<br>  // string public constant symbol = &#x27;0x0&#x27;;<br>  // uint public constant decimals = 18;<br>  uint public timeLock = block.timestamp + 10 * 365 days;<br>  uint256 public INITIAL_SUPPLY;<br>  address public player;<br><br>  constructor(address _player) <br>  ERC20(&#x27;NaughtCoin&#x27;, &#x27;0x0&#x27;) &#123;<br>    player = _player;<br>    INITIAL_SUPPLY = 1000000 * (10**uint256(decimals()));<br>    // _totalSupply = INITIAL_SUPPLY;<br>    // _balances[player] = INITIAL_SUPPLY;<br>    _mint(player, INITIAL_SUPPLY);<br>    emit Transfer(address(0), player, INITIAL_SUPPLY);<br>  &#125;<br>  <br>  function transfer(address _to, uint256 _value) override public lockTokens returns(bool) &#123;<br>    super.transfer(_to, _value);<br>  &#125;<br><br>  // Prevent the initial owner from transferring tokens until the timelock has passed<br>  modifier lockTokens() &#123;<br>    if (msg.sender == player) &#123;<br>      require(block.timestamp &gt; timeLock);<br>      _;<br>    &#125; else &#123;<br>     _;<br>    &#125;<br>  &#125; <br>&#125; <br></code></pre></td></tr></table></figure><p>合约导入了ERC20，所以对于代币的转移除了重写的transfer还有transfrom方法，只需要注意transfrom函数还需要额外的操作：approve</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;此文章会记录在Ethernaut上经历的题。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>SpringAOP</title>
    <link href="http://lexlady.top/2022/12/26/SpringAOP/"/>
    <id>http://lexlady.top/2022/12/26/SpringAOP/</id>
    <published>2022-12-26T15:53:12.000Z</published>
    <updated>2022-12-26T15:53:12.882Z</updated>
    
    <content type="html"><![CDATA[<p>Spring AOP是Spring框架体系结构中非常重要的功能模块之一；提供了面向切面编程实现。</p><span id="more"></span><h1 id="Spring-AOP的基本概念"><a href="#Spring-AOP的基本概念" class="headerlink" title="Spring AOP的基本概念"></a>Spring AOP的基本概念</h1><h2 id="AOP的概念"><a href="#AOP的概念" class="headerlink" title="AOP的概念"></a>AOP的概念</h2><p>AOP（Aspect-Oriented Programming）即面向切面编程，相应的就是OOP，面向对象编程。在OOP中，以类作为程序的基本单位，而在AOP中则是以切面作为基本单位。  </p><blockquote><p>在业务处理功能中，通常都有日志记录、事务处理、异常处理等操作，如果是使用OOP可以通过封装或继承的方法实现代码重写来应用到多个业务中，但仍存在同样的代码分散到各个方法中。<br>因此，AOP采取横向抽取机制，将分散在各个方法中的重复代码提取出来，然后在程序编译或运行阶段，再将抽取出来的代码应用到需要执行的地方。  </p></blockquote><p>传统的OOP是无法实现这样的横向抽取机制，因为OOP实现的是父子的纵向重用。但AOP并不是OOP的替代品，而是对OOP的一种补充，进而相辅相成。</p><h2 id="AOP的基本术语"><a href="#AOP的基本术语" class="headerlink" title="AOP的基本术语"></a>AOP的基本术语</h2><ol><li>切面（Aspect）<br>指封装横切到系统功能的类  </li><li>连接点（Joinpoint）<br>指程序运行中的一些时间点（如方法的调用或异常的抛出）  </li><li>切入点（Pointcut）<br>指那些需要处理的连接点，在Spring AOP中，所有的方法执行都是连接点，而切入点是一个描述信息，用来修饰连接点，确定哪些连接点需要被处理。  </li><li>通知（增强处理）<br>由切面添加到特点的连接点（满足切入点规则）的一段代码，</li><li>引入（Introduction）<br>允许在现有的实现类中添加自定义的方法和属性  </li><li>目标对象（Target Object）<br>指所有被通知的对象。</li><li>代理（Proxy）<br>是通知应用到目标对象后，被动态创建的对象</li><li>织入（Weaving）</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;Spring AOP是Spring框架体系结构中非常重要的功能模块之一；提供了面向切面编程实现。&lt;/p&gt;</summary>
    
    
    
    
    <category term="SpringBoot" scheme="http://lexlady.top/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringIoC</title>
    <link href="http://lexlady.top/2022/12/01/SpringIoC/"/>
    <id>http://lexlady.top/2022/12/01/SpringIoC/</id>
    <published>2022-12-01T13:43:42.000Z</published>
    <updated>2022-12-26T15:16:06.751Z</updated>
    
    <content type="html"><![CDATA[<p>简单的对Spring IoC进行介绍,要求理解控制反转的概念；它是如何消减程序的耦合问题的？</p><span id="more"></span><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>下面从一个生活实例对控制反转进行解释（也称依赖注入(Dependency Injection,DI)，只是执行角度不同，是同一个概念）</p><blockquote><p>如果我们要吃饭，就可以有两种选择：一是自己做；另一种是下馆子。当我们要自己做时，就需要自己准备食材、进行烹饪。而下馆子只需要根据自己的需要让店家提供。<br>控制反转的思想便包含在了上述的例子中：<strong>将执行操作交给Spring容器</strong>。<br>由容器控制对象的创建以及查找并注入依赖的资源，而资源则集中管理，<u>实现资源的可配置和易管理</u>，<em>降低了使用资源双方的依赖程度，松耦合</em></p></blockquote><h1 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h1><blockquote><p>在Spring框架中，仅管使用XML配置文件可以很简单地装配Bean，但对于需要配置大量的Bean时，其XML文件会过于庞大，不方便维护。  </p></blockquote><p><strong>因此推荐使用注解(annotation)的方式去装配Bean</strong></p><h2 id="声明Bean的注解"><a href="#声明Bean的注解" class="headerlink" title="声明Bean的注解"></a>声明Bean的注解</h2><ol><li>@Component</li></ol><ul><li>表示一个组件对象(Bean)</li><li>作用于任何层次上</li><li>无明确角色</li><li>一个泛化的概念</li></ul><ol start="2"><li>@Repository</li></ol><ul><li>将数据访问层(Dao)的类标识为Bean</li><li>功能与@Component相同</li></ul><ol start="3"><li>@Service</li></ol><ul><li>标注一个业务逻辑组件类（Service）</li><li>功能与@Component相同</li></ul><ol start="4"><li>@Controller</li></ol><ul><li>用于标注一个控制器组件类（Spring MVC 的Controller）</li><li>功能与@Component相同</li></ul><h2 id="注入Bean的注解"><a href="#注入Bean的注解" class="headerlink" title="注入Bean的注解"></a>注入Bean的注解</h2><ol><li>@Autowired</li></ol><ul><li>可以对类成员变量、方法及构造方法进行标注，完成自动装配的工作</li><li>消除setter getter方法</li></ul><ol start="2"><li>@Resource</li></ol><ul><li>与@Autowired功能一样</li><li>区别：默认是按照名称来装配注入的，只有当找不到与名称匹配的Bean时才会按照类型来装配注入；</li><li>@Recourse的两个属性：<ul><li>name：指定Bean实例名称</li><li>type：指定Bean类型</li></ul></li></ul><ol start="3"><li>@Qualifier</li></ol><ul><li>与@Autowired注解配合使用。当@Autowired需要按照名称来装配注入时，则使用@Qualifier</li></ul><p>Spring IoC容器（ApplicationContext）负责创建和注入Bean。Spring提供使用XML配置、注解、Java配置以及groovy配置实现Bean的创建和注入。</p><h1 id="实例一-（基于注解的依赖注入）"><a href="#实例一-（基于注解的依赖注入）" class="headerlink" title="实例一 （基于注解的依赖注入）"></a>实例一 （基于注解的依赖注入）</h1><blockquote><p>步骤：<br>创建Web应用，导入jar包（Spring4件套、第三方依赖包和spring-aop（用于扫描注解））<br>创建Annotation包<br>在该包下创建DAO层<br>在该包下创建Service层<br>在该包下创建Controller层<br>创建配置类<br>创建测试类</p></blockquote><h3 id="Dao层代码"><a href="#Dao层代码" class="headerlink" title="Dao层代码"></a>Dao层代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> ;<br><span class="hljs-meta">@Repository</span><br><span class="hljs-comment">//等价于@Repository(name = &quot;theDao&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">theDao</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;testDao save&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Service层代码"><a href="#Service层代码" class="headerlink" title="Service层代码"></a>Service层代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> ;<br><span class="hljs-meta">@Service</span><br><span class="hljs-comment">//相当于@Service(&quot;theService&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">theService</span> &#123;<br>    <span class="hljs-meta">@Resource(name = &quot;theDao&quot;)</span><br>    <span class="hljs-comment">//相当于@Autowired，</span><br>    <span class="hljs-keyword">private</span> theDao testDao;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;testService save&quot;</span>);<br>        testDao.save();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Controller层代码"><a href="#Controller层代码" class="headerlink" title="Controller层代码"></a>Controller层代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> ;<br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">theController</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> theService testService;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">()</span> &#123;<br>        testService.save();<br>        System.out.println(<span class="hljs-string">&quot;testController save&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> ;<br><span class="hljs-meta">@Configuration</span>  <span class="hljs-comment">//声明当前类是配置类，相当于一个XML文件</span><br><span class="hljs-meta">@ComponentScan(&quot;annotation&quot;)</span>    <span class="hljs-comment">//自动扫描当前包下使用的注解，并注册为Bean</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Configannotation</span> &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> ;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestAnnotation</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">AnnotationConfigApplicationContext</span> <span class="hljs-variable">appCon</span> <span class="hljs-operator">=</span> <br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(Configannotation.class);<br>        <span class="hljs-type">theController</span> <span class="hljs-variable">tc</span> <span class="hljs-operator">=</span>appCon.getBean(theController.class);<br>        tc.save();<br>        appCon.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="实例二-（Java配置）"><a href="#实例二-（Java配置）" class="headerlink" title="实例二 （Java配置）"></a>实例二 （Java配置）</h1><p>Java配置是通过@Configuration和@Bean来实现的  </p><blockquote><p>@Configuration声明当前类作为一个配置类<br>@Bean注解在方法上，声明当前方法的返回值为一个Bean</p></blockquote><h3 id="Dao层代码-1"><a href="#Dao层代码-1" class="headerlink" title="Dao层代码"></a>Dao层代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> ;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">theDao</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;testDao save&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Service层代码-1"><a href="#Service层代码-1" class="headerlink" title="Service层代码"></a>Service层代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> ;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">theService</span> &#123;<br>    theDao testDao;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTestDao</span><span class="hljs-params">(theDao testDao)</span>&#123;<br>        <span class="hljs-built_in">this</span>.testDao = testDao;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">()</span> &#123;<br>        testDao.save();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Controller层代码-1"><a href="#Controller层代码-1" class="headerlink" title="Controller层代码"></a>Controller层代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> ;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">theController</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    theService testService;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTestService</span><span class="hljs-params">(theService testService)</span> &#123;<br>        <span class="hljs-built_in">this</span>.testService = testService;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">()</span> &#123;<br>        testService.save();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="配置类-1"><a href="#配置类-1" class="headerlink" title="配置类"></a>配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> ;<br><span class="hljs-meta">@Configuration</span>  <span class="hljs-comment">//声明当前类是配置类，相当于一个XML文件</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Configannotation</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> theDao <span class="hljs-title function_">getTestDao</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">theDao</span>();<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> theService <span class="hljs-title function_">getTestService</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">theService</span> <span class="hljs-variable">ts</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">theService</span>();<br>        ts.setTestDao(getTestDao());<br>        <span class="hljs-keyword">return</span> ts;<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> theController <span class="hljs-title function_">getTestController</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">theController</span> <span class="hljs-variable">ts</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">theController</span>();<br>        ts.setTestService(getTestService());<br>        <span class="hljs-keyword">return</span> ts;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="测试类-1"><a href="#测试类-1" class="headerlink" title="测试类"></a>测试类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> ;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestConfig</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//初始化Spring容器ApplicationContext</span><br>        <span class="hljs-type">AnnotationConfigApplicationContext</span> <span class="hljs-variable">appCon</span> <span class="hljs-operator">=</span> <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(Configannotation.class);<br>        <span class="hljs-type">theController</span> <span class="hljs-variable">tc</span> <span class="hljs-operator">=</span>appCon.getBean(theController.class);<br>        tc.save();<br>        appCon.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>控制反转是一种通过描述（可以是xml或注解）并通过第三方产生或获取特定对象的方式。<ul><li>在Spring中实现控制反转的是IoC容器</li><li>实现方法是依赖注入</li></ul></li><li>常用注解</li><li>两种Bean的创建和注入：通过对比可以看出，有时候使用Java配置反而更加繁琐。<ul><li>全局配置尽量使用Java配置</li><li>业务Bean的配置尽量使用注解配置</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;简单的对Spring IoC进行介绍,要求理解控制反转的概念；它是如何消减程序的耦合问题的？&lt;/p&gt;</summary>
    
    
    
    <category term="Spring教程" scheme="http://lexlady.top/categories/Spring%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="SpringBoot" scheme="http://lexlady.top/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://lexlady.top/2022/12/01/hello-world/"/>
    <id>http://lexlady.top/2022/12/01/hello-world/</id>
    <published>2022-12-01T10:01:38.542Z</published>
    <updated>2022-12-01T10:01:38.542Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
