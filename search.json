[{"title":"SpringIoC","url":"/2022/12/01/SpringIoC/","content":"简单的对Spring IoC进行介绍,要求理解控制反转的概念；它是如何消减程序的耦合问题的？\n\n基本概念下面从一个生活实例对控制反转进行解释（也称依赖注入(Dependency Injection,DI)，只是执行角度不同，是同一个概念）\n\n如果我们要吃饭，就可以有两种选择：一是自己做；另一种是下馆子。当我们要自己做时，就需要自己准备食材、进行烹饪。而下馆子只需要根据自己的需要让店家提供。控制反转的思想便包含在了上述的例子中：将执行操作交给Spring容器。由容器控制对象的创建以及查找并注入依赖的资源，而资源则集中管理，实现资源的可配置和易管理，降低了使用资源双方的依赖程度，松耦合\n\n常用注解\n在Spring框架中，仅管使用XML配置文件可以很简单地装配Bean，但对于需要配置大量的Bean时，其XML文件会过于庞大，不方便维护。  \n\n因此推荐使用注解(annotation)的方式去装配Bean\n声明Bean的注解\n@Component\n\n\n表示一个组件对象(Bean)\n作用于任何层次上\n无明确角色\n一个泛化的概念\n\n\n@Repository\n\n\n将数据访问层(Dao)的类标识为Bean\n功能与@Component相同\n\n\n@Service\n\n\n标注一个业务逻辑组件类（Service）\n功能与@Component相同\n\n\n@Controller\n\n\n用于标注一个控制器组件类（Spring MVC 的Controller）\n功能与@Component相同\n\n注入Bean的注解\n@Autowired\n\n\n可以对类成员变量、方法及构造方法进行标注，完成自动装配的工作\n消除setter getter方法\n\n\n@Resource\n\n\n与@Autowired功能一样\n区别：默认是按照名称来装配注入的，只有当找不到与名称匹配的Bean时才会按照类型来装配注入；\n@Recourse的两个属性：\nname：指定Bean实例名称\ntype：指定Bean类型\n\n\n\n\n@Qualifier\n\n\n与@Autowired注解配合使用。当@Autowired需要按照名称来装配注入时，则使用@Qualifier\n\nSpring IoC容器（ApplicationContext）负责创建和注入Bean。Spring提供使用XML配置、注解、Java配置以及groovy配置实现Bean的创建和注入。\n实例一 （基于注解的依赖注入）\n步骤：创建Web应用，导入jar包（Spring4件套、第三方依赖包和spring-aop（用于扫描注解））创建Annotation包在该包下创建DAO层在该包下创建Service层在该包下创建Controller层创建配置类创建测试类\n\nDao层代码import ;@Repository//等价于@Repository(name = &quot;theDao&quot;)public class theDao &#123;    public void save() &#123;        System.out.println(&quot;testDao save&quot;);    &#125;&#125;\nService层代码import ;@Service//相当于@Service(&quot;theService&quot;)public class theService &#123;    @Resource(name = &quot;theDao&quot;)    //相当于@Autowired，    private theDao testDao;    public void save() &#123;        System.out.println(&quot;testService save&quot;);        testDao.save();    &#125;&#125;\nController层代码import ;@Controllerpublic class theController &#123;    @Autowired    private theService testService;    public void save() &#123;        testService.save();        System.out.println(&quot;testController save&quot;);    &#125;&#125;\n配置类import ;@Configuration  //声明当前类是配置类，相当于一个XML文件@ComponentScan(&quot;annotation&quot;)    //自动扫描当前包下使用的注解，并注册为Beanpublic class Configannotation &#123;    ...&#125;\n测试类import ;public class TestAnnotation &#123;    public static void main(String[] args) &#123;        AnnotationConfigApplicationContext appCon =             new AnnotationConfigApplicationContext(Configannotation.class);        theController tc =appCon.getBean(theController.class);        tc.save();        appCon.close();    &#125;&#125;\n实例二 （Java配置）Java配置是通过@Configuration和@Bean来实现的  \n\n@Configuration声明当前类作为一个配置类@Bean注解在方法上，声明当前方法的返回值为一个Bean\n\nDao层代码import ;public class theDao &#123;    public void save() &#123;        System.out.println(&quot;testDao save&quot;);    &#125;&#125;\nService层代码import ;public class theService &#123;    theDao testDao;    public void setTestDao(theDao testDao)&#123;        this.testDao = testDao;    &#125;    public void save() &#123;        testDao.save();    &#125;&#125;\nController层代码import ;public class theController &#123;    @Autowired    theService testService;    public void setTestService(theService testService) &#123;        this.testService = testService;    &#125;    public void save() &#123;        testService.save();    &#125;&#125;\n配置类import ;@Configuration  //声明当前类是配置类，相当于一个XML文件public class Configannotation &#123;    @Bean    public theDao getTestDao() &#123;        return new theDao();    &#125;    @Bean    public theService getTestService() &#123;        theService ts = new theService();        ts.setTestDao(getTestDao());        return ts;    &#125;    @Bean    public theController getTestController() &#123;        theController ts = new theController();        ts.setTestService(getTestService());        return ts;    &#125;&#125;\n测试类import ;public class TestConfig &#123;    public static void main(String[] args) &#123;        //初始化Spring容器ApplicationContext        AnnotationConfigApplicationContext appCon =         new AnnotationConfigApplicationContext(Configannotation.class);        theController tc =appCon.getBean(theController.class);        tc.save();        appCon.close();    &#125;&#125;\n总结\n控制反转是一种通过描述（可以是xml或注解）并通过第三方产生或获取特定对象的方式。\n在Spring中实现控制反转的是IoC容器\n实现方法是依赖注入\n\n\n常用注解\n两种Bean的创建和注入：通过对比可以看出，有时候使用Java配置反而更加繁琐。\n全局配置尽量使用Java配置\n业务Bean的配置尽量使用注解配置\n\n\n\n","categories":["Spring教程"],"tags":["SpringBoot"]},{"title":"Hello World","url":"/2022/12/01/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"SpringAOP","url":"/2022/12/26/SpringAOP/","content":"Spring AOP是Spring框架体系结构中非常重要的功能模块之一；提供了面向切面编程实现。\n\nSpring AOP的基本概念AOP的概念AOP（Aspect-Oriented Programming）即面向切面编程，相应的就是OOP，面向对象编程。在OOP中，以类作为程序的基本单位，而在AOP中则是以切面作为基本单位。  \n\n在业务处理功能中，通常都有日志记录、事务处理、异常处理等操作，如果是使用OOP可以通过封装或继承的方法实现代码重写来应用到多个业务中，但仍存在同样的代码分散到各个方法中。因此，AOP采取横向抽取机制，将分散在各个方法中的重复代码提取出来，然后在程序编译或运行阶段，再将抽取出来的代码应用到需要执行的地方。  \n\n传统的OOP是无法实现这样的横向抽取机制，因为OOP实现的是父子的纵向重用。但AOP并不是OOP的替代品，而是对OOP的一种补充，进而相辅相成。\nAOP的基本术语\n切面（Aspect）指封装横切到系统功能的类  \n连接点（Joinpoint）指程序运行中的一些时间点（如方法的调用或异常的抛出）  \n切入点（Pointcut）指那些需要处理的连接点，在Spring AOP中，所有的方法执行都是连接点，而切入点是一个描述信息，用来修饰连接点，确定哪些连接点需要被处理。  \n通知（增强处理）由切面添加到特点的连接点（满足切入点规则）的一段代码，\n引入（Introduction）允许在现有的实现类中添加自定义的方法和属性  \n目标对象（Target Object）指所有被通知的对象。\n代理（Proxy）是通知应用到目标对象后，被动态创建的对象\n织入（Weaving）\n\n","tags":["SpringBoot"]},{"title":"Ethernaut","url":"/2023/02/25/Ether/","content":"此文章会记录在Ethernaut上经历的题。\n\nHello Ethernaut在第一题中，我们会跟着引导通过web终端进行操作，基本上没什么难度，一步步地按照提示来做就行。你甚至可以通过直接查看合约ABI来推断出答案，实在是太友好了！！收获：  \n\n关键字的使用\n各种变量的存储位置\n\n\nFallback任务要求：获取合约的所有权；将余额减为零\n解题点：\nreceive() external payable &#123;    require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);    owner = msg.sender;  &#125;```  &gt; receive方法&gt; * 一个合约至多含有一个receive()函数,&gt; * 没有function关键字、没有参数，没有返回值&gt; * 可见性必须声明为external，必须含有payable关键字&gt; * 允许使用modifier修改器&gt; &gt; 当本合约收到ether但并未被调用任何函数，未接受任何数据，receive函数被触发，执行ether的传输（类似于基本的send(),transfer()函数）；如果合约中不存在此类方法，但拥有一个可支付的回退函数将触发回退函数执行ether的操作；如果都不存在，那么合约将不能接受ether并抛出异常&gt; &gt; 选自[solidity官方文档v0.8.13](https://docs.soliditylang.org/en/v0.8.13/contracts.html#receive-ether-function)参考：1）执行实例中的contribute方法，向合约发送最多0.001ether。2）向合约发送以太，触发receive方法。3）执行实例中的withdraw方法---# Fallout任务要求：获取合约的所有权~~卖眼镜的做的题~~解题点：```soliditycontract Fallout is Ownable &#123;...function Fal1out() public payable &#123;...\n作为构造函数其名称居然与合约名称不一致，使其成为了任何人都可以执行的公共函数\n\n在solidity 0.4.22版本及其之后中使用function声明构造函数的方法被舍弃，而采用了使用关键字constructor来声明构造函数。\n\n这是在使用编译器0.4.22之前的版本时所需注意的\n\n\n参考：直接调用函数Fal1out\n\nCoin Flip任务要求：连续猜对硬币的正反面十次。区区千分之一的运气我也不是没有\n解题点：硬币的正反面取决于上一个块，结果看起来是随机的但却是可预测的，我们也可以通过获取上一个区块的信息来运行一次题目的算法然后选择对应的结果。因为在一个区块中的交易不止一个，所以只要保证在生成下一个区块前将完成操作即可。\n参考：获取实例地址在remix上部署一份攻击合约（只需要在获取结果后调用实例）之后连续使用攻击合约的方法进行攻击10次就行\n\n知识点SafeMath库：防溢出的增强型运算方法block.num：当前区块数block.blockhash：区块哈希值\n\n\nTelephone任务要求：获取合约的所有权\n解题点：\nfunction changeOwner(address _owner) public &#123;    if (tx.origin != msg.sender) &#123;      owner = _owner;    &#125;&#125;\n本题涉及到tx.origin与msg.sender的区别：前者表示交易的发送者，后者则表示消息的发送者。\n如果情景是在一个合约下的调用，那么这两者是木有区别的；但是如果是在多个合约的情况下，比如用户通过A合约来调用B合约，那么对于B合约来说，msg.sender就代表合约A，而tx.origin就代表用户。\n参考：在remix上部署另一个合约，通过该合约调用实例中的方法改变owner\n\nToken任务要求：获取更多的Token\n解题点：\nfunction transfer(address _to, uint _value) public returns (bool) &#123;    require(balances[msg.sender] - _value &gt;= 0);    balances[msg.sender] -= _value;    balances[_to] += _value;    return true;  &#125;\n这里可以通过下溢绕过require检测，因为_value和balance[]都为无符号整数，所以结果会变为2^256-1\n参考：略\n\nDelegation任务要求：获取合约的所有权\n分析：这题包含了两个合约Delegation和Delegate，Delegation合约实例化了Delegate合约，又在其Fallback函数中使用了delegatecall来调用了delegate合约。\n\ncall函数是一个能对合约发送数据与合约进行交互的底层接口（它们都接受一个 bytes memory 参数，并返回成功条件（作为一个 bool） 和返回的数据（ bytes memory）。而delegatecall又与call有所不同；通过delegatecall调用的目标地址的代码要在当前合约的环境中执行。这个函数主要是方便我们使用存在其他地方的函数（用户必须确保两个合约中的存储结构都适合使用delegatecall。）\n\n解题点：使用delegatecall调用delegate合约的pwn函数。\n\nForce任务要求：让合约的balance大于0\n解题点：MEOW~（不是）\n在以太坊中可以强制给一个合约发送以太，无论合约是否拒绝。通过函数selfdestruct来实现。\n\n这是一个自毁函数，当你调用它的时候，它会使该合约无效化并删除该地址的字节码，然后它会把合约里剩余的资金发送给参数所指定的地址，比较特殊的是这笔资金的发送将无视合约的fallback函数，因为我们之前也提到了当合约直接收到一笔不知如何处理的eth时会触发fallback函数，然而selfdestruct的发送的资金会无视这一点。\n\n因此我们只需要创建一个合约往合约中存点eth然后调用selfdestruct发送给实例合约就行。\n\nVault任务要求：将合约中的bool值改变\n解题点：输入密码废话\n任何数据在区块链上都是透明的！（战术后仰）通过web3中的getStorageAt函数直接获取合约里的状态变量的值\n\nweb3.eth.getStorageAt(address, position [, defaultBlock] [, callback])参数1：String 获取存储的地址；参数2：存储的索引位置；参数3：（可选）不使用web3.eth.defaultBlock设置的默认块，而是自定义或预定义的块号；参数4：（可选）可选回调，返回一个错误对象作为第一个参数，结果作为第二个参数Returns ：返回给定位置的值\n选自web3.eth官方文档\n\n\nKing任务要求：确保王位\n解题点：payable(king).transfer(msg.value);\n当新的国王诞生时将会给老国王原来的奖金，那么只要原来的国王不接受直接进行revert，那么就可以永远的占据合约的king\n参考：pragma ...contract attack&#123;  constructor (address _addr) public payable&#123;    _addr.call&#123;gas:100000000,value:msg.value&#125;;  &#125;  receive() external payable &#123;    revert();  &#125;&#125;Re-entrancy任务要求：盗取合约中的所有代币\n解题点：\nfunction withdraw(uint _amount) public &#123;    if(balances[msg.sender] &gt;= _amount) &#123;      (bool result,) = msg.sender.call&#123;value:_amount&#125;(&quot;&quot;);      if(result) &#123;        _amount;      &#125;      balances[msg.sender] -= _amount;    &#125;  &#125;\n\n重入的关键：发送完成后才进行了sender的balances更新，所以只需要使其不断进行call.value发送eth，同样使用Fallback函数来实现\n"}]